/*
#############################################################################################
# Global Agenda (1.5.1.5) SDK
# Generated with TheFeckless UE3 SDK Generator v1.4_Beta-Rev.51
# ========================================================================================= #
# File: TgGame_classes.h
# ========================================================================================= #
# Credits: uNrEaL, Tamimego, SystemFiles, R00T88, _silencer, the1domo, K@N@VEL
# Thanks: HOOAH07, lowHertz
# Forums: www.uc-forum.com, www.gamedeception.net
#############################################################################################
*/

#ifdef _MSC_VER
	#pragma pack ( push, 0x4 )
#endif

/*
# ========================================================================================= #
# Constants
# ========================================================================================= #
*/

#define CONST_AI_MV_PATROL                                       8
#define CONST_AI_MV_PATROL_SHORT_STOP                            1156
#define CONST_AI_MV_PATROL_LONG_STOP                             1157
#define CONST_AI_MV_WANDER                                       11
#define CONST_AI_MV_FOLLOW                                       15
#define CONST_AI_MV_FOLLOW_AT_GUN_RANGE                          233
#define CONST_AI_MV_FOLLOW_AT_MELEE_RANGE                        257
#define CONST_AI_MV_LOCATION                                     238
#define CONST_AI_MV_CIRCLE_ENEMY                                 630
#define CONST_AI_MV_LEAN_OUT                                     281
#define CONST_AI_MV_TAKE_COVER                                   282
#define CONST_AI_MV_BACKSTEP                                     918
#define CONST_AI_MV_BACK_THE_HELL_UP                             1096
#define CONST_AI_MV_SPIN                                         1176
#define CONST_AI_MV_DRIVE_BY                                     1196
#define CONST_AI_MV_SPREAD_OUT                                   931
#define CONST_AI_MV_DISMOUNT                                     100
#define CONST_AI_MV_TELEPORT                                     1558
#define CONST_AI_MV_NONE                                         2
#define CONST_AI_MD_PATROL_PATH                                  184
#define CONST_AI_MD_RANDOM                                       185
#define CONST_AI_MD_NEAREST_FRIEND                               186
#define CONST_AI_MD_NEAREST_HUMAN_FRIEND                         909
#define CONST_AI_MD_NEAREST_ROBOT_FRIEND                         910
#define CONST_AI_MD_NEAREST_ENEMY                                187
#define CONST_AI_MD_FRIEND_TO_HELP                               256
#define CONST_AI_MD_LAST_ATTACKER                                227
#define CONST_AI_MD_CURRENT_TARGET                               232
#define CONST_AI_MD_LAST_TARGET_LOC                              237
#define CONST_AI_MD_SPAWN_LOC                                    241
#define CONST_AI_MD_SAFETY_LOC                                   242
#define CONST_AI_MD_QUICKEST_COVER                               276
#define CONST_AI_MD_CLOSER_COVER                                 277
#define CONST_AI_MD_FURTHER_COVER                                278
#define CONST_AI_MD_CLOSEST_COVER                                692
#define CONST_AI_MD_TRIGGER_DESTINATION                          289
#define CONST_AI_MD_OWNER                                        310
#define CONST_AI_MD_NEAREST_ALARM                                471
#define CONST_AI_MD_CURRENT_OBJECTIVE                            904
#define CONST_AI_MD_CLOSEST_ENEMY_OBJECTIVE                      1490
#define CONST_AI_MD_CLOSEST_FRIENDLY_OBJECTIVE                   1489
#define CONST_AI_MD_COMMAND_DESTINATION                          711
#define CONST_AI_MD_CLOSER_COVER_FOR_CD                          732
#define CONST_AI_MD_FORMATION                                    735
#define CONST_AI_MD_NEAREST_TURRET_POINT                         955
#define CONST_AI_MD_NEAREST_SNIPER_POINT                         972
#define CONST_AI_MD_NEAREST_VOLUME_PATHNODE_TO_TARGET            1578
#define CONST_AI_MD_NEAREST_PET_SPAWN_POINT                      1579
#define CONST_AI_MD_NONE                                         196
#define CONST_AI_PC_RUN                                          356
#define CONST_AI_PC_WALK                                         357
#define CONST_AI_PC_CROUCH                                       358
#define CONST_AI_LA_TARGET                                       429
#define CONST_AI_LA_DESTINATION                                  430
#define CONST_AI_LA_ACTION_POINT                                 631
#define CONST_AI_LA_COMMAND_DESTINATION                          736
#define CONST_AI_LA_OWNER_FACING                                 738
#define CONST_AI_LA_OWNER                                        737
#define CONST_AI_LA_ENEMY_ASSAULT_POINT                          953
#define CONST_AI_AC_USE_DEVICE                                   17
#define CONST_AI_AC_CHECK_DEVICE_PROXIMITY                       491
#define CONST_AI_AC_NONE                                         16
#define CONST_AI_AC_CALL_FOR_HELP                                249
#define CONST_AI_AC_RADIO_ALARM                                  620
#define CONST_AI_AC_DO_BLOCK                                     766
#define CONST_AI_AC_BREAK_BLOCK                                  767
#define CONST_AI_AC_UNEQUIP                                      802
#define CONST_AI_AC_SEARCH                                       821
#define CONST_AI_AC_CHECK_DEVICE_ANGLE                           822
#define CONST_AI_AC_USE_DEVICE_LAGGED                            1170
#define CONST_AI_AC_USE_DEVICE_SPREAD                            1178
#define CONST_AI_AC_SET_PHASE                                    1059
#define CONST_AI_AC_SET_PHASE01                                  1060
#define CONST_AI_AC_SET_PHASE02                                  1061
#define CONST_AI_AC_SET_PHASE03                                  1062
#define CONST_AI_AC_SET_PHASE04                                  1063
#define CONST_AI_AC_SET_PHASE05                                  1064
#define CONST_AI_AC_IGNORE_ALARM                                 1190
#define CONST_AI_AC_DESPAWN                                      1272
#define CONST_AI_AC_DESPAWN_ALARM_BOTS                           1318
#define CONST_AI_AC_SUB_BEHAVIOR                                 1515
#define CONST_AI_AC_SPAWN_PETS                                   1516
#define CONST_AI_AT_SELF                                         57
#define CONST_AI_AT_NEAREST_ENEMY                                3
#define CONST_AI_AT_NEAREST_TAUNTER                              835
#define CONST_AI_AT_NEAREST_FRIEND                               60
#define CONST_AI_AT_NEAREST_HUMAN_FRIEND                         911
#define CONST_AI_AT_NEAREST_ROBOT_FRIEND                         912
#define CONST_AI_AT_NEAREST_HUMAN_ENEMY                          959
#define CONST_AI_AT_NEAREST_ROBOT_ENEMY                          960
#define CONST_AI_AT_NEAREST_ASSAULT_FRIEND                       968
#define CONST_AI_AT_NEAREST_MEDIC_ENEMY                          969
#define CONST_AI_AT_NEAREST_ASSAULT_ENEMY                        1086
#define CONST_AI_AT_NEAREST_RECON_ENEMY                          1087
#define CONST_AI_AT_NEAREST_ROBOTICS_ENEMY                       1088
#define CONST_AI_AT_NEAREST_DEPLOY_ENEMY                         1476
#define CONST_AI_AT_NEAREST_PLAYER                               1161
#define CONST_AI_AT_RANDOM_PLAYER                                1274
#define CONST_AI_AT_RANDOM_PLAYER_IN_LOS                         1409
#define CONST_AI_AT_FRIEND_TO_HELP                               254
#define CONST_AI_AT_FRIENDS_ATTACKER                             255
#define CONST_AI_AT_FRIENDS_TARGET                               689
#define CONST_AI_AT_LAST_ATTACKER                                228
#define CONST_AI_AT_CURRENT_TARGET                               231
#define CONST_AI_AT_TRIGGER_TARGET                               288
#define CONST_AI_AT_OBJECTIVE_BOT                                1402
#define CONST_AI_AT_OWNER_LAST_ATTACKER                          313
#define CONST_AI_AT_OWNER_LAST_ATTACKED                          314
#define CONST_AI_AT_OWNER                                        344
#define CONST_AI_AT_OWNER_TARGET                                 1408
#define CONST_AI_AT_WEAKEST_ENEMY                                315
#define CONST_AI_AT_WEAKEST_FRIEND                               316
#define CONST_AI_AT_WEAKEST_HUMAN_FRIEND                         913
#define CONST_AI_AT_WEAKEST_ROBOT_FRIEND                         914
#define CONST_AI_AT_HIGHEST_RECENT_THREAT                        818
#define CONST_AI_AT_CLEAR                                        362
#define CONST_AI_AT_COMMAND_TARGET                               710
#define CONST_AI_AT_CLOSEST_ENEMY_OBJECTIVE                      1492
#define CONST_AI_AT_CLOSEST_FRIENDLY_OBJECTIVE                   1491
#define CONST_AI_AT_NONE                                         136
#define CONST_AI_COMP_EQUAL                                      193
#define CONST_AI_COMP_GREATER                                    194
#define CONST_AI_COMP_LESS                                       195
#define CONST_AI_COMP_NOT_EQUAL                                  1094
#define CONST_AI_COMMAND_FOLLOW                                  707
#define CONST_AI_COMMAND_GOTO                                    708
#define CONST_AI_COMMAND_ATTACK                                  709
#define CONST_AI_TEST_ENEMY_RECENTLY_UNSTEALTHED                 1155
#define CONST_AI_TEST_ENEMY_SIGHTED                              470
#define CONST_AI_TEST_ENEMY_TAUNT_SIGHTED                        834
#define CONST_AI_TEST_TIME_SINCE_SAW_DEAD_FRIEND                 490
#define CONST_AI_TEST_NUM_HUMAN_FRIENDS                          1293
#define CONST_AI_TEST_NUM_ENEMY_SIGHTED                          188
#define CONST_AI_TEST_NUM_ENEMY_IN_GUN_RANGE                     189
#define CONST_AI_TEST_NUM_ENEMY_IN_MELEE_RANGE                   245
#define CONST_AI_TEST_HEAR_SOUND                                 259
#define CONST_AI_TEST_TARGET_IN_GUN_RANGE                        244
#define CONST_AI_TEST_TARGET_IN_MELEE_RANGE                      243
#define CONST_AI_TEST_TARGET_IN_LOS                              285
#define CONST_AI_TEST_HAS_ENEMY_TARGET                           234
#define CONST_AI_TEST_HAS_FRIENDLY_TARGET                        295
#define CONST_AI_TEST_HAS_LAST_LOCATION                          236
#define CONST_AI_TEST_HAS_LAST_ATTACKER                          260
#define CONST_AI_TEST_HAS_SAFETY_LOCATION                        253
#define CONST_AI_TEST_HAS_CURRENT_OBJECTIVE                      908
#define CONST_AI_TEST_HAS_OBJECTIVE_BOT                          1401
#define CONST_AI_TEST_OBJECTIVE_BOT_IS_FRIENDLY                  1451
#define CONST_AI_TEST_HAS_ENEMY_OBJECTIVE                        1495
#define CONST_AI_TEST_HAS_ENEMY_OBJECTIVE_BOT                    1496
#define CONST_AI_TEST_HAS_FRIENDLY_OBJECTIVE                     1493
#define CONST_AI_TEST_HAS_FRIENDLY_OBJECTIVE_BOT                 1494
#define CONST_AI_TEST_HAS_RECENT_THREAT                          1264
#define CONST_AI_TEST_RECENT_THREAT_IN_LOS                       1265
#define CONST_AI_TEST_CURRENT_OBJECTIVE_PERCENT                  716
#define CONST_AI_TEXT_DAMAGE_TAKEN_THIS_PHASE                    1382
#define CONST_AI_TEST_HELP_REQUESTED                             190
#define CONST_AI_TEST_HAS_HELP                                   252
#define CONST_AI_TEST_FRIEND_TO_HELP_HAS_TARGET                  690
#define CONST_AI_TEST_FRIEND_TO_HELP_HAS_ATTACKER                691
#define CONST_AI_TEST_HEALTH_LEVEL                               191
#define CONST_AI_TEST_POWER_POOL_PERCENT                         919
#define CONST_AI_TEST_RECENT_DAMAGE                              192
#define CONST_AI_TEST_RANDOM                                     216
#define CONST_AI_TEST_HAS_PATROL_PATH                            235
#define CONST_AI_TEST_NUM_FRIENDS_IN_VISION_RANGE                267
#define CONST_AI_TEST_NUM_FRIENDS_IN_ASSIST_RANGE                268
#define CONST_AI_TEST_AT_LAST_TARGET_LOC                         269
#define CONST_AI_TEST_AT_SPAWN_LOC                               270
#define CONST_AI_TEST_AT_SAFETY_LOC                              271
#define CONST_AI_TEST_AT_COVER                                   273
#define CONST_AI_TEST_AT_COVER_FOR_TARGET                        274
#define CONST_AI_TEST_CLOSER_COVER_FOR_TARGET                    275
#define CONST_AI_TEST_FURTHER_COVER_FOR_TARGET                   279
#define CONST_AI_TEST_IN_DRIVE_BY                                1198
#define CONST_AI_TEST_HAS_DRIVE_BY_PATH                          1197
#define CONST_AI_TEST_HAS_TRIGGER_TARGET                         286
#define CONST_AI_TEST_HAS_TRIGGER_DESTINATION                    287
#define CONST_AI_TEST_AT_TRIGGER_DESTINATION                     290
#define CONST_AI_TEST_HAS_COMMAND_TARGET                         712
#define CONST_AI_TEST_HAS_COMMAND_DESTINATION                    713
#define CONST_AI_TEST_AT_COMMAND_DESTINATION                     714
#define CONST_AI_TEST_HAS_COMMAND_FOLLOW                         715
#define CONST_AI_TEST_CLOSER_COVER_FOR_COMM_DEST                 733
#define CONST_AI_TEST_DISTANCE_FROM_COMM_DEST                    734
#define CONST_AI_TEST_EQUIP_1_READY                              481
#define CONST_AI_TEST_EQUIP_2_READY                              280
#define CONST_AI_TEST_EQUIP_3_READY                              381
#define CONST_AI_TEST_EQUIP_4_READY                              382
#define CONST_AI_TEST_EQUIP_5_READY                              482
#define CONST_AI_TEST_EQUIP_6_READY                              483
#define CONST_AI_TEST_EQUIP_7_READY                              383
#define CONST_AI_TEST_EQUIP_8_READY                              384
#define CONST_AI_TEST_EQUIP_9_READY                              484
#define CONST_AI_TEST_EQUIP_10_READY                             485
#define CONST_AI_TEST_EQUIP_1_IN_RANGE                           693
#define CONST_AI_TEST_EQUIP_2_IN_RANGE                           694
#define CONST_AI_TEST_EQUIP_3_IN_RANGE                           695
#define CONST_AI_TEST_EQUIP_4_IN_RANGE                           696
#define CONST_AI_TEST_EQUIP_5_IN_RANGE                           697
#define CONST_AI_TEST_EQUIP_6_IN_RANGE                           698
#define CONST_AI_TEST_EQUIP_7_IN_RANGE                           699
#define CONST_AI_TEST_EQUIP_8_IN_RANGE                           700
#define CONST_AI_TEST_EQUIP_9_IN_RANGE                           701
#define CONST_AI_TEST_EQUIP_10_IN_RANGE                          702
#define CONST_AI_TEST_ATTACKER_IN_EQUIP_2_IN_RANGE               824
#define CONST_AI_TEST_ATTACKER_IN_EQUIP_3_IN_RANGE               825
#define CONST_AI_TEST_THREAT_IN_EQUIP_2_IN_RANGE                 826
#define CONST_AI_TEST_THREAT_IN_EQUIP_3_IN_RANGE                 827
#define CONST_AI_TEST_HAS_OWNER                                  308
#define CONST_AI_TEST_DISTANCE_FROM_OWNER                        309
#define CONST_AI_TEST_DISTANCE_FROM_SOUND                        819
#define CONST_AI_TEST_DISTANCE_FROM_SPAWN                        688
#define CONST_AI_TEST_DISTANCE_FROM_TARGET                       346
#define CONST_AI_TEST_DIST_FROM_NEAREST_ENEMY                    420
#define CONST_AI_TEST_DIST_FROM_LAST_ATTACKER                    424
#define CONST_AI_TEST_DIST_FROM_HELP_REQUEST                     809
#define CONST_AI_TEST_DIST_FROM_QUICKEST_COVER                   811
#define CONST_AI_TEST_DIST_FROM_TRIGGER_DEST                     905
#define CONST_AI_TEST_DIST_FROM_CURRENT_OBJECTIVE                906
#define CONST_AI_TEST_DIST_FROM_NEAREST_FRIEND                   917
#define CONST_AI_TEST_OWNER_HAS_LAST_ATTACKER                    311
#define CONST_AI_TEST_OWNER_HAS_LAST_ATTACKED                    312
#define CONST_AI_TEST_OWNER_HEALTH                               345
#define CONST_AI_TEST_OWNER_PHASE                                1406
#define CONST_AI_TEST_OWNER_HAS_TARGET                           1410
#define CONST_AI_TEST_OWNER_IS_PATROLLING                        1414
#define CONST_AI_TEST_CURRENT_TARGET_HEALTH                      317
#define CONST_AI_TEST_POSTURE_IS_HIBERNATE                       340
#define CONST_AI_TEST_FRIEND_TO_ENEMY_RATIO                      341
#define CONST_AI_TEST_TARGET_HEALTH_RATIO                        920
#define CONST_AI_TEST_WEAKEST_FRIEND_HEALTH                      343
#define CONST_AI_TEST_WEAKEST_HUMAN_FRIEND_HEALTH                915
#define CONST_AI_TEST_WEAKEST_ROBOT_FRIEND_HEALTH                916
#define CONST_AI_TEST_TIME_SINCE_ENTERED_COMBAT                  1479
#define CONST_AI_TEST_TIME_SINCE_LEFT_COMBAT                     1480
#define CONST_AI_TEST_TIME_SINCE_TARGET_IN_LOS                   359
#define CONST_AI_TEST_RECENT_AOE_DAMAGE                          360
#define CONST_AI_TEST_THREATENED_BY_GRENADE                      481
#define CONST_AI_TEST_TARGET_IS_LAST_ATTACKER                    355
#define CONST_AI_TEST_LAST_ATTACKER_IN_LOS                       361
#define CONST_AI_TEST_NONE                                       197
#define CONST_AI_TEST_TARGET_CAN_BE_REPAIRED                     723
#define CONST_AI_TEST_TARGET_BLOCKING                            776
#define CONST_AI_TEST_TARGET_MELEE_EQUIPPED                      777
#define CONST_AI_TEST_TARGET_IN_MELEE_ATTACK                     778
#define CONST_AI_TEST_TARGET_STUNNED                             801
#define CONST_AI_TEST_TARGET_STEALTHED                           805
#define CONST_AI_TEST_TARGET_IS_OBJECTIVE_BOT                    1415
#define CONST_AI_TEST_TARGET_IN_VOLUME                           1440
#define CONST_AI_TEST_CURRENT_PHASE                              1066
#define CONST_AI_TEST_TIME_SINCE_ACQUIRED_TARGET                 1090
#define CONST_AI_TEST_TIME_SINCE_START_PHASE                     1065
#define CONST_AI_TEST_TIME_SINCE_HEAR_SOUND                      363
#define CONST_AI_TEST_TIME_SINCE_HEAR_HELP_CALL                  364
#define CONST_AI_TEST_TIME_SINCE_MADE_HELP_CALL                  619
#define CONST_AI_TEST_TIME_SINCE_RADIO_ALARM                     629
#define CONST_AI_TEST_TIME_SINCE_LAST_PET_SPAWN                  1517
#define CONST_AI_TEST_TIME_SINCE_ACTION_POINT                    665
#define CONST_AI_TEST_TIME_SINCE_HIT_TARGET                      1269
#define CONST_AI_TEST_TIME_SINCE_HIT_ENEMY                       1273
#define CONST_AI_TEST_TIME_SINCE_LAST_EVENT                      1484
#define CONST_AI_TEST_TIME_SINCE_SPAWNED                         1486
#define CONST_AI_TEST_LAST_EVENT_NUMBER                          1485
#define CONST_AI_TEST_NUMBER_ACTIVE_SPAWNED_PETS                 1518
#define CONST_AI_TEST_HAS_VALID_NEARBY_PET_SPAWN_POINT           1580
#define CONST_AI_TEST_AT_VALID_PET_SPAWN_POINT                   1581
#define CONST_AI_TEST_NEAREST_ALARM_DISTANCE                     472
#define CONST_AI_TEST_AT_OPEN_RELAX_POINT                        518
#define CONST_AI_TEST_AT_WALL_RELAX_POINT                        655
#define CONST_AI_TEST_AT_DEFAULT_MINE_POINT                      519
#define CONST_AI_TEST_AT_STANDARD_CONSOLE_POINT                  657
#define CONST_AI_TEST_AT_DEFAULT_LAB_CONSOLE_POINT               658
#define CONST_AI_TEST_AT_NORMAL_GUARD_WATCH                      659
#define CONST_AI_TEST_AT_ELEVATED_GUARD_WATCH                    660
#define CONST_AI_TEST_AT_DEFAULT_FACTORY_LINE                    661
#define CONST_AI_TEST_IS_TARGET_POISONED                         926
#define CONST_AI_TEST_IS_TARGET_INVULNERABLE                     927
#define CONST_AI_TEST_TARGET_AOE_PROTECTION                      928
#define CONST_AI_TEST_TARGET_RANGE_PROTECTION                    929
#define CONST_AI_TEST_TARGET_MELEE_PROTECTION                    930
#define CONST_AI_TEST_MISSION_IN_SETUP                           970
#define CONST_AI_TEST_MISSION_TIME_REMAINING                     932
#define CONST_AI_TEST_AM_I_INVINCIBLE                            938
#define CONST_AI_TEST_AM_I_POISONED                              939
#define CONST_AI_TEST_AM_I_STEALTHED                             1247
#define CONST_AI_TEST_IS_BEHIND_TARGET                           940
#define CONST_AI_TEST_IS_ALARM_BOT                               1159
#define CONST_AI_TEST_AM_I_ON_FIRE                               1590
#define CONST_AI_TEST_AM_I_DEBUFFED                              1591
#define CONST_AI_TEST_TARGET_IS_ASSAULT                          946
#define CONST_AI_TEST_TARGET_IS_MEDIC                            947
#define CONST_AI_TEST_TARGET_IS_RECON                            948
#define CONST_AI_TEST_TARGET_IS_ROBOTICS                         949
#define CONST_AI_TEST_TARGET_IS_HIGHEST_THREAT                   979
#define CONST_AI_TEST_TARGET_IS_LAST_TAUNTER                     1257
#define CONST_AI_TEST_TARGET_IS_OWNER                            1575
#define CONST_AI_TEST_DIST_FROM_NEAREST_TURRET_POINT             954
#define CONST_AI_TEST_DIST_FROM_NEAREST_SNIPER_POINT             971
#define CONST_AI_TEST_TARGET_IN_INDIRECT_FIRE                    1168
#define CONST_AI_TEST_RECENT_TARGET_DIED                         1191
#define CONST_AI_TEST_DIST_FROM_NEAREST_ROBOT_ENEMY              957
#define CONST_AI_TEST_DIST_FROM_NEAREST_HUMAN_ENEMY              958
#define CONST_AI_TEST_DIST_FROM_NEAREST_ASSAULT_FRIEND           967
#define CONST_AI_TEST_IS_ATTACKER_TASKFORCE                      978
#define CONST_AI_TEST_DIST_FROM_NEAREST_ENEMY_MEDIC              966
#define CONST_AI_TEST_DIST_FROM_NEAREST_ENEMY_ASSAULT            1083
#define CONST_AI_TEST_DIST_FROM_NEAREST_ENEMY_RECON              1084
#define CONST_AI_TEST_DIST_FROM_NEAREST_ENEMY_ROBOTICS           1085
#define CONST_AI_TEST_ENEMY_ASSAULT_IN_LOS                       1248
#define CONST_AI_TEST_ENEMY_MEDIC_IN_LOS                         1249
#define CONST_AI_TEST_ENEMY_RECON_IN_LOS                         1250
#define CONST_AI_TEST_ENEMY_ROBOTICS_IN_LOS                      1251
#define CONST_AI_TEST_NUM_HUMAN_ENEMIES_IN_BOSS_ROOM             1316
#define CONST_AI_TEST_NUM_ALARM_BOTS_IN_BOSS_ROOM                1317
#define CONST_AI_TEST_TARGET_IS_REACHABLE                        1340
#define CONST_AI_TEST_MINIONS_IN_HELP_RANGE                      1416
#define CONST_AI_TEST_ENEMY_DEPLOYABLE_IN_LOS                    1473
#define CONST_AI_TEST_DIST_NEAREST_ENEMY_DEPLOYABLE              1474
#define CONST_AI_TEST_TARGET_IS_DEPLOYABLE                       1475
#define CONST_AI_TEST_TARGET_HAS_VORTEX                          1576
#define CONST_AI_TEST_AM_I_TAUNTER                               1600
#define CONST_AI_TEST_MAXIMUM                                    1601
#define CONST_AI_MEMORY_THRESHOLD                                30
#define CONST_MINSTRAFEDIST                                      200
#define CONST_AI_DEFAULT_DISTANCE_OFFSET                         50
#define CONST_AI_DEFAULT_MODE                                    -1
#define CONST_AI_COVER_CHECK_RANGE                               1000
#define CONST_AI_ALARM_CHECK_RANGE                               10000
#define CONST_FAIL_PERCENTAGE_TEST                               101
#define CONST_AI_INVALID_TIME                                    -10000
#define CONST_AI_MAX_DISTANCE                                    10000
#define CONST_AI_BOT_TICK_SECONDS                                1.0
#define CONST_AI_MIN_PAUSE_SECONDS                               0.1
#define CONST_AI_ACTION_DELAY                                    10
#define CONST_AI_ACTION_REUSE_DELAY                              40
#define CONST_AI_ALARM_MAX_OFFSET_Z                              200
#define CONST_AI_MAX_DISTANCE_FROM_OWNER                         1000
#define CONST_AI_CHECK_FIRE_ANGLE                                0.90
#define CONST_AI_LAGGED_FIRE_ANGLE                               0.30
#define CONST_AI_TEAM_PASSTHRU_DISTANCE                          350
#define CONST_AI_REGEN_TICK                                      10
#define CONST_AI_HEALTH_REGEN                                    0.05
#define CONST_AI_MAXIMUM_TREE_DEPTH                              20
#define CONST_AI_PHYSICAL_ANY                                    0
#define CONST_AI_PHYSICAL_BIO                                    860
#define CONST_AI_PHYSICAL_MECH                                   861
#define CONST_AI_PHYSICAL_CYBORG                                 973
#define CONST_AI_PROFILE_ANY                                     0
#define CONST_AI_PROFILE_MEDIC                                   941
#define CONST_AI_PROFILE_RECON                                   942
#define CONST_AI_PROFILE_ASSAULT                                 943
#define CONST_AI_PROFILE_ROBOTICS                                944
#define CONST_AI_SQUAD_ROLE_LEADER                               1404
#define CONST_AI_SQUAD_ROLE_FOLLOWER                             1405
#define CONST_MAX_HEAD_MORPH_POSES                               82
#define CONST_GLOBAL_OFFHAND_COOLDOWN                            1.0
#define CONST_GLOBAL_OFFHAND_CLIENT_COOLDOWN_START               0.75
#define CONST_MAX_DEVICE_EQPOINT                                 15
#define CONST_HEARTBEAT_TIME_FOR_SOUNDMAKING                     4.0
#define CONST_MINTIMEBETWEENPAINSOUNDS                           0.35
#define CONST_CRAFTING_PAWN_SFX_ID                               1154
#define CONST_MAX_NUM_DEPLOYED_BOTS                              3
#define CONST_TG_MAX_SEE_FLAG                                    8
#define CONST_TG_MAX_DISPLAY_FLAG                                7
#define CONST_MSG_COMBAT_DAMAGE                                  10963
#define CONST_MSG_COMBAT_DEATH                                   10964
#define CONST_MSG_COMBAT_BACKSTAB                                20589
#define CONST_MSG_COMBAT_FALLING                                 42151
#define CONST_MSG_COMBAT_HEAL                                    10965
#define CONST_MSG_COMBAT_REPAIR                                  16009
#define CONST_MSG_COMBAT_STUN                                    42148
#define CONST_MSG_COMBAT_BLOCK                                   42149
#define CONST_MSG_COMBAT_BLOCK_BREAK                             42150
#define CONST_PROCESS_COMBAT_MESSAGE_RATE                        0.20
#define CONST_ASSAULT_PROFILE_ID                                 680
#define CONST_ROBOTICS_PROFILE_ID                                679
#define CONST_INFILTRATOR_PROFILE_ID                             681
#define CONST_MEDIC_PROFILE_ID                                   567
#define CONST_AGENT_PROFILE_ID                                   1148
#define CONST_DEVTEST_PROFILE_ID                                 255
#define CONST_TG_ASSIST_TIMEOUT                                  10
#define CONST_DAMAGE_CAP_HEALTH_START_PERC                       90
#define CONST_DAMAGE_CAP_HEALTH_END_PERC                         10
#define CONST_TG_MAX_FLASH_EVENTS                                32
#define CONST_TG_SENSOR_TICK_SECONDS                             1
#define CONST_TG_DEFAULT_TAG_ICON_DIMENSION                      32
#define CONST_TG_MAX_SENSOR_ALERT                                5
#define CONST_MAX_NBR_OF_DAMAGEINFO                              8
#define CONST_TG_GENDER_FEMALE                                   852
#define CONST_TG_GENDER_MALE                                     853
#define CONST_TG_GENDER_GENERIC                                  854
#define CONST_TG_AUDIO_GROUP_MALE                                60
#define CONST_TG_AUDIO_GROUP_FEMALE                              61
#define CONST_TG_PHYSICALITY_BIOLOGICAL                          860
#define CONST_TG_PHYSICALITY_MECHANICAL                          861
#define CONST_TG_PHYSICALITY_CYBORG                              973
#define CONST_TG_INVULNERABLE_EFFECT_GROUP                       8698
#define CONST_TG_MAX_PAWN_HEIGHT                                 108
#define CONST_TG_TARGET_FRIENDLY_HEALTH_DIST                     1800
#define CONST_TG_STAT_FADING_DIST                                1300
#define CONST_TG_MIN_AIM_TRACE_LENGTH                            160
#define CONST_TG_BASE_DAMAGE                                     1000
#define CONST_TG_AUTO_HELP_HEALTH_PERCENTAGE                     25.0f
#define CONST_TG_MAX_MORPH_INDEX                                 255
#define CONST_TG_STEALTH_GENERAL                                 1037
#define CONST_TG_STEALTH_RESIST_SENSOR                           1038
#define CONST_TG_STEALTH_RESIST_SCANNER                          1039
#define CONST_TG_STEALTH_RESIST_BOTH                             1047
#define CONST_TG_RANK_ELITE                                      1048
#define CONST_TG_RANK_HUNTER                                     1049
#define CONST_TG_RANK_BOSS                                       1050
#define CONST_TG_RANK_SUPPORT                                    1051
#define CONST_TG_RANK_MINION                                     1052
#define CONST_TG_RANK_BYSTANDER                                  1053
#define CONST_TG_SPAWNFX_VALID_DURATION                          5
#define CONST_TG_MAX_DYE_SLOT                                    5
#define CONST_TG_MAX_SCANNER_SETTINGS                            2
#define CONST_EQ_MAX_LOAD_DEVICE                                 15
#define CONST_TG_DEVICE_TYPE_RANGE                               0
#define CONST_TG_DEVICE_TYPE_MELEE                               1
#define CONST_TG_DEVICE_TYPE_OFFHAND                             2
#define CONST_TG_DEVICE_TYPE_NEWMELEE                            3
#define CONST_TG_DEPLOYABLE_USE_TYPE_READY                       0
#define CONST_TG_DEPLOYABLE_USE_TYPE_DEPLOY                      1
#define CONST_TG_DEPLOYABLE_USE_TYPE_INTERRUPT                   2
#define CONST_TG_DEPLOYABLE_USE_TYPE_RETRIEVE                    3
#define CONST_TG_DEPLOYABLE_USE_TYPE_PUTAWAY                     4
#define CONST_TG_MELEE_ANIM_ACTIVE                               0
#define CONST_TG_MELEE_ANIM_ATTACK_RIGHT                         1
#define CONST_TG_MELEE_ANIM_ATTACK_LEFT                          2
#define CONST_TG_MELEE_ANIM_POST_ATTACK_POSE                     3
#define CONST_TG_MELEE_ANIM_POST_ATTACK_POSE_JUMP                4
#define CONST_TG_MELEE_ANIM_POST_ATTACK_POSE_CROUCH              5
#define CONST_TG_MELEE_ANIM_RETRIEVE                             6
#define CONST_TG_MELEE_ANIM_PUTAWAY                              7
#define CONST_TG_MELEE_USE_TYPE_READY                            0
#define CONST_TG_MELEE_USE_TYPE_FIRE                             1
#define CONST_TG_MELEE_USE_TYPE_RETRIEVE                         2
#define CONST_TG_MELEE_USE_TYPE_PUTAWAY                          3
#define CONST_TG_MELEE_USE_TYPE_BLOCKSTUN                        4
#define CONST_TG_OFFHAND_USE_TYPE_DEPLOY                         0
#define CONST_TG_OFFHAND_USE_TYPE_INTERRUPT                      1
#define CONST_TG_RANGE_USE_TYPE_READY                            0
#define CONST_TG_RANGE_USE_TYPE_FIRE                             1
#define CONST_TG_RANGE_USE_TYPE_FIRE2                            2
#define CONST_TG_RANGE_USE_TYPE_RETRIEVE                         3
#define CONST_TG_RANGE_USE_TYPE_PUTAWAY                          4
#define CONST_TG_RANGE_USE_TYPE_MODESWITCH                       5
#define CONST_TG_RANGE_USE_TYPE_BUILDUP                          6
#define CONST_TG_RANGE_USE_TYPE_LOWERBODY                        7
#define CONST_TG_MELEE_WEAPON_ANIM_IDLE                          0
#define CONST_TG_MELEE_WEAPON_ANIM_ATTACK                        1
#define CONST_TG_PICKUP_BOT_FLAG                                 2926
#define CONST_BOT_ENCOUNTER_DESPAWN_TIME                         60
#define CONST_COVER_DEFAULT_RANGE                                150
#define CONST_TGDPT_DEFAULT                                      666
#define CONST_TGDPT_HEALTHCRATE                                  667
#define CONST_DEPLOYABLE_STARTING_HEALTH_PCT                     0.10f
#define CONST_MAX_NBR_OF_DPL_DAMAGEINFO                          8
#define CONST_TGIFGT_FOOTSTEP_RUN                                760
#define CONST_TGIFGT_FOOTSTEP_WALK                               815
#define CONST_TGIFGT_FOOTSTEP_SCUFF                              816
#define CONST_TGIFGT_GRENADE_BOUNCE                              761
#define CONST_TGIFGT_WEAPON_IMPACT                               762
#define CONST_TGIFGT_SKYDIVING_IMPACT                            763
#define CONST_TG_BEACON_EXIT_DEPLOYABLE_ID                       36
#define CONST_TG_BEACON_ENTRANCE_DEPLOYABLE_ID                   48
#define CONST_TG_MAX_DEPLOYABLE_SENSOR_COUNTER                   30
#define CONST_TG_MAX_DEPLOYABLE_SENSOR_AUDIO_WARNING_LENGTH      2
#define CONST_TGTT_ATTACK_NA                                     83
#define CONST_TGTT_ATTACK_INSTANT_RANGED                         85
#define CONST_TGTT_ATTACK_THROWN                                 87
#define CONST_TGTT_ATTACK_PLACE_DEPLOYABLE                       209
#define CONST_TGTT_ATTACK_PROJECTILE_RANGED                      177
#define CONST_TGTT_ATTACK_MELEE                                  170
#define CONST_TGTT_ATTACK_SPAWN_PET                              306
#define CONST_TGTT_ATTACK_INSTANT_DEPLOYABLE                     342
#define CONST_TGTT_ATTACK_INSTANT_BOT                            817
#define CONST_TGTT_ATTACK_POWER_DOWN                             239
#define CONST_TGTT_ATTACK_SELF_DEPLOYABLE                        876
#define CONST_TGTT_ATTACK_ARTILLERY_STRIKE                       1177
#define CONST_TGTT_ATTACK_TELEPORT                               1442
#define CONST_TGTT_TARGET_SELF                                   214
#define CONST_TGTT_TARGET_FRIEND                                 213
#define CONST_TGTT_TARGET_ENEMY                                  212
#define CONST_TGTT_TARGET_ALL                                    703
#define CONST_TGTT_TARGET_ENEMY_AND_SELF                         846
#define CONST_TGTT_TARGET_FRIEND_ONLY                            884
#define CONST_TGTT_REMOTE_TYPE_NA                                89
#define CONST_TGTT_REMOTE_TYPE_PROXIMITY                         90
#define CONST_TGTT_REMOTE_TYPE_TIME                              91
#define CONST_TGTT_REMOTE_TYPE_TRIGGER                           92
#define CONST_TGTT_REMOTE_TYPE_PROX_PROJ                         123
#define CONST_TGDT_None                                          112
#define CONST_TGDT_Physical                                      113
#define CONST_TGDT_Energy                                        116
#define CONST_TGDT_Thermal                                       115
#define CONST_TGDT_Bio                                           897
#define CONST_TGRF_RESTRICT_NONE                                 0
#define CONST_TGRF_RESTRICT_MELEE                                1
#define CONST_TGRF_RESTRICT_RANGED                               2
#define CONST_TGRF_RESTRICT_MOVEMENT                             4
#define CONST_TGRF_RESTRICT_SPECIALITY                           8
#define CONST_TGRF_RESTRICT_SENSOR                               16
#define CONST_TGRF_RESTRICT_SUIT                                 32
#define CONST_TGRF_RESTRICT_POWERPACK                            64
#define CONST_TGCT_CAMERA_NONE                                   0
#define CONST_TGCT_CAMERA_MELEE                                  1
#define CONST_TGCT_CAMERA_RANGED                                 2
#define CONST_TGCT_CAMERA_TEST                                   3
#define CONST_TGCT_CAMERA_DEATHZOOM                              4
#define CONST_TGCT_CAMERA_GRENADE                                5
#define CONST_TGCT_CAMERA_HACKING_ROBOT                          6
#define CONST_TGHT_NONE                                          0x00
#define CONST_TGHT_DEFAULT                                       0x01
#define CONST_TGHT_EXAGGERATED_POKE                              0x02
#define CONST_TGMAX_FIRE_MODE                                    6
#define CONST_TGEGT_EQUIP                                        261
#define CONST_TGEGT_BUILDUP                                      262
#define CONST_TGEGT_FIRE                                         263
#define CONST_TGEGT_HIT                                          264
#define CONST_TGEGT_COOLDOWN                                     265
#define CONST_TGEGT_AIM                                          266
#define CONST_TGEGT_HIT_IN_AIR                                   272
#define CONST_TGEGT_EQUIP_MODE                                   283
#define CONST_TGEGT_BLOCK                                        397
#define CONST_TGEGT_BLOCK_HIT                                    398
#define CONST_TGEGT_HIT_SITUATIONAL                              505
#define CONST_TGEGT_HIT_SITUATIONAL_IS_BLOCKED                   594
#define CONST_TGEGT_SUCCESSFUL_HIT                               759
#define CONST_TGEGT_REACTIVE_SKILL                               1104
#define CONST_TGEGT_HIT_THROUGH_BLOCK                            1294
#define CONST_TGHS_HIT_SITUATIONAL_CROUCH                        506
#define CONST_TGHS_HIT_SITUATIONAL_JUMP                          507
#define CONST_TGHS_HIT_SITUATIONAL_SPRINT                        508
#define CONST_TGHS_HIT_SITUATIONAL_BACKSTAB                      509
#define CONST_TGHS_HIT_SITUATIONAL_BLOCKBREAKER                  718
#define CONST_TGHS_HIT_SITUATIONAL_HEALTH_BELOW                  1270
#define CONST_TGHS_HIT_SITUATIONAL_HEALTH_ABOVE                  1271
#define CONST_TGDRCB_NONE                                        829
#define CONST_TGDRCB_SECOND_FIRE_MODE                            830
#define CONST_TGDRCB_AIM_MODE                                    833
#define CONST_TGDRCB_DETONATE                                    831
#define CONST_TGDRCB_CUSTOM                                      832
#define CONST_TGDRCB_SNIPER_ZOOM                                 887
#define CONST_TGDRCB_MELEE_BLOCK                                 894
#define CONST_TGDRCB_MELEE_BLOCKBREAK                            895
#define CONST_TGD_RIGHT_CLICK_FIRE_MODE                          1
#define CONST_TGD_MESH_TYPE_INHAND                               855
#define CONST_TGD_MESH_TYPE_ATTACHED                             856
#define CONST_TGD_MESH_TYPE_ALT_ATTACHED                         857
#define CONST_TGD_MESH_TYPE_LEFT_HAND                            1418
#define CONST_TGD_ANIMSET_DEST_DEVICE                            858
#define CONST_TGD_ANIMSET_DEST_PAWN                              859
#define CONST_TGD_ANIMSET_DEST_CHAR_SELECT                       1275
#define CONST_DEPLOYMODE_GROUND_DELTA_CHECK_DIST                 60.0f
#define CONST_DEPLOYMODE_MINIMUM_RADIUS_CHECK_DIST               30.0f
#define CONST_OFFHAND_EQUIP_COOLDOWN                             30.0f
#define CONST_REFIRE_SERVER_GRACE                                0.1f
#define CONST_COOLDOWN_SERVER_GRACE                              0.5f
#define CONST_TGDT_RANGED                                        388
#define CONST_TGDT_SPECIALTY                                     981
#define CONST_TGDT_MELEE                                         389
#define CONST_TGDT_OFF_HAND                                      390
#define CONST_TGDT_BASE_HUMAN_ATTRIB                             392
#define CONST_TGDT_PLAYER_SENSOR                                 393
#define CONST_TGDT_MORALE                                        476
#define CONST_TGDT_TRAVEL                                        806
#define CONST_NO_FIRE_SEQUENCE                                   255
#define CONST_TGT_MAX_TIMERS                                     32
#define CONST_TGATDT_ANIM_TREE_RANGE                             0.0
#define CONST_TGATDT_ANIM_TREE_MELEE                             1.0
#define CONST_TG_DEVICEFORM_RANGED                               1
#define CONST_TG_DEVICEFORM_MELEE                                2
#define CONST_TG_DEVICEFORM_DEPLOYABLE                           3
#define CONST_TG_DEVICEFORM_BASIC                                4
#define CONST_TG_DEVICEFORM_GRENADE                              5
#define CONST_TG_DEVICEFORM_MELEE_NEW                            6
#define CONST_TG_DEVICEFORM_MELEE_DUAL_WIELD                     7
#define CONST_TG_DEVICEFORM_SITUATIONAL_JUMP                     100
#define CONST_TG_DEVICEFORM_SITUATIONAL_SPRINT                   101
#define CONST_TG_DEVICEFORM_SITUATIONAL_CROUCH                   102
#define CONST_TG_DEVICEFORM_SITUATIONAL_SPRINT_CHARGE            103
#define CONST_TG_DEVICEFORM_SITUATIONAL_BLOCKBREAKER             104
#define CONST_TMS_FADEDAMAGE_TIMER                               1
#define CONST_IDLE_STATE_OFF                                     0
#define CONST_IDLE_STATE_TIMING                                  1
#define CONST_IDLE_STATE_ON                                      2
#define CONST_DEFAULT_FX_RADIUS                                  240.0f
#define CONST_MAX_DOOR_PARTS                                     3
#define CONST_TGCM_NA                                            119
#define CONST_TGCM_ADD                                           67
#define CONST_TGCM_SUBTRACT                                      70
#define CONST_TGCM_PERC_INCREASE                                 68
#define CONST_TGCM_PERC_DECREASE                                 69
#define CONST_TG_ROOT_GROUNDSPEED                                10000
#define CONST_TGEGT_NEWEST                                       156
#define CONST_TGEGT_STACKING                                     155
#define CONST_TGEGT_STRONGEST                                    157
#define CONST_TGEGT_REFRESH                                      836
#define CONST_TGEGT_OLDEST                                       874
#define CONST_TGEGC_LOCAL                                        302
#define CONST_TGEGC_POISON                                       303
#define CONST_TGEGC_SLOW                                         304
#define CONST_TGEGC_DISEASE                                      305
#define CONST_TGEGC_STUN                                         378
#define CONST_TGEGC_SLEEP                                        431
#define CONST_TGEGC_ABILITY                                      607
#define CONST_TGEGC_STEALTH                                      621
#define CONST_TGEGC_KNOCKBACK                                    875
#define CONST_TGEGC_EMP_STUN                                     653
#define CONST_TGEGC_IGNITE                                       719
#define CONST_TGEGC_EMP_SHORT_CIRCUIT                            768
#define CONST_TGEGC_GENERAL_DEBUFF                               769
#define CONST_TGEGC_PERSONAL_SHIELD                              770
#define CONST_TGEGC_PROXIMITY_SHIELD                             771
#define CONST_TGEGC_REGENERATION                                 772
#define CONST_TGEGC_STIM_BOOST                                   773
#define CONST_TGEGC_STIM_RESISTANCE                              774
#define CONST_TGEGC_GENERAL_BUFF                                 775
#define CONST_TGEGC_INVULNERABLE                                 862
#define CONST_TGEGC_POWER_POOL_DEBUFF                            879
#define CONST_TGEGC_REMOVE_EFFECT                                877
#define CONST_TGEGC_EMP_BURN                                     921
#define CONST_TGEGC_BUFF_DAMAGE_INTERNAL                         963
#define CONST_TGEGC_TEAM_STEALTH                                 1036
#define CONST_TGEGC_REST                                         1095
#define CONST_TGEGC_BLEED                                        1016
#define CONST_TIMER_INTERVAL                                     0
#define CONST_TIMER_LIFEDONE                                     1
#define CONST_DEFAULT_MAX_EFFECT_STACKS                          20
#define CONST_TGEA_MAX_EFFECTS                                   16
#define CONST_TGEA_MAX_EFFECTS_QUEUE                             32
#define CONST_TGEGS_EMPTY                                        0
#define CONST_TGEGS_ACTIVE_REP                                   1
#define CONST_TGEGS_ACTIVE                                       2
#define CONST_TGEGS_FLASH_REP                                    3
#define CONST_TGEGS_EMPTY_REP                                    4
#define CONST_REFRESH_NONE                                       0
#define CONST_REFRESH_REUSE                                      1
#define CONST_REFRESH_ADD                                        2
#define CONST_AIE_DAMAGE                                         0
#define CONST_AIE_HEALTH                                         1
#define CONST_CONTRIBUTION_BUFFER                                0.75f
#define CONST_CONTRIBUTION_BUFFEE                                0.25f
#define CONST_FEET_TO_UNREAL_UNITS                               16
#define CONST_MISSION_TIME_SETUP_SECS                            60.0
#define CONST_TERRITORY_TIME_SETUP_SECS                          120.0
#define CONST_PVE_TIME_SETUP_SECONDS                             15.0
#define CONST_DEFENSE_TIME_SETUP_SECONDS                         30.0
#define CONST_MIN_PVE_BOSS_TIME_REMAINING_SECONDS                240.0f
#define CONST_RAID_END_DELAY                                     60.0
#define CONST_PLAYER_END_GAME_DELAY                              10.0f
#define CONST_FINISH_END_MISSION_DELAY                           120.0
#define CONST_TG_DB_XP_SAVE_INTERVAL                             10
#define CONST_TG_DB_QUEST_UPDATE_INTERVAL                        10
#define CONST_TG_F2P_MAX_LEVEL                                   12
#define CONST_TG_F2P_MAX_PERSONAL_CREDITS                        100000
#define CONST_TG_TOKEN_WEEKLY_MAX                                100000
#define CONST_TG_TOKEN_ACCOUNT_MAX                               100000
#define CONST_TG_BOT_TYPE_DECOY                                  628
#define CONST_TG_BOT_TYPE_CREW                                   896
#define CONST_TG_CHARACTER_BUILDER_PACKAGE_NAME                  "characterbuilder_map"
#define CONST_TG_MAX_MAP_OBJECTIVES                              75
#define CONST_SEAL_PERCENT_TICKETS                               0.70
#define CONST_NUM_ASSIGNMENT_PENDING_SECS                        300
#define CONST_DAMAGE_SCALE                                       100
#define CONST_VOIP_SPEAKER_VOLUME_MODIFIER                       0.25
#define CONST_SAY_DISTANCE                                       800
#define CONST_TG_RELEASE_DIALOG_SHOW_DELAY                       0.1f
#define CONST_TG_PET_DEATH_CAMERA_LENGTH                         2
#define CONST_TG_JETTING_Z_THRUST                                100
#define CONST_CREW_BOT_DELAY                                     1.0f
#define CONST_TG_ROUND_END_SOUND_RES_ID                          3095
#define CONST_COMMAND_NONE                                       0
#define CONST_COMMAND_FOLLOW                                     1
#define CONST_COMMAND_GOTO                                       2
#define CONST_COMMAND_ATTACK                                     3
#define CONST_IM_LOCATION_CODE_EQUIPPED                          369
#define CONST_IM_LOCATION_CODE_ON_HAND                           370
#define CONST_IM_LOCATION_CODE_BANK                              371
#define CONST_IM_LOCATION_CODE_STRIKEFORCE                       1297
#define CONST_IM_LOCATION_CODE_AUCTION                           1079
#define CONST_IM_LOCATION_CODE_MAIL                              1080
#define CONST_IM_LOCATION_CODE_ELITE_ENTICEMENT                  1598
#define CONST_IM_LOCATION_CODE_BOOST_ENTICEMENT                  1599
#define CONST_IM_MAX_PROFILES                                    5
#define CONST_TGITC_DEVICE                                       217
#define CONST_TGITC_FLAIR                                        950
#define CONST_TGITC_DROPPED                                      724
#define CONST_TGITC_DYE                                          1020
#define CONST_TGITC_ENHANCEMENT                                  1106
#define CONST_TGITC_BLUEPRINT                                    686
#define CONST_TGITC_COMPONENT                                    1171
#define CONST_TGITC_HEX_ITEM                                     1298
#define CONST_TGITC_HEX_BOARD                                    1312
#define CONST_TGITC_REPAIR_KIT                                   1369
#define CONST_TGITC_LIMITED_EDITION                              1403
#define CONST_TGITC_MOD_KIT_DEVICE                               1434
#define CONST_TGITC_MOD_KIT_ARMOR                                1441
#define CONST_TGITC_CONSUMABLE                                   1412
#define CONST_TGITC_BOOST                                        1500
#define CONST_TGITC_VANITY_PET                                   1535
#define CONST_TGITC_JETPACK_TRAIL                                1612
#define CONST_TGITC_CONTAINER                                    1634
#define CONST_TGISC_FLAIR_HELMET                                 1006
#define CONST_TGISC_FLAIR_HELMET_FLAIR                           1007
#define CONST_TGISC_FLAIR_SUIT                                   1008
#define CONST_TGISC_HEX_ITEM_BOT                                 1300
#define CONST_TGISC_HEX_ITEM_DEPLOYABLE                          1301
#define CONST_TGISC_HEX_ITEM_DROPSHIP                            1302
#define CONST_TGISC_BLUEPRINT_FACTORY                            1319
#define CONST_TGISC_BLUEPRINT_VENDOR                             1344
#define CONST_TGISC_BLUEPRINT_UPGRADE                            1345
#define CONST_TGISC_BLUEPRINT_MOD                                1435
#define CONST_TGISC_COMPONENT_CONQUEST                           1347
#define CONST_TGISC_COMPONENT_MOD                                1348
#define CONST_TGISC_HEX_BOARD_FORGE                              1373
#define CONST_TGISC_HEX_BOARD_DEED                               1338
#define CONST_TGISC_HEX_BOARD_MISSILE                            1339
#define CONST_TGISC_ENHANCEMENT                                  1107
#define CONST_TGISC_ENHANCEMENT01                                1108
#define CONST_TGISC_ENHANCEMENT02                                1109
#define CONST_TGISC_ENHANCEMENT03                                1110
#define CONST_TGISC_ENHANCEMENT04                                1111
#define CONST_TGISC_ENHANCEMENT05                                1112
#define CONST_TGISC_ENHANCEMENT06                                1113
#define CONST_TGISC_ENHANCEMENT07                                1114
#define CONST_TGISC_ENHANCEMENT08                                1115
#define CONST_TGISC_ENHANCEMENT09                                1116
#define CONST_TGISC_ENHANCEMENT10                                1117
#define CONST_TGISC_ENHANCEMENT11                                1118
#define CONST_TGISC_ENHANCEMENT12                                1119
#define CONST_TGISC_ENHANCEMENT13                                1120
#define CONST_TGISC_ENHANCEMENT14                                1121
#define CONST_TGISC_ENHANCEMENT_TITLE                            1122
#define CONST_TG_ITEM_MIN_LEVEL_RARE                             20
#define CONST_TG_ITEM_MIN_LEVEL_EPIC                             30
#define CONST_PROP_CARGO_SPACE_AVAILABLE                         393
#define CONST_PROP_PLAYER_CAPACITY                               392
#define CONST_PROP_ITEM_SIZE                                     394
#define CONST_TG_NAV_ROUTE_INDICATOR_SPINUP_FX_ID                0
#define CONST_TG_NAV_ROUTE_INDICATOR_PATHING_FX_ID               1136
#define CONST_TG_NAV_ROUTE_INDICATOR_SPINDOWN_FX_ID              0
#define CONST_ITEM_QUALITY_EPIC                                  1162
#define CONST_ITEM_QUALITY_RARE                                  1163
#define CONST_ITEM_QUALITY_UNCOMMON                              1164
#define CONST_ITEM_QUALITY_COMMON                                1165
#define CONST_DETECTED_PLAYER_SFX_ID                             1163
#define CONST_TG_HEALTHBAR_WIDTH                                 100.0f
#define CONST_TG_HEALTHBAR_HEIGHT                                16.0f
#define CONST_TG_HEALTHFRAME_EDGE                                2.0f
#define CONST_TGFXP_SCALAR                                       299
#define CONST_TGFXP_VECTOR                                       300
#define CONST_TGFXP_COLOR                                        301
#define CONST_TGFXP_TEXTURE                                      307
#define CONST_TGFXT_NO_PRIORITY                                  0
#define CONST_TGFXT_PRIORITY_SHIELD                              625
#define CONST_TGFXT_PRIORITY_STEALTH                             626
#define CONST_TGFXT_PRIORITY_STEALTH_DETECTION                   627
#define CONST_TGFXT_PRIORITY_FLAME                               838
#define CONST_TGFXT_PRIORITY_SPAWN_SORTORDER                     15
#define CONST_TGFXMAT_GENERIC                                    615
#define CONST_TGFXMAT_HAIR                                       616
#define CONST_TGFXMAT_HEAD                                       617
#define CONST_TGFXMAT_BODY                                       618
#define CONST_TGFXMAT_HELMET                                     1010
#define CONST_TGFXMAT_BACKPACK                                   1011
#define CONST_TGFXMAT_INHAND                                     1192
#define CONST_UICLOCKMASK_ACTIVE_BIT                             0x1
#define CONST_UICLOCKMASK_ALARM_BIT                              0x2
#define CONST_UICLOCKMASK_COUNTDOWN_BIT                          0x4
#define CONST_UICLOCKMASK_SHOWBAR_BIT                            0x8
#define CONST_UICLOCKMASK_INCRPAD_SHIFT                          4
#define CONST_UITEXTMASK_ACTIVE_BIT                              0x1
#define CONST_UITEXTMASK_USEDURATION_BIT                         0x2
#define CONST_UITEXTMASK_WHICHBOX_BIT                            0x4
#define CONST_UITEXTMASK_ALLOWESC_BIT                            0x8
#define CONST_UITEXTMASK_INCRPAD_SHIFT                           4
#define CONST_PLAYER_NOT_TAGGED                                  -1
#define CONST_BLOCKER_FRIENDLY_TEAM_MIC                          2156
#define CONST_BLOCKER_ENEMY_TEAM_MIC                             2157
#define CONST_DEFAULT_BUFF_MODIFIER                              100
#define CONST_MESHASM_ID_PC_CHARBUILD_BALD                       403
#define CONST_MESHASM_ID_PC_MALE_CHARBUILD_DEFAULT_SUIT          1727
#define CONST_MESHASM_ID_PC_FEMALE_CHARBUILD_DEFAULT_SUIT        1037
#define CONST_MESHASM_ID_PC_MALE_MEDIC_DEFAULT_SUIT              1355
#define CONST_MESHASM_ID_PC_MALE_TORMENTOR_DEFAULT_SUIT          1725
#define CONST_MESHASM_ID_PC_MALE_ASSAULT_DEFAULT_SUIT            1354
#define CONST_MESHASM_ID_PC_MALE_TANK_DEFAULT_SUIT               1724
#define CONST_MESHASM_ID_PC_MALE_ROBOTICS_DEFAULT_SUIT           1357
#define CONST_MESHASM_ID_PC_MALE_ENGINEER_DEFAULT_SUIT           1726
#define CONST_MESHASM_ID_PC_MALE_INFILTRATOR_DEFAULT_SUIT        1356
#define CONST_MESHASM_ID_PC_MALE_RANGER_DEFAULT_SUIT             1727
#define CONST_MESHASM_ID_PC_FEMALE_MEDIC_DEFAULT_SUIT            1484
#define CONST_MESHASM_ID_PC_FEMALE_TORMENTOR_DEFAULT_SUIT        1729
#define CONST_MESHASM_ID_PC_FEMALE_ASSAULT_DEFAULT_SUIT          1485
#define CONST_MESHASM_ID_PC_FEMALE_TANK_DEFAULT_SUIT             1728
#define CONST_MESHASM_ID_PC_FEMALE_ROBOTICS_DEFAULT_SUIT         1482
#define CONST_MESHASM_ID_PC_FEMALE_ENGINEER_DEFAULT_SUIT         1731
#define CONST_MESHASM_ID_PC_FEMALE_INFILTRATOR_DEFAULT_SUIT      1483
#define CONST_MESHASM_ID_PC_FEMALE_RANGER_DEFAULT_SUIT           1730
#define CONST_MESHASM_ID_HAZMAT_MALE_ASSAULT                     2308
#define CONST_MESHASM_ID_HAZMAT_MALE_MEDIC                       2309
#define CONST_MESHASM_ID_HAZMAT_MALE_RECON                       2310
#define CONST_MESHASM_ID_HAZMAT_MALE_ROBOTICS                    2311
#define CONST_MESHASM_ID_HAZMAT_FEMALE_ASSAULT                   2312
#define CONST_MESHASM_ID_HAZMAT_FEMALE_MEDIC                     2314
#define CONST_MESHASM_ID_HAZMAT_FEMALE_RECON                     2315
#define CONST_MESHASM_ID_HAZMAT_FEMALE_ROBOTICS                  2316
#define CONST_TG_SKILL_GROUP_CRAFTING                            138
#define CONST_TG_MAX_CRAFTING_LEVEL                              300
#define CONST_TG_RAPPEL_ROPE_FX                                  1593
#define CONST_TG_DESTROYER_ES_BASIC_CANNONS                      2
#define CONST_TG_DESTROYER_ES_GRENADE_LAUNCH                     3
#define CONST_TG_DESTROYER_ES_SHIELD                             7
#define CONST_TG_DESTROYER_ES_BLAST_WAVE                         8
#define CONST_TG_BRAWLER_PHASE_CHARGE                            5
#define CONST_CTR_JET_EQUIP_INDEX                                3
#define CONST_CTR_INTERACTION_SCREEN_SFX_ID                      1236
#define CONST_CTR_MALE_BASE_ANIMSET_ID                           5447
#define CONST_CTR_FEMALE_BASE_ANIMSET_ID                         5442
#define CONST_TG_TUBES_MESH_ID                                   2180
#define CONST_HUNTER_CLASS_MITIGATION_BOOST                      0.7f
#define CONST_TG_HUNTER_PARENT_MESH_RECON                        1996
#define CONST_TG_HUNTER_PARENT_MESH_ASSAULT                      1997
#define CONST_TG_HUNTER_PARENT_MESH_ROBOTICS                     1998
#define CONST_TG_HUNTER_PARENT_MESH_MEDIC                        1999
#define CONST_TG_HUNTER_SOCKET_MESH_MEDIC                        2000
#define CONST_TG_HUNTER_AIMING_ANIMSET                           5230
#define CONST_SENSOR_BEAM_SFX_ID                                 1137
#define CONST_LIGHT_BEAM_MESH_ID                                 1924
#define CONST_LENS_FLARE_TEMPLATE_RES_ID                         4677
#define CONST_SCANNER_PHASE_TRANS_TIME_PATROL                    2.0f
#define CONST_SCANNER_PHASE_TRANS_TIME_SENSORSWEEP               3.f
#define CONST_SCANNER_PHASE_TRANS_TIME_POWERRECHARGE             2.0f
#define CONST_SCANNER_PHASE_TRANS_TIME_ALARM                     0.05f
#define CONST_PAWN_PHASE_CHARGE                                  2
#define CONST_TG_SIEGE_WEAPON_MIC_FRIENDLY                       5761
#define CONST_TG_SIEGE_WEAPON_MIC_ENEMY                          5763
#define CONST_SWITCHBLADE_VORTEX_SFX_ID                          1276
#define CONST_THINKTANK_SHIELD_SFX_ID                            1317
#define CONST_TG_PILOT_MESH_ID                                   2182
#define CONST_TEMP_VANITY_PET_MESH_ID                            0
#define CONST_TG_WARLORD_SWORD_MESH_ID                           2460
#define CONST_TG_WARLORD_GUN_MESH_ID                             2461
#define CONST_WIDOW_VORTEX_SFX_ID                                1432
#define CONST_TG_DYE_MYSELF                                      1
#define CONST_TG_DYE_FRIEND                                      2
#define CONST_TG_DYE_ENEMY                                       4
#define CONST_TG_MAX_BOT_CHECK_RANGE                             16000
#define CONST_TG_CLOSE_VISION_RANGE                              240
#define CONST_TG_CLOSE_HEARING_RANGE                             160
#define CONST_PROJECTILE_LINE_TRACE_DISTANCE                     32
#define CONST_TGPT_FLOAT                                         137
#define CONST_TGPT_INT                                           176
#define CONST_TGPT_COMBO                                         503
#define CONST_TGPID_PROJECTILE_SPEED                             46
#define CONST_TGPID_DAMAGE_RADIUS                                6
#define CONST_TGPID_REMOTE_ACTIVATION_TIME                       7
#define CONST_TGPID_PROXIMITY_DISTANCE                           8
#define CONST_TGPID_REMOTE_ACQUIRE_DISTANCE                      47
#define CONST_TGPID_CONE_ATTACK_ANGLE                            64
#define CONST_TGPID_EFFECTIVE_RADIUS                             343
#define CONST_TGPID_ACCURACY                                     10
#define CONST_TGPID_ACCURACY_CROUCH                              249
#define CONST_TGPID_ACCURACY_SPRINT                              246
#define CONST_TGPID_ACCURACY_WALK                                245
#define CONST_TGPID_ACCURACY_AIM_MODE_BONUS                      250
#define CONST_TGPID_ACCURACY_CORRECTION_RATE                     247
#define CONST_TGPID_ACCURACY_CORRECTION_RATE_CROUCH              248
#define CONST_TGPID_ACCURACY_LOSS_MAX                            253
#define CONST_TGPID_ACCURACY_LOSS_ON_JUMP                        251
#define CONST_TGPID_ACCURACY_LOSS_ON_SHOOT                       252
#define CONST_TGPID_SCOPE_POWER                                  259
#define CONST_TGPID_MAKEVISIBLE_FADE_RATE                        353
#define CONST_TGPID_GROUND_SPEED                                 49
#define CONST_TGPID_JUMPZ                                        50
#define CONST_TGPID_HEALTH                                       51
#define CONST_TGPID_HEALTH_MAX                                   304
#define CONST_TGPID_HEALTH_MAX_MODIFIER                          412
#define CONST_TGPID_HEALTH_MAX_TEMP                              306
#define CONST_TGPID_RANGE                                        5
#define CONST_TGPID_MIN_RANGE                                    48
#define CONST_TGPID_FLIGHT_ACCELERATION                          59
#define CONST_TGPID_KNOCKBACK                                    60
#define CONST_TGPID_KNOCKDOWN                                    164
#define CONST_TGPID_GRAVITYZ_MODIFIER                            136
#define CONST_TGPID_FALLING_DAMAGE_MODIFIER                      137
#define CONST_TGPID_PUSHBACK                                     295
#define CONST_TGPID_DISARM_IN_HAND                               303
#define CONST_TGPID_LOCK_YAW_ROTATION                            323
#define CONST_TGPID_THREAT                                       420
#define CONST_TGPID_THREAT_MODIFIER                              421
#define CONST_TGPID_CAMERA_SHAKE                                 69
#define CONST_TGPID_AIR_SPEED                                    70
#define CONST_TGPID_ATTACK_RATE                                  84
#define CONST_TGPID_INTERRUPT_CHANCE                             96
#define CONST_TGPID_DEVICE_MODE_EQUIP_TIME                       146
#define CONST_TGPID_DEVICE_MODE_BUILDUP_TIME                     2
#define CONST_TGPID_DEVICE_MODE_FIRE_TIME                        53
#define CONST_TGPID_DEVICE_MODE_COOLDOWN_TIME                    4
#define CONST_TGPID_DEVICE_MODE_TIME_TO_HOLD_BLOCK               258
#define CONST_TGPID_DEVICE_SHOTS_PER_FIRE                        287
#define CONST_TGPID_TIME_TO_DEPLOY_SECS                          279
#define CONST_TGPID_MAX_CONTROL_RANGE                            283
#define CONST_TGPID_HIT_TIME                                     310
#define CONST_TGPID_FULL_BODY_ANIM_TIME                          419
#define CONST_TGPID_REPAIR                                       260
#define CONST_TGPID_MAP_PLAYER_KILL_VALUE                        95
#define CONST_TGPID_TUTORIAL_MAP                                 368
#define CONST_TGPID_CAPTURE_TIME                                 87
#define CONST_TGPID_HOLD_TIME                                    88
#define CONST_TGPID_TICK_TIME                                    89
#define CONST_TGPID_CAPTURE_SCORE                                97
#define CONST_TGPID_TICK_SCORE                                   98
#define CONST_TGPID_TICKET_TICK_DELAY                            411
#define CONST_TGPID_MIND_CONTROLLED                              100
#define CONST_TGPID_STUN                                         166
#define CONST_TGPID_SLEEP                                        167
#define CONST_TGPID_DAZED                                        187
#define CONST_TGPID_REVIVE                                       115
#define CONST_TGPID_NUM_RESPAWNS                                 387
#define CONST_TGPID_PLAYER_RELEASE                               116
#define CONST_TGPID_PLAYER_HEALTH_AUTO_RELEASE                   117
#define CONST_TGPID_PLAYER_HEALTH_MAN_RELEASE                    118
#define CONST_TGPID_PLAYER_RELEASE_LENGTH                        119
#define CONST_TGPID_PLAYER_RELEASE_LENGTH_ATTACKERS              313
#define CONST_TGPID_PLAYER_RELEASE_LENGTH_DEFENDERS              314
#define CONST_TGPID_MISSION_TIME_SECS                            299
#define CONST_TGPID_QUIET_END_MISSION                            342
#define CONST_TGPID_ROUND_TIME                                   416
#define CONST_TGPID_GAME_SPEED_MODIFIER                          122
#define CONST_TGPID_STEALTH_TRANSTIME_MODIFIER                   124
#define CONST_TGPID_STEALTH_DISABLED                             141
#define CONST_TGPID_STEALTH_TYPE_CODE                            341
#define CONST_TGPID_REMOVE_EFFECT                                140
#define CONST_TGPID_PLAYER_CHARGE                                138
#define CONST_TGPID_PLAYER_CHARGE_SPEED                          139
#define CONST_TGPID_SWEEP_TYPE                                   142
#define CONST_TGPID_SWEEP_DIRECTION                              143
#define CONST_TGPID_SWEEP_RATE                                   144
#define CONST_TGPID_SWEEP_RANGE                                  145
#define CONST_TGPID_PERSIST_TIME                                 150
#define CONST_TGPID_PERSIST_PULSE                                151
#define CONST_TGPID_CHARACTER_VISION_RANGE                       152
#define CONST_TGPID_DEVICE_EFFECTIVE_RANGE                       153
#define CONST_TGPID_MAX_DEPLOYABLES_OUT                          154
#define CONST_TGPID_TAG_ENEMY                                    161
#define CONST_TGPID_BUILDUP_CHARGE_TIME                          162
#define CONST_TGPID_WEIGHT_BONUS                                 186
#define CONST_TGPID_DEPLOYABLE_ARTILLERY_RADIUS                  397
#define CONST_INDEX_DISPLAY_TARGET_MINIMAP                       0
#define CONST_INDEX_DISPLAY_TARGET_INGAME                        1
#define CONST_INDEX_DISPLAY_TARGET_BRACKET                       2
#define CONST_INDEX_DISPLAY_TARGET_DISTANCE                      3
#define CONST_INDEX_DISPLAY_TARGET_TAGGED                        4
#define CONST_INDEX_DISPLAY_SEND_AUDIO_WARNING                   5
#define CONST_INDEX_DISPLAY_TARGET_LOW_HEALTH                    6
#define CONST_INDEX_SEE_NON_MOVING_ENEMY                         0
#define CONST_INDEX_SEE_WALKING_ENEMY                            1
#define CONST_INDEX_SEE_MAKING_NOISE_ENEMY                       2
#define CONST_INDEX_SEE_FLYING_ENEMY                             3
#define CONST_INDEX_SEE_STEALTHED_ENEMY                          4
#define CONST_INDEX_SEE_DEPLOYABLES                              5
#define CONST_INDEX_SEE_BEACONS                                  6
#define CONST_INDEX_SEE_BOTS_ONLY                                7
#define CONST_TGPID_SCANNER_FOV                                  90
#define CONST_TGPID_SCANNER_RANGE                                13
#define CONST_TGPID_SCANNER_EFFECT_ON                            123
#define CONST_TGPID_SCANNER_VIS_CONFIG                           221
#define CONST_TGPID_SCANNER_REQUIRE_LOS                          223
#define CONST_TGPID_PROTECTION_DISEASE                           160
#define CONST_TGPID_PROTECTION_ENERGY                            157
#define CONST_TGPID_PROTECTION_PHYSICAL                          155
#define CONST_TGPID_PROTECTION_POISON                            159
#define CONST_TGPID_PROTECTION_SLOW                              158
#define CONST_TGPID_PROTECTION_THERMAL                           156
#define CONST_TGPID_PROTECTION_STUN                              163
#define CONST_TGPID_PROTECTION_SLEEP                             168
#define CONST_TGPID_PROTECTION_MELEE                             217
#define CONST_TGPID_PROTECTION_RANGED                            218
#define CONST_TGPID_PROTECTION_AOE                               219
#define CONST_TGPID_EVADE_ALL                                    216
#define CONST_TGPID_PROTECTION_KNOCKBACK                         233
#define CONST_TGPID_PROTECTION_EMP_STUN                          235
#define CONST_TGPID_PROTECTION_IGNITE                            266
#define CONST_TGPID_PROTECTION_BIO                               324
#define CONST_TGPID_PROTECTION_EMP_BURN                          328
#define CONST_TGPID_PROTECTION_BLEED                             371
#define CONST_TGPID_POWERPOOL                                    243
#define CONST_TGPID_POWERPOOL_RECHARGE_RATE                      244
#define CONST_TGPID_POWERPOOL_COST                               242
#define CONST_TGPID_POWERPOOL_MIN_COST                           285
#define CONST_TGPID_POWERPOOL_MAX                                255
#define CONST_TGPID_POWERPOOL_COST_BLOCK                         322
#define CONST_TGPID_ABILITY_CHARGE                               262
#define CONST_TGPID_ABILITY_CHARGE_BONUS_COST                    263
#define CONST_TGPID_ABILITY_CHARGE_MAX                           264
#define CONST_TGPID_ABILITY_CHARGE_RECHARGE_RATE                 265
#define CONST_TGPID_ALLOW_PET_DOMINATION                         236
#define CONST_TGPID_HEALING_MODIFIER                             330
#define CONST_TGPID_GROUNDSPEED_MODIFIER                         66
#define CONST_TGPID_ACCURACY_MODIFIER                            113
#define CONST_TGPID_RANGE_MODIFIER                               114
#define CONST_TGPID_EFFECTIVE_RANGE_MODIFIER                     207
#define CONST_TGPID_TARGET_AUTOLOCK                              200
#define CONST_TGPID_INSTANT_POWER                                201
#define CONST_TGPID_RECHARGE_TIME_MODIFIER                       203
#define CONST_TGPID_EFFECT_LIFETIME_MODIFIER                     208
#define CONST_TGPID_EFFECT_POTENCY_MODIFIER                      376
#define CONST_TGPID_EFFECT_SHIELD_MODIFIER                       386
#define CONST_TGPID_REMOVE_MEZ                                   209
#define CONST_TGPID_EFFECT_HEAL_MODIFIER_SELF                    210
#define CONST_TGPID_EFFECT_REPAIR_MODIFIER_SELF                  261
#define CONST_TGPID_MISSING_HEALTH                               211
#define CONST_TGPID_MELEE_ATTACKRATING_MODIFIER                  213
#define CONST_TGPID_RANGED_ATTACKRATING_MODIFIER                 215
#define CONST_TGPID_CROUCH_STEALTH_DISTANCE                      220
#define CONST_TGPID_SILENT_MOVEMENT                              224
#define CONST_TGPID_XDEPLOY_ABILITY                              225
#define CONST_TGPID_MELEE_ATTACKRATE_MODIFIER                    231
#define CONST_TGPID_RANGED_ATTACKRATE_MODIFIER                   232
#define CONST_TGPID_RESIST_TAGGING                               254
#define CONST_TGPID_ACCURACY_CORR_RATE_MODIFIER                  256
#define CONST_TGPID_CRITICAL_HIT_MODIFIER                        280
#define CONST_TGPID_MAX_CONTROL_RANGE_MODIFIER                   284
#define CONST_TGPID_ARCING_JUMPS                                 309
#define CONST_TGPID_CONTAGIOUS_RADIUS                            312
#define CONST_TGPID_EFFECT_DAMAGE_TAKEN_MODIFIER                 316
#define CONST_TGPID_DAMAGE_REFLECT                               335
#define CONST_TGPID_REMOTE_TIME_MODIFIER                         349
#define CONST_TGPID_PET_DAMAGE_MODIFIER                          350
#define CONST_TGPID_AOE_RADIUS_MODIFIER                          352
#define CONST_TGPID_PET_LIFESPAN_MODIFIER                        355
#define CONST_TGPID_PET_LIFESPAN                                 354
#define CONST_TGPID_PROJECTILE_SPEED_MODIFIER                    356
#define CONST_TGPID_MORALE_POINTS_MODIFIER                       357
#define CONST_TGPID_BUFF_DEPLOY_RATE_MODIFIER                    360
#define CONST_TGPID_PET_MAX_HEALTH_MODIFIER                      366
#define CONST_TGPID_HEALTH_MAX_DEPLOYABLES                       339
#define CONST_TGPID_EFFICIENCY_MODIFIER                          385
#define CONST_TGPID_EFFICIENCY_HEALTH_MODIFIER                   390
#define CONST_TGPID_ALLOW_MULTIPLE_TARGETS                       415
#define CONST_TGPID_PET_RANGE_MODIFIER                           381
#define CONST_TGPID_PET_DAMAGE_RADIUS_MODIFIER                   382
#define CONST_TGPID_PET_ACCURACY_MODIFIER                        383
#define CONST_TGPID_PET_RECHARGE_RATE_MODIFIER                   384
#define CONST_TGPID_DAMAGE_MODIFIER                              65
#define CONST_TGPID_MELEE_DAMAGE_MODIFIER                        212
#define CONST_TGPID_RANGED_DAMAGE_MODIFIER                       214
#define CONST_TGPID_AOE_DAMAGE_MODIFIER                          321
#define CONST_TGPID_SITUATIONAL_DAMAGE_MODIFIER                  370
#define CONST_TGPID_BIOLOGICAL_DAMAGE_MODIFIER                   389
#define CONST_TGPID_MECHANICAL_DAMAGE_MODIFIER                   388
#define CONST_TGPID_BUFF_DAMAGE_MODIFIER                         361
#define CONST_TGPID_BUFF_DAMAGE_AOE_MODIFIER                     362
#define CONST_TGPID_BUFF_DAMAGE_MELEE_MODIFIER                   363
#define CONST_TGPID_BUFF_DAMAGE_RANGED_MODIFIER                  364
#define CONST_TGPID_BUFF_DAMAGE_SITUATIONAL_MODIFIER             369
#define CONST_TGPID_AUTO_SPAWN                                   170
#define CONST_TGPID_RESPAWN                                      171
#define CONST_TGPID_BOT_COUNT                                    172
#define CONST_TGPID_RESPAWN_DELAY                                173
#define CONST_TGPID_SPAWN_DELAY                                  174
#define CONST_TGPID_TEAM_NUMBER                                  175
#define CONST_TGPID_TASK_FORCE_NUMBER                            176
#define CONST_TGPID_COALITION_NUMBER                             177
#define CONST_TGPID_SELECTION_METHOD                             178
#define CONST_TGPID_BOT_SELECTION_LIST                           179
#define CONST_TGPID_PLACEMENT_METHOD                             180
#define CONST_TGPID_PATROL_LOOP                                  181
#define CONST_TGPID_GLOBAL_ALARM_NUMBER                          182
#define CONST_TGPID_SPAWN_LOCATION_LIST                          183
#define CONST_TGPID_PATROL_LOCATION_LIST                         184
#define CONST_TGPID_DEPLOYABLE_SELECTION_LIST                    185
#define CONST_TGPID_DESTRUCTIBLE_SELECTION_LIST                  188
#define CONST_TGPID_INSTANCE_SELECTION_LIST                      229
#define CONST_TGPID_DEVICE_SELECTION_LIST                        282
#define CONST_TGPID_NAME_SELECTION_LIST                          292
#define CONST_TGPID_BULK_SPAWN                                   230
#define CONST_TGPID_LOOT_TABLE_ID                                332
#define CONST_TGPID_DEFENDER_HENCHEMEN_SEL_LIST                  333
#define CONST_TGPID_ATTACKER_HENCHEMEN_SEL_LIST                  334
#define CONST_TGPID_SPAWN_TABLE_ID                               340
#define CONST_TGPID_START_RATING                                 189
#define CONST_TGPID_CURRENT_RATING                               190
#define CONST_TGPID_RESET_RATING                                 191
#define CONST_TGPID_DECREASE_RATE                                192
#define CONST_TGPID_RETURN_MAP_TYPE                              325
#define CONST_TGPID_RETURN_MAP_GAME_ID                           424
#define CONST_TGPID_DISABLED                                     345
#define CONST_TGPID_MAP_ID                                       193
#define CONST_TGPID_GROUP_NUMBER                                 194
#define CONST_TGPID_PRELOAD                                      195
#define CONST_TGPID_SET_TASK_FORCE                               196
#define CONST_TGPID_BALANCE_TASK_FORCE                           197
#define CONST_TGPID_IGNORE_NON_MEMBERS                           198
#define CONST_TGPID_USE_PLAYER_START                             199
#define CONST_TGPID_REQUEST_MISSION                              329
#define CONST_TGPID_PET_DEPLOY_TIME_MODIFIER                     391
#define CONST_TGPID_DEPLOY_RATE_MODIFIER                         278
#define CONST_TGPID_TRAINING_DEVICE_LIST                         281
#define CONST_TGPID_SUPER_JUMP                                   286
#define CONST_TGPID_TIME_TO_CAPTURE                              288
#define CONST_TGPID_CAPTURE_ONLY_ONCE                            289
#define CONST_TGPID_ALLOW_AIBOT_INTERACTION                      290
#define CONST_TGPID_ALLOW_PLAYERBOT_INTERACTION                  291
#define CONST_TGPID_TIME_TO_HOLD                                 294
#define CONST_TGPID_DEFENDER_RECAP_RATE                          296
#define CONST_TGPID_CAPTURE_ACCEL_RATE                           297
#define CONST_TGPID_CAPTURE_ACCEL_RATE_CAP                       298
#define CONST_TGPID_OBJECTIVE_BOT_ID                             301
#define CONST_TGPID_CAPTURE_TIME_EXTENTION                       300
#define CONST_TGPID_OVERTIME_RATE_MODIFIER                       317
#define CONST_TGPID_END_OT_ON_DEFENDER_PROGRESS                  320
#define CONST_TGPID_POINTS_PER_SECOND                            326
#define CONST_TGPID_POINTS_TO_WIN                                327
#define CONST_TGPID_OBJECTIVE_UNLOCK_DELAY                       331
#define CONST_TGPID_BLOCK_FRIENDLY_FIRE                          302
#define CONST_TGPID_TAUNT                                        305
#define CONST_TGPID_FORCE_RESET_TASKFORCE                        308
#define CONST_TGPID_REQUIRED_POINTS_TO_FIRE                      318
#define CONST_TGPID_BOOST_CHARGE_RATE                            337
#define CONST_TGPID_ROOT                                         338
#define CONST_TGPID_CAPTURE_TIME_RESET                           358
#define CONST_TGPID_PRIORITY                                     346
#define CONST_TGPID_OBJECTIVE_ID                                 347
#define CONST_TGPID_MIN_AGENTS                                   401
#define CONST_TGPID_POINTS                                       398
#define CONST_TGPID_CREDITS                                      399
#define CONST_TGPID_REWARD_XP                                    400
#define CONST_TGPID_OBJECTIVE_COOLDOWN_SECONDS                   409
#define CONST_TGPID_MINIMUM_LEVEL                                410
#define CONST_TGPID_MINI_MAP_MIN_X                               402
#define CONST_TGPID_MINI_MAP_MIN_Y                               403
#define CONST_TGPID_MINI_MAP_MAX_X                               404
#define CONST_TGPID_MINI_MAP_MAX_Y                               405
#define CONST_TGPID_MINI_MAP_TEXTURE_ID                          406
#define CONST_TGPID_MINI_MAP_TEXTURE_UL                          407
#define CONST_TGPID_MINI_MAP_TEXTURE_VL                          408
#define CONST_TGPID_NEXT_MAP_GAME                                344
#define CONST_TGPID_ROUTE_NUMBER                                 348
#define CONST_TGPID_TELEPORT_BOTS                                359
#define CONST_TGPID_PAUSE_ON_CAPTURE                             365
#define CONST_TGPID_SPAWN_ORDER                                  367
#define CONST_TGPID_PVE_NORMAL_FLAG                              377
#define CONST_TGPID_PVE_EXPERT_FLAG                              378
#define CONST_TGPID_PVE_HEROIC_FLAG                              379
#define CONST_TGPID_PVE_EXTREME_FLAG                             380
#define CONST_TGPID_FRICTION_MULTIPLIER                          395
#define CONST_TGPID_XP_MODIFIER                                  417
#define CONST_TGPID_TOKEN_MODIFIER                               418
#define CONST_TGPID_CREDIT_MODIFIER                              422
#define CONST_TGPID_LOOT_MODIFIER                                423
#define CONST_TGPID_QUESTREWARD_ELITE_XP_MODIFIER                425
#define CONST_TGPID_QUESTREWARD_ELITE_CREDIT_MODIFIER            426
#define CONST_TGPID_QUESTREWARD_ELITE_TOKENS_MODIFIER            427
#define CONST_TGPID_QUESTREWARD_BOOST_XP_MODIFIER                428
#define CONST_TGPID_QUESTREWARD_BOOST_CREDIT_MODIFIER            429
#define CONST_TGPID_QUESTREWARD_BOOST_TOKEN_MODIFIER             430
#define CONST_TGPID_QUESTREWARD_BOOST_LOOT_MODIFIER              431
#define CONST_NUM_TICKET_COALITIONS                              3
#define CONST_TG_EQUIP_POINT_EQP_MAX                             25
#define CONST_MAX_STATS_DEVICES                                  9
#define CONST_NUM_SCORE_TYPES                                    11
#define CONST_TG_MAX_PREMADE_DEPLOYS                             20
#define CONST_TG_MAX_PRIMARY_OBJECTIVES                          5
#define CONST_TG_MAX_TASK_TEAM_NUMBER                            10
#define CONST_EMITTER_ACTIVATION_MASK_NONE                       0
#define CONST_EMITTER_ACTIVATION_MASK_FRIENDLY                   1
#define CONST_EMITTER_ACTIVATION_MASK_HOSTILE                    2
#define CONST_EMITTER_ACTIVATION_MASK_CONTESTED                  4
#define CONST_FX_SCALE_BY_DAMAGE                                 745
#define CONST_FX_SCALE_BY_RADIUS                                 746
#define CONST_FX_SCALE_BY_RADIUS_SQUARED                         1023
#define CONST_INVALID_LIGHT_SCORE                                2
#define CONST_INVALID_LIGHTARRAY_INDEX                           -1
#define CONST_TGFXLIGHT_MAX_SETTINGS_VALUE                       5
#define CONST_TG_PLAYER_TASK_FORCE_COUNT                         2
#define CONST_TG_MAX_SCROLLLIST_ENTRIES                          100
#define CONST_TG_MAX_CHATSCROLLLIST_ENTRIES                      100
#define CONST_INVALIDFIELD                                       -1
#define CONST_MIN_ZOOM                                           14.0f
#define CONST_MAX_ZOOM                                           40.0f
#define CONST_MAX_HEXMAP_PAN_DELTA                               50
#define CONST_MAX_HEXMAP_ZOOM_DELTA                              4
#define CONST_MAX_RAID_HEXES                                     61
#define CONST_MAX_TEAMS                                          6
#define CONST_HEX_DEFENSE_BUILDING_ID_N                          2
#define CONST_HEX_DEFENSE_BUILDING_ID_NW                         12
#define CONST_HEX_DEFENSE_BUILDING_ID_NE                         6
#define CONST_HEX_DEFENSE_BUILDING_ID_S                          9
#define CONST_HEX_DEFENSE_BUILDING_ID_SW                         10
#define CONST_HEX_DEFENSE_BUILDING_ID_SE                         8
#define CONST_ICON_SIZE                                          64
#define CONST_MAP_OBJECTIVE_OFFSET                               0
#define CONST_MAP_OBJECTIVE_SIZE_LARGE                           76.0
#define CONST_MAP_OBJECTIVE_SIZE_MEDIUM                          64.0
#define CONST_MAP_OBJECTIVE_SIZE_SMALL                           48.0
#define CONST_MAP_LOCAL_PLAYER_SIZE                              36.0
#define CONST_MAP_PLAYER_SIZE                                    24.0
#define CONST_MAP_ICONS                                          15
#define CONST_MAP_OBJECTIVE_TYPE_START                           1385
#define CONST_MAP_OBJECTIVE_TYPE_DEFEND                          1387
#define CONST_NO_MSGID                                           -1

/*
# ========================================================================================= #
# Enums
# ========================================================================================= #
*/

// Enum TgGame.TgActionPoint.eActionPointType
/*enum eActionPointType
{
	ACTION_NONE                                        = 0,
	ACTION_RELAX_OPEN                                  = 1,
	ACTION_MINE_DEFAULT                                = 2,
	ACTION_RELAX_WALL                                  = 3,
	ACTION_CONSOLE_STANDARD                            = 4,
	ACTION_CONSOLE_LAB_DEFAULT                         = 5,
	ACTION_GUARD_WATCH_NORMAL                          = 6,
	ACTION_GUARD_WATCH_ELEVATED                        = 7,
	ACTION_FACTORY_LINE_DEFAULT                        = 8,
	ACTION_SNIPE                                       = 9,
	ACTION_PLACE_TURRET                                = 10,
	ACTION_PLACE_SHIELD                                = 11,
	ACTION_PLACE_CRATE                                 = 12,
	ACTION_PLACE_MINE                                  = 13,
	ACTION_PLACE_SENSOR                                = 14,
	ACTION_MAX                                         = 15
};*/

// Enum TgGame.TgObject.TG_Coalition
/*enum TG_Coalition
{
	Coalition_None                                     = 0,
	Coalition_A                                        = 1,
	Coalition_B                                        = 2,
	Coalition_MAX                                      = 3
};*/

// Enum TgGame.TgActorFactory.eSelectionMethod
/*enum eSelectionMethod
{
	SM_RANDOM                                          = 0,
	SM_SEQUENTIAL                                      = 1,
	SM_MAX                                             = 2
};*/

// Enum TgGame.TgPawn.TG_EQUIP_POINT
/*enum TG_EQUIP_POINT
{
	EQP_NONE                                           = 0,
	EQP_GENERIC                                        = 1,
	EQP_GENERIC01                                      = 2,
	EQP_GENERIC02                                      = 3,
	EQP_GENERIC03                                      = 4,
	EQP_GENERIC04                                      = 5,
	EQP_GENERIC05                                      = 6,
	EQP_GENERIC06                                      = 7,
	EQP_GENERIC07                                      = 8,
	EQP_GENERIC08                                      = 9,
	EQP_GENERIC09                                      = 10,
	EQP_GENERIC10                                      = 11,
	EQP_GENERIC11                                      = 12,
	EQP_GENERIC12                                      = 13,
	EQP_GENERIC13                                      = 14,
	EQP_GENERIC14                                      = 15,
	EQP_GENERIC15                                      = 16,
	EQP_GENERIC16                                      = 17,
	EQP_GENERIC17                                      = 18,
	EQP_GENERIC18                                      = 19,
	EQP_GENERIC19                                      = 20,
	EQP_GENERIC20                                      = 21,
	EQP_GENERIC21                                      = 22,
	EQP_GENERIC22                                      = 23,
	EQP_GENERIC23                                      = 24,
	EQP_MAX                                            = 25
};*/

// Enum TgGame.TgObject.GAME_WIN_STATE
/*enum GAME_WIN_STATE
{
	GWS_NONE                                           = 0,
	GWS_DEFENDER_WON                                   = 1,
	GWS_ATTACKER_WON                                   = 2,
	GWS_TIE                                            = 3,
	GWS_MAX                                            = 4
};*/

// Enum TgGame.TgObject.GAME_TYPE
/*enum GAME_TYPE
{
	GT_UNSET                                           = 0,
	GT_CITY                                            = 1,
	GT_CAPTURE                                         = 2,
	GT_ESCORT                                          = 3,
	GT_TICKET                                          = 4,
	GT_POINTROTATION                                   = 5,
	GT_CTF                                             = 6,
	GT_ARENA                                           = 7,
	GT_CONTROL                                         = 8,
	GT_OPENPVE                                         = 9,
	GT_OPENPVP                                         = 10,
	GT_DEFENSE                                         = 11,
	GT_MAX                                             = 12
};*/

// Enum TgGame.TgObject.TG_HIDEABLE_HUD_ELEMENT
/*enum TG_HIDEABLE_HUD_ELEMENT
{
	DeviceBar                                          = 0,
	BuffBar                                            = 1,
	ChatBox                                            = 2,
	AlertBox                                           = 3,
	MiniMap                                            = 4,
	MissionInfo                                        = 5,
	PlayerInfo                                         = 6,
	TeamInfo                                           = 7,
	Reticle                                            = 8,
	OmegaAlert                                         = 9,
	AgentInfo                                          = 10,
	QuestTracking                                      = 11,
	AllElements                                        = 12,
	TG_HIDEABLE_HUD_ELEMENT_MAX                        = 13
};*/

// Enum TgGame.TgObject.DAMAGE_INFO_TYPE
/*enum DAMAGE_INFO_TYPE
{
	DIT_Damage                                         = 0,
	DIT_Status                                         = 1,
	DIT_Healing                                        = 2,
	DIT_Objective                                      = 3,
	DIT_Experience                                     = 4,
	DIT_MAX                                            = 5
};*/

// Enum TgGame.TgObject.EHeadMorphPoses
/*enum EHeadMorphPoses
{
	HMP_None                                           = 0,
	HMP_BaseHeads                                      = 1,
	HMP_FaceSkinnyFat                                  = 2,
	HMP_BrowUpDown                                     = 3,
	HMP_BrowCornerUpDown                               = 4,
	HMP_BrowInOut                                      = 5,
	HMP_BrowStyle                                      = 6,
	HMP_EyeCornerUpDown                                = 7,
	HMP_EyesWideNarrow                                 = 8,
	HMP_EyeStyle                                       = 9,
	HMP_EyeColor                                       = 10,
	HMP_ChinInOut                                      = 11,
	HMP_ChinUpDown                                     = 12,
	HMP_ChinWideNarrow                                 = 13,
	HMP_CheekBoneUpDown                                = 14,
	HMP_CheekBoneInOut                                 = 15,
	HMP_CheekInOut                                     = 16,
	HMP_JawBoneInOut                                   = 17,
	HMP_JawBoneUpDown                                  = 18,
	HMP_JawRound                                       = 19,
	HMP_MouthSmallLarge                                = 20,
	HMP_MouthUpDown                                    = 21,
	HMP_LowerLipThinThick                              = 22,
	HMP_LipsForward                                    = 23,
	HMP_LowerLipInOut                                  = 24,
	HMP_MouthStyle                                     = 25,
	HMP_NoseInOut                                      = 26,
	HMP_NoseNarrowWide                                 = 27,
	HMP_NoseBridgeArcInOut                             = 28,
	HMP_NoseTipUpDown                                  = 29,
	HMP_NoseTipSmallLarge                              = 30,
	HMP_NostrilUpDown                                  = 31,
	HMP_NostrilSmallLarge                              = 32,
	HMP_NoseBoneBackForward                            = 33,
	HMP_NoseUnderIn                                    = 34,
	HMP_EarStyle                                       = 35,
	HMP_EarsInOut                                      = 36,
	HMP_EarsSmallLarge                                 = 37,
	HMP_EarlobeSmallLarge                              = 38,
	HMP_NoseUpDown                                     = 39,
	HMP_CheekBoneForwardBack                           = 40,
	HMP_EyesTranslateInOut                             = 41,
	HMP_EyesTranslateDownUp                            = 42,
	HMP_EyesTranslateForwardBack                       = 43,
	HMP_JawForwardBack                                 = 44,
	HMP_FacialHair                                     = 45,
	HMP_FaceSmallLarge                                 = 46,
	HMP_FaceInOut                                      = 47,
	HMP_UpperHeadScale                                 = 48,
	HMP_LowerHeadScale                                 = 49,
	HMP_EyesSmallLarge                                 = 50,
	HMP_BrowTexture                                    = 51,
	HMP_SkinColor                                      = 52,
	HMP_Wrinkle                                        = 53,
	HMP_MidBrowPinchInOut                              = 54,
	HMP_BrowSidesScale                                 = 55,
	HMP_MoutBallScaleUpDown                            = 56,
	HMP_UpperLipThinThick                              = 57,
	HMP_ChinSmallLarge                                 = 58,
	HMP_UpperEyelidThinThick                           = 59,
	HMP_HairColor                                      = 60,
	HMP_CheekColor                                     = 61,
	HMP_LipColor                                       = 62,
	HMP_EyeShadow                                      = 63,
	HMP_HairAccessoryColor                             = 64,
	HMP_Hair                                           = 65,
	HMP_SkinTone                                       = 66,
	HMP_SkinComplexionHead                             = 67,
	HMP_SkinComplexionEyes                             = 68,
	HMP_SkinComplexionCheeks                           = 69,
	HMP_EyeShadowIntensity                             = 70,
	HMP_LipColorIntensity                              = 71,
	HMP_CheekColorIntensity                            = 72,
	HMP_SecondaryHairColor                             = 73,
	HMP_FacePaintPattern                               = 74,
	HMP_FacePaintPrimaryColor                          = 75,
	HMP_FacePaintSecondaryColor                        = 76,
	HMP_FacePaintTertiaryColor                         = 77,
	HMP_FacePaintPrimaryIntensity                      = 78,
	HMP_FacePaintSecondaryIntensity                    = 79,
	HMP_FacePaintTertiaryIntensity                     = 80,
	HMP_MAX                                            = 81
};*/

// Enum TgGame.TgObject.EHeadMorphGroups
/*enum EHeadMorphGroups
{
	HMG_None                                           = 0,
	HMG_BaseHead                                       = 1,
	HMG_General                                        = 2,
	HMG_Hair                                           = 3,
	HMG_Eyes                                           = 4,
	HMG_Mouth                                          = 5,
	HMG_Nose                                           = 6,
	HMG_Ears                                           = 7,
	HMG_Colors                                         = 8,
	HMG_HairColors                                     = 9,
	HMG_MAX                                            = 10
};*/

// Enum TgGame.TgObject.EDyeSlots
/*enum EDyeSlots
{
	DYE_Primary                                        = 0,
	DYE_Secondary                                      = 1,
	DYE_Emissive                                       = 2,
	DYE_WeaponColor                                    = 3,
	DYE_WeaponEmissive                                 = 4,
	DYE_MAX                                            = 5
};*/

// Enum TgGame.TgPawn.TG_ZOOM_VISUAL
/*enum TG_ZOOM_VISUAL
{
	ZV_NONE                                            = 0,
	ZV_BINOCULARS                                      = 1,
	ZV_SCOPE                                           = 2,
	ZV_MAX                                             = 3
};*/

// Enum TgGame.TgPawn.TG_DEATH_REASON
/*enum TG_DEATH_REASON
{
	DR_NORMAL                                          = 0,
	DR_DESPAWN                                         = 1,
	DR_MAX                                             = 2
};*/

// Enum TgGame.TgPawn.EZoomState
/*enum EZoomState
{
	ZST_NotZoomed                                      = 0,
	ZST_ZoomingIn                                      = 1,
	ZST_Zoomed                                         = 2,
	ZST_ZoomingOut                                     = 3,
	ZST_MAX                                            = 4
};*/

// Enum TgGame.TgPawn.TG_BUFF_TYPE
/*enum TG_BUFF_TYPE
{
	BUFF_UNKNOWN                                       = 0,
	BUFF_EFFECT                                        = 1,
	BUFF_SELFEFFECT                                    = 2,
	BUFF_DEVICE                                        = 3,
	BUFF_PET                                           = 4,
	BUFF_MAX                                           = 5
};*/

// Enum TgGame.TgPawn.TG_BUFF_SOURCE_TYPE
/*enum TG_BUFF_SOURCE_TYPE
{
	BUFF_SOURCE_TYPE_SKILL                             = 0,
	BUFF_SOURCE_TYPE_ITEM                              = 1,
	BUFF_SOURCE_TYPE_EFFICIENCY                        = 2,
	BUFF_SOURCE_TYPE_SELF                              = 3,
	BUFF_SOURCE_TYPE_OTHER                             = 4,
	BUFF_SOURCE_TYPE_MAX                               = 5
};*/

// Enum TgGame.TgPawn.TG_EMOTE_TYPE
/*enum TG_EMOTE_TYPE
{
	EMOTE_NONE                                         = 0,
	EMOTE_SEARCH                                       = 1,
	EMOTE_YELL                                         = 2,
	EMOTE_STARTLE                                      = 3,
	EMOTE_TALK                                         = 4,
	EMOTE_CRY                                          = 5,
	EMOTE_LAUGH                                        = 6,
	EMOTE_TAUNT                                        = 7,
	EMOTE_SPIT                                         = 8,
	EMOTE_TRIGGER_ON                                   = 9,
	EMOTE_TRIGGER_OFF                                  = 10,
	EMOTE_PATROL1                                      = 11,
	EMOTE_AIRGUITAR                                    = 12,
	EMOTE_APPLAUSE                                     = 13,
	EMOTE_BOW                                          = 14,
	EMOTE_CELEBRATE                                    = 15,
	EMOTE_CHICKENDANCE                                 = 16,
	EMOTE_FLEX                                         = 17,
	EMOTE_HANDSTAND                                    = 18,
	EMOTE_HEISMAN                                      = 19,
	EMOTE_JIG                                          = 20,
	EMOTE_KARATEKID                                    = 21,
	EMOTE_KONG                                         = 22,
	EMOTE_LAUGH2                                       = 23,
	EMOTE_LAUGH3                                       = 24,
	EMOTE_LEWDGESTURE                                  = 25,
	EMOTE_LOOKAROUND                                   = 26,
	EMOTE_RUMPSHAKA                                    = 27,
	EMOTE_SHADOWBOX                                    = 28,
	EMOTE_TOUCHDOWN                                    = 29,
	EMOTE_RADIO                                        = 30,
	EMOTE_RADIOSHORT                                   = 31,
	EMOTE_AGREE                                        = 32,
	EMOTE_AMIGO                                        = 33,
	EMOTE_COMEHERE                                     = 34,
	EMOTE_DISAGREE                                     = 35,
	EMOTE_SALUTE                                       = 36,
	EMOTE_WAVE                                         = 37,
	EMOTE_MOONWALK                                     = 38,
	EMOTE_RDSALUTE                                     = 39,
	EMOTE_ROAR                                         = 40,
	EMOTE_SBSALUTE                                     = 41,
	EMOTE_RUMMY                                        = 42,
	EMOTE_HOEDOWN                                      = 43,
	EMOTE_ROBODANCE                                    = 44,
	EMOTE_PSYCHO                                       = 45,
	EMOTE_FACEPALM                                     = 46,
	EMOTE_NO                                           = 47,
	EMOTE_HUG                                          = 48,
	EMOTE_HELLO                                        = 49,
	EMOTE_BYE                                          = 50,
	EMOTE_THANK                                        = 51,
	EMOTE_WELCOME                                      = 52,
	EMOTE_POINT                                        = 53,
	EMOTE_NOD                                          = 54,
	EMOTE_WAIT                                         = 55,
	EMOTE_SIGH                                         = 56,
	EMOTE_FOLLOWME                                     = 57,
	EMOTE_POSITIVE                                     = 58,
	EMOTE_MAX                                          = 59
};*/

// Enum TgGame.TgPawn.TG_EMOTE_LENGTH
/*enum TG_EMOTE_LENGTH
{
	EMOTE_LENGTH_NONE                                  = 0,
	EMOTE_LENGTH_SHORT                                 = 1,
	EMOTE_LENGTH_MEDIUM                                = 2,
	EMOTE_LENGTH_LONG                                  = 3,
	EMOTE_LENGTH_RANDOM                                = 4,
	EMOTE_LENGTH_MAX                                   = 5
};*/

// Enum TgGame.TgPawn.TG_AIM_TYPE
/*enum TG_AIM_TYPE
{
	TG_AIM_X                                           = 0,
	TG_AIM_Y                                           = 1,
	TG_AIM_XY                                          = 2,
	TG_AIM_LOOKAT                                      = 3,
	TG_AIM_NONE                                        = 4,
	TG_AIM_MAX                                         = 5
};*/

// Enum TgGame.TgPawn.TG_POSTURE
/*enum TG_POSTURE
{
	TG_POSTURE_DEFAULT                                 = 0,
	TG_POSTURE_HIBERNATE                               = 1,
	TG_POSTURE_ENRAGED                                 = 2,
	TG_POSTURE_SCARED                                  = 3,
	TG_POSTURE_WOUNDED                                 = 4,
	TG_POSTURE_STUNNED                                 = 5,
	TG_POSTURE_SHORTCIRCUIT                            = 6,
	TG_POSTURE_CONFUSE                                 = 7,
	TG_POSTURE_SLOW                                    = 8,
	TG_POSTURE_KNOCKBACK                               = 9,
	TG_POSTURE_SLEEP                                   = 10,
	TG_POSTURE_CRITICALFAILURE                         = 11,
	TG_POSTURE_IMMOBILIZE                              = 12,
	TG_POSTURE_VISIONBLUR                              = 13,
	TG_POSTURE_WEAKNESS                                = 14,
	TG_POSTURE_BLOCKING                                = 15,
	TG_POSTURE_JOB1                                    = 16,
	TG_POSTURE_JOB2                                    = 17,
	TG_POSTURE_PATROL                                  = 18,
	TG_POSTURE_RELAX                                   = 19,
	TG_POSTURE_ATCONSOLE                               = 20,
	TG_POSTURE_GENERICFIRE1                            = 21,
	TG_POSTURE_GENERICFIRE2                            = 22,
	TG_POSTURE_GENERICFIRE3                            = 23,
	TG_POSTURE_BLOCKSTUN                               = 24,
	TG_POSTURE_REST                                    = 25,
	TG_POSTURE_STARTLED                                = 26,
	TG_POSTURE_LOWPROFILEPANIC                         = 27,
	TG_POSTURE_RUNNINGPANIC                            = 28,
	TG_POSTURE_SCAREDANDWOUNDED                        = 29,
	TG_POSTURE_SEARCHING                               = 30,
	TG_POSTURE_NONE                                    = 31,
	TG_POSTURE_MAX                                     = 32
};*/

// Enum TgGame.TgPawn.EPhysAnimState
/*enum EPhysAnimState
{
	PhysAnim_FixedAll                                  = 0,
	PhysAnim_FixedLower                                = 1,
	PhysAnim_MotorRagdoll                              = 2,
	PhysAnim_Floppy                                    = 3,
	PhysAnim_BoneSprings                               = 4,
	PhysAnim_Recover                                   = 5,
	PhysAnim_FixPelvis                                 = 6,
	PhysAnim_MAX                                       = 7
};*/

// Enum TgGame.TgPawn.ESilentMode
/*enum ESilentMode
{
	Silent_Normal                                      = 0,
	Silent_Walking                                     = 1,
	Silent_Sprinting                                   = 2,
	Silent_MAX                                         = 3
};*/

// Enum TgGame.TgAnimBlendByDirection.EBlendDirTypes
/*enum EBlendDirTypes
{
	FBDir_Forward                                      = 0,
	FBDir_Back                                         = 1,
	FBDir_Left                                         = 2,
	FBDir_Right                                        = 3,
	FBDir_ForwardRight                                 = 4,
	FBDir_ForwardLeft                                  = 5,
	FBDir_BackRight                                    = 6,
	FBDir_BackLeft                                     = 7,
	FBDir_Standing                                     = 8,
	FBDir_None                                         = 9,
	FBDir_MAX                                          = 10
};*/

// Enum TgGame.TgAnimBlendByDirection.EBlendByDirectionSpeedType
/*enum EBlendByDirectionSpeedType
{
	EBBDST_Velocity                                    = 0,
	EBBDST_Accel                                       = 1,
	EBBDST_MAX                                         = 2
};*/

// Enum TgGame.TgAnimBlendByFall.EBlendFallTypes
/*enum EBlendFallTypes
{
	FBT_Up                                             = 0,
	FBT_UpLoop                                         = 1,
	FBT_Down                                           = 2,
	FBT_PreLand                                        = 3,
	FBT_Land                                           = 4,
	FBT_None                                           = 5,
	FBT_MAX                                            = 6
};*/

// Enum TgGame.TgAnimBlendByFall.EFallStyle
/*enum EFallStyle
{
	FS_Standard                                        = 0,
	FS_Grapple                                         = 1,
	FS_Hanging                                         = 2,
	FS_WallJump                                        = 3,
	FS_MAX                                             = 4
};*/

// Enum TgGame.TgAnimBlendByFlying.EFlyDirTypes
/*enum EFlyDirTypes
{
	FDir_Forward                                       = 0,
	FDir_Back                                          = 1,
	FDir_Left                                          = 2,
	FDir_Right                                         = 3,
	FDir_Up                                            = 4,
	FDir_Down                                          = 5,
	FDir_UpMidair                                      = 6,
	FDir_None                                          = 7,
	FDir_MAX                                           = 8
};*/

// Enum TgGame.TgAnimBlendByGrapple.EGrappleActionTypes
/*enum EGrappleActionTypes
{
	FGrappleAction_Idle                                = 0,
	FGrappleAction_Up                                  = 1,
	FGrappleAction_Down                                = 2,
	FGrappleAction_Stop                                = 3,
	FGrappleAction_DismountMomentum                    = 4,
	FGrappleAction_MAX                                 = 5
};*/

// Enum TgGame.TgAnimBlendByMelee.BLEND_BY_MELEE_FIRE_DIRECTIONS
/*enum BLEND_BY_MELEE_FIRE_DIRECTIONS
{
	BMM_FromRight                                      = 0,
	BMM_FromLeft                                       = 1,
	BMM_MAX                                            = 2
};*/

// Enum TgGame.TgAnimBlendByObjectiveStatus.ObjectiveStatus
/*enum ObjectiveStatus
{
	ObjectiveAnim_NonMovingUncontested                 = 0,
	ObjectiveAnim_NonMovingContested                   = 1,
	ObjectiveAnim_Moving                               = 2,
	ObjectiveAnim_MAX                                  = 3
};*/

// Enum TgGame.TgAnimBlendBySpeed.ESpeedType
/*enum ESpeedType
{
	EST_Velocity                                       = 0,
	EST_AccelAndMaxSpeed                               = 1,
	EST_MAX                                            = 2
};*/

// Enum TgGame.TgAnimBlendByStance.EStanceTypes
/*enum EStanceTypes
{
	Stance_Standard                                    = 0,
	Stance_Aiming                                      = 1,
	Stance_MAX                                         = 2
};*/

// Enum TgGame.TgAnimNodeBlendByHanging.EHangingActionTypes
/*enum EHangingActionTypes
{
	Hanging_Grab                                       = 0,
	Hanging_Idle                                       = 1,
	Hanging_BuildupDismount                            = 2,
	Hanging_MAX                                        = 3
};*/

// Enum TgGame.TgAnimNodeBlendByHanging.EHangSurfaceTypes
/*enum EHangSurfaceTypes
{
	HST_None                                           = 0,
	HST_Wall                                           = 1,
	HST_Catwalk                                        = 2,
	HST_WallNoVolume                                   = 3,
	HST_MAX                                            = 4
};*/

// Enum TgGame.TgAnimNodeBlendByKnockdown.EKnockDownChildren
/*enum EKnockDownChildren
{
	KNOCKDOWNANIM_Input                                = 0,
	KNOCKDOWNANIM_DownState                            = 1,
	KNOCKDOWNANIM_GetUp                                = 2,
	KNOCKDOWNANIM_MAX                                  = 3
};*/

// Enum TgGame.TgAnimNodeBlendByMeleeWeaponAnim.TG_MELEE_WEAPON_ANIM_TYPE
/*enum TG_MELEE_WEAPON_ANIM_TYPE
{
	MWAT_Default                                       = 0,
	MWAT_DualSword                                     = 1,
	MWAT_MAX                                           = 2
};*/

// Enum TgGame.TgAnimNodeBlendByQuestGiver.AnimQuestGiverState
/*enum AnimQuestGiverState
{
	ANIMQUEST_None                                     = 0,
	ANIMQUEST_NoQuest                                  = 1,
	ANIMQUEST_Quest                                    = 2,
	ANIMQUEST_QuestComplete                            = 3,
	ANIMQUEST_MAX                                      = 4
};*/

// Enum TgGame.TgAnimNodeBlendBySkydiving.ESkydivingActionTypes
/*enum ESkydivingActionTypes
{
	FSkydivingAction_None                              = 0,
	FSkydivingAction_MoveForward                       = 1,
	FSkydivingAction_Launch                            = 2,
	FSkydivingAction_Down                              = 3,
	FSkydivingAction_Left                              = 4,
	FSkydivingAction_Right                             = 5,
	FSkydivingAction_Forward                           = 6,
	FSkydivingAction_Backward                          = 7,
	FSkydivingAction_Preland                           = 8,
	FSkydivingAction_MAX                               = 9
};*/

// Enum TgGame.TgAnimNodeBlendList_EquipScreen.EEquipScreenAnimTypes
/*enum EEquipScreenAnimTypes
{
	ESAT_Default                                       = 0,
	ESAT_Weapon                                        = 1,
	ESAT_Helmet                                        = 2,
	ESAT_Backpack                                      = 3,
	ESAT_Suit                                          = 4,
	ESAT_MAX                                           = 5
};*/

// Enum TgGame.TgAnimNodeBlendNPC.NPCAnimationStates
/*enum NPCAnimationStates
{
	NPCAS_NoCustomerPresent                            = 0,
	NPCAS_CustomerPresent                              = 1,
	NPCAS_Greeting                                     = 2,
	NPCAS_NoSale                                       = 3,
	NPCAS_CallOut                                      = 4,
	NPCAS_Sale                                         = 5,
	NPCAS_TransCustomerPresentToNotPresent             = 6,
	NPCAS_None                                         = 7,
	NPCAS_MAX                                          = 8
};*/

// Enum TgGame.TgAnimNotify_AudioGroup.TG_MESH_SOURCE
/*enum TG_MESH_SOURCE
{
	TG_MESH_SOURCE_PAWN                                = 0,
	TG_MESH_SOURCE_IN_HAND_DEVICE                      = 1,
	TG_MESH_SOURCE_MAX                                 = 2
};*/

// Enum TgGame.TgAnimNotify_MeleeDamage.m_EAttackDirection
/*enum m_EAttackDirection
{
	RightToLeft                                        = 0,
	LeftToRight                                        = 1,
	m_EAttackDirection_MAX                             = 2
};*/

// Enum TgGame.TgObject.ENPCVoices
/*enum ENPCVoices
{
	NPCVOICE_VendorMale01                              = 0,
	NPCVOICE_VendorMale02                              = 1,
	NPCVOICE_VendorMale03                              = 2,
	NPCVOICE_VendorMale04                              = 3,
	NPCVOICE_VendorMale05                              = 4,
	NPCVOICE_VendorMale06                              = 5,
	NPCVOICE_VendorMale07                              = 6,
	NPCVOICE_VendorMale08                              = 7,
	NPCVOICE_VendorMale09                              = 8,
	NPCVOICE_VendorMale10                              = 9,
	NPCVOICE_VendorFemale01                            = 10,
	NPCVOICE_VendorFemale02                            = 11,
	NPCVOICE_VendorFemale03                            = 12,
	NPCVOICE_VendorFemale04                            = 13,
	NPCVOICE_VendorFemale05                            = 14,
	NPCVOICE_VendorFemale06                            = 15,
	NPCVOICE_VendorFemale07                            = 16,
	NPCVOICE_VendorFemale08                            = 17,
	NPCVOICE_VendorFemale09                            = 18,
	NPCVOICE_VendorFemale10                            = 19,
	NPCVOICE_MAX                                       = 20
};*/

// Enum TgGame.TgObject.AlertPriority
/*enum AlertPriority
{
	APT_Minimal                                        = 0,
	APT_Normal                                         = 1,
	APT_High                                           = 2,
	APT_Critical                                       = 3,
	APT_MAX                                            = 4
};*/

// Enum TgGame.TgObject.AlertType
/*enum AlertType
{
	ATT_Regular                                        = 0,
	ATT_Beneficial                                     = 1,
	ATT_Detrimental                                    = 2,
	ATT_Important                                      = 3,
	ATT_MAX                                            = 4
};*/

// Enum TgGame.TgAnimNotify_ToggleSocketSpecialFX.TG_SFX_MESH_SOURCE
/*enum TG_SFX_MESH_SOURCE
{
	TG_SFX_MESH_SOURCE_PAWN                            = 0,
	TG_SFX_MESH_SOURCE_IN_HAND_DEVICE                  = 1,
	TG_SFX_MESH_SOURCE_MAX                             = 2
};*/

// Enum TgGame.TgAnimTurnInPlace.ForcedTransitionAngle
/*enum ForcedTransitionAngle
{
	FTA_NONE                                           = 0,
	FTA                                                = 1,
	FTA01                                              = 2,
	FTA_MAX                                            = 3
};*/

// Enum TgGame.TgMissionObjective.MissionObjectiveStatus
/*enum MissionObjectiveStatus
{
	TGMOS_NONE                                         = 0,
	TGMOS_PAUSED                                       = 1,
	TGMOS_PAUSED_CONTESTED                             = 2,
	TGMOS_DEFENDER_INHOLD                              = 3,
	TGMOS_ATTACKER_INHOLD                              = 4,
	TGMOS_DEFENDER_INPROGRESS                          = 5,
	TGMOS_ATTACKER_INPROGRESS                          = 6,
	TGMOS_DEFENDER_CAPTURED                            = 7,
	TGMOS_ATTACKER_CAPTURED                            = 8,
	TGMOS_ATTACKER_WAITING                             = 9,
	TGMOS_ATTACKER_START_NEXT                          = 10,
	TGMOS_MAX                                          = 11
};*/

// Enum TgGame.TgMissionObjective.ObjectiveStatusDisplay
/*enum ObjectiveStatusDisplay
{
	TGOSD_DEFEND                                       = 0,
	TGOSD_CAPTURE                                      = 1,
	TGOSD_DESTROY                                      = 2,
	TGOSD_MAX                                          = 3
};*/

// Enum TgGame.TgMissionObjective.HexBaseBonusDirection
/*enum HexBaseBonusDirection
{
	HBD_None                                           = 0,
	HBD_Clockwise                                      = 1,
	HBD_CounterClockwise                               = 2,
	HBD_Outer                                          = 3,
	HBD_Core                                           = 4,
	HBD_MAX                                            = 5
};*/

// Enum TgGame.TgMissionObjective.OpenWorldRole
/*enum OpenWorldRole
{
	OWR_Attacker                                       = 0,
	OWR_Defender                                       = 1,
	OWR_MAX                                            = 2
};*/

// Enum TgGame.TgBotFactory.eBotSelection
/*enum eBotSelection
{
	BS_RANDOM                                          = 0,
	BS_SEQUENTIAL                                      = 1,
	BS_MAX                                             = 2
};*/

// Enum TgGame.TgChestActor.TG_CHEST_STATE
/*enum TG_CHEST_STATE
{
	TG_CHEST_SPAWNED                                   = 0,
	TG_CHEST_OPENED                                    = 1,
	TG_CHEST_CLOSED                                    = 2,
	TG_CHEST_MAX                                       = 3
};*/

// Enum TgGame.TgDeploy_Artillery.ArtilleryType
/*enum ArtilleryType
{
	Artillery_Objective                                = 0,
	Artillery_Player                                   = 1,
	Artillery_Self                                     = 2,
	Artillery_MAX                                      = 3
};*/

// Enum TgGame.TgDeploy_ForceField.TG_DAMAGETYPE_INDEX
/*enum TG_DAMAGETYPE_INDEX
{
	TDT_THERMAL                                        = 0,
	TDT_PHYSICAL                                       = 1,
	TDT_ENERGY                                         = 2,
	TDT_BIO                                            = 3,
	TDT_MAX                                            = 4
};*/

// Enum TgGame.TgDeviceFire.ESweepType
/*enum ESweepType
{
	Sweep_Static                                       = 0,
	Sweep_Rotating                                     = 1,
	Sweep_Moving                                       = 2,
	Sweep_MAX                                          = 3
};*/

// Enum TgGame.TgDevice.EDeployModeStatus
/*enum EDeployModeStatus
{
	DMS_None                                           = 0,
	DMS_CannotFire                                     = 1,
	DMS_CannotPlace                                    = 2,
	DMS_OK                                             = 3,
	DMS_MAX                                            = 4
};*/

// Enum TgGame.TgDevice.EWeaponFireType
/*enum EWeaponFireType
{
	EWFT_InstantHit                                    = 0,
	EWFT_Projectile                                    = 1,
	EWFT_Custom                                        = 2,
	EWFT_Arcing                                        = 3,
	EWFT_None                                          = 4,
	EWFT_MAX                                           = 5
};*/

// Enum TgGame.TgTimerManager.TGT_EVENT
/*enum TGT_EVENT
{
	TGTE_DONE                                          = 0,
	TGTE_START                                         = 1,
	TGTE_UPDATE                                        = 2,
	TGTE_PAUSED                                        = 3,
	TGTE_MAX                                           = 4
};*/

// Enum TgGame.TgDeviceFire.DeviceTargetMode
/*enum DeviceTargetMode
{
	TGDTM_Melee                                        = 0,
	TGDTM_Free                                         = 1,
	TGDTM_Ground                                       = 2,
	TGDTM_MAX                                          = 3
};*/

// Enum TgGame.TgDeviceFire.DeviceTargeterType
/*enum DeviceTargeterType
{
	TGDTT_None                                         = 0,
	TGDTT_Self                                         = 1,
	TGDTT_Friend                                       = 2,
	TGDTT_Enemy                                        = 3,
	TGDTT_Enemy_And_Self                               = 4,
	TGDTT_Friend_Only                                  = 5,
	TGDTT_All                                          = 6,
	TGDTT_MAX                                          = 7
};*/

// Enum TgGame.TgDeviceFire.EffectGroupSource
/*enum EffectGroupSource
{
	TGEGS_Self                                         = 0,
	TGEGS_EffectManager                                = 1,
	TGEGS_MAX                                          = 2
};*/

// Enum TgGame.TgDistributionFloatSoundAttenuation.SoundAttenuationType
/*enum SoundAttenuationType
{
	TG_ATTENUATION_None                                = 0,
	TG_ATTENUATION_Sm_foley                            = 1,
	TG_ATTENUATION_Lg_foley                            = 2,
	TG_ATTENUATION_Melee_Hit                           = 3,
	TG_ATTENUATION_Sm_gun                              = 4,
	TG_ATTENUATION_Med_gun                             = 5,
	TG_ATTENUATION_Lg_gun                              = 6,
	TG_ATTENUATION_Sm_exp                              = 7,
	TG_ATTENUATION_Med_exp                             = 8,
	TG_ATTENUATION_Lg_exp                              = 9,
	TG_ATTENUATION_MAX                                 = 10
};*/

// Enum TgGame.TgDoorMarker.DoorStatus
/*enum DoorStatus
{
	TGD_NONE                                           = 0,
	TGD_LOCKED                                         = 1,
	TGD_OPEN                                           = 2,
	TGD_CLOSE                                          = 3,
	TGD_MAX                                            = 4
};*/

// Enum TgGame.TgEffectGroup.AttackType
/*enum AttackType
{
	TGAT_None                                          = 0,
	TGAT_Melee                                         = 1,
	TGAT_Range                                         = 2,
	TGAT_AOE                                           = 3,
	TGAT_Falling                                       = 4,
	TGAT_MAX                                           = 5
};*/

// Enum TgGame.TgGame.GameTimerState
/*enum GameTimerState
{
	TGMTS_UNSET                                        = 0,
	TGMTS_SETUP                                        = 1,
	TGMTS_MISSION_RUNNING                              = 2,
	TGMTS_MISSION_OVERTIME                             = 3,
	TGMTS_MISSION_COMPLETE                             = 4,
	TGMTS_MISSION_PAUSED                               = 5,
	TGMTS_CUSTOM                                       = 6,
	TGMTS_MAX                                          = 7
};*/

// Enum TgGame.TgGame.MedalStatus
/*enum MedalStatus
{
	TGMS_None                                          = 0,
	TGMS_Fail                                          = 1,
	TGMS_Pass                                          = 2,
	TGMS_Bronze                                        = 3,
	TGMS_Silver                                        = 4,
	TGMS_Gold                                          = 5,
	TGMS_MAX                                           = 6
};*/

// Enum TgGame.TgGame.GameRewardValuesMode
/*enum GameRewardValuesMode
{
	RVM_DEFAULT                                        = 0,
	RVM_ENDMISSION                                     = 1,
	RVM_QUEST                                          = 2,
	RVM_MAX                                            = 3
};*/

// Enum TgGame.TgRepInfo_Game.MissionTimerState
/*enum MissionTimerState
{
	MTS_STOPPED                                        = 0,
	MTS_RUNNING                                        = 1,
	MTS_PAUSED                                         = 2,
	MTS_MAX                                            = 3
};*/

// Enum TgGame.TgHexItemInstance.EHexItemState
/*enum EHexItemState
{
	HIS_NotSpawned                                     = 0,
	HIS_Factory                                        = 1,
	HIS_PickedUp                                       = 2,
	HIS_Placed                                         = 3,
	HIS_Destroyed                                      = 4,
	HIS_DoNotSpawn                                     = 5,
	HIS_MAX                                            = 6
};*/

// Enum TgGame.TgHitDisplayActor.EHitDisplayDirection
/*enum EHitDisplayDirection
{
	EHDD_F                                             = 0,
	EHDD_FL                                            = 1,
	EHDD_L                                             = 2,
	EHDD_BL                                            = 3,
	EHDD_B                                             = 4,
	EHDD_BR                                            = 5,
	EHDD_R                                             = 6,
	EHDD_FR                                            = 7,
	EHDD_All                                           = 8,
	EHDD_None                                          = 9,
	EHDD_MAX                                           = 10
};*/

// Enum TgGame.TgPlayerController.EMouseTargetMode
/*enum EMouseTargetMode
{
	MOUSE_TARGET_NONE                                  = 0,
	MOUSE_TARGET_SELF                                  = 1,
	MOUSE_TARGET_MELEE                                 = 2,
	MOUSE_TARGET_RANGED                                = 3,
	MOUSE_TARGET_GROUND                                = 4,
	MOUSE_TARGET_TAG                                   = 5,
	MOUSE_TARGET_MAX                                   = 6
};*/

// Enum TgGame.TgPlayerController.ERangedTargetState
/*enum ERangedTargetState
{
	RANGED_TARGET_DEFAULT                              = 0,
	RANGED_TARGET_IN_RANGE                             = 1,
	RANGED_TARGET_OUT_RANGE                            = 2,
	RANGED_TARGET_FRIENDLY                             = 3,
	RANGED_TARGET_FALLOFF_RANGE                        = 4,
	RANGED_TARGET_MAX                                  = 5
};*/

// Enum TgGame.TgPlayerController.EWatchOtherPlayersMode
/*enum EWatchOtherPlayersMode
{
	WOPM_NONE                                          = 0,
	WOPM_PLAYER                                        = 1,
	WOPM_CAMERA                                        = 2,
	WOPM_MAX                                           = 3
};*/

// Enum TgGame.TgPlayerController.ETimerCommand
/*enum ETimerCommand
{
	TIMER_START                                        = 0,
	TIMER_PAUSE                                        = 1,
	TIMER_STOP                                         = 2,
	TIMER_MAX                                          = 3
};*/

// Enum TgGame.TgInventoryObject.EReplicatedState
/*enum EReplicatedState
{
	IORS_Ok                                            = 0,
	IORS_Edited                                        = 1,
	IORS_Deleted                                       = 2,
	IORS_MAX                                           = 3
};*/

// Enum TgGame.TgNavRouteIndicator.eSetRouteResult
/*enum eSetRouteResult
{
	SetRoute_Failed                                    = 0,
	SetRoute_OK                                        = 1,
	SetRoute_AtDestination                             = 2,
	SetRoute_MAX                                       = 3
};*/

// Enum TgGame.TgObject.TgSupportedAspectRatios
/*enum TgSupportedAspectRatios
{
	TgAR_4x3                                           = 0,
	TgAR_5x4                                           = 1,
	TgAR_16x9                                          = 2,
	TgAR_16x10                                         = 3,
	TgAR_Other                                         = 4,
	TgAR_MAX                                           = 5
};*/

// Enum TgGame.TgObjectiveAssignment.AssignmentState
/*enum AssignmentState
{
	AMS_None                                           = 0,
	AMS_Pending                                        = 1,
	AMS_Active                                         = 2,
	AMS_AttackerWon                                    = 3,
	AMS_DefenderWon                                    = 4,
	AMS_Abandoned                                      = 5,
	AMS_MAX                                            = 6
};*/

// Enum TgGame.TgOmegaVolume.eVolumeVisualCue
/*enum eVolumeVisualCue
{
	eVVC_None                                          = 0,
	eVVC_ObjectiveQuestAvailableSoon                   = 1,
	eVVC_QuestAvailableSoon                            = 2,
	eVVC_IncompleteTurnin                              = 3,
	eVVC_AvailableTurninOnlyQuest                      = 4,
	eVVC_AvailableObjectiveQuest                       = 5,
	eVVC_AvailableRepeatableQuest                      = 6,
	eVVC_AvailableQuest                                = 7,
	eVVC_HelperUIVolume                                = 8,
	eVVC_TargetUIVolume                                = 9,
	eVVC_CompleteTurnin                                = 10,
	eVVC_MAX                                           = 11
};*/

// Enum TgGame.TgPawn.TG_TELEPORT_STATE
/*enum TG_TELEPORT_STATE
{
	TELEPORT_NONE                                      = 0,
	TELEPORT_READY                                     = 1,
	TELEPORT_ENTER                                     = 2,
	TELEPORT_EXIT                                      = 3,
	TELEPORT_MAX                                       = 4
};*/

// Enum TgGame.TgSpecialFx.ELightFxState
/*enum ELightFxState
{
	LFX_UNMANAGED                                      = 0,
	LFX_ACTIVE                                         = 1,
	LFX_KILLEDBYMGR                                    = 2,
	LFX_DYING                                          = 3,
	LFX_INACTIVE                                       = 4,
	LFX_MAX                                            = 5
};*/

// Enum TgGame.TgPawn_Character.TG_ATTACHED_MESH
/*enum TG_ATTACHED_MESH
{
	TAM_NONE                                           = 0,
	TAM_BACKPACK_STATIC                                = 1,
	TAM_BACKPACK_SKELETAL                              = 2,
	TAM_JETPACK                                        = 3,
	TAM_MAX                                            = 4
};*/

// Enum TgGame.TgPawn_AttackTransport.ETgAttackTransportDeathType
/*enum ETgAttackTransportDeathType
{
	ATDT_None                                          = 0,
	ATDT_TailFliesOff                                  = 1,
	ATDT_ExplodesHovering                              = 2,
	ATDT_PropellersFlyOff                              = 3,
	ATDT_MAX                                           = 4
};*/

// Enum TgGame.TgPawn_Hunter.EHunterClasses
/*enum EHunterClasses
{
	HUNT_None                                          = 0,
	HUNT_Recon                                         = 1,
	HUNT_Assault                                       = 2,
	HUNT_Robotics                                      = 3,
	HUNT_Medic                                         = 4,
	HUNT_MAX                                           = 5
};*/

// Enum TgGame.TgPawn_Scanner.EScannerPhases
/*enum EScannerPhases
{
	ScannerPhase_Patrol                                = 0,
	ScannerPhase_SensorSweep                           = 1,
	ScannerPhase_PowerRecharge                         = 2,
	ScannerPhase_Alarm                                 = 3,
	ScannerPhase_MAX                                   = 4
};*/

// Enum TgGame.TgPawn_Marauder.TG_CONSTRICTED_YAW_OFFSET_DIR
/*enum TG_CONSTRICTED_YAW_OFFSET_DIR
{
	TGCYO_None                                         = 0,
	TGCYO_Left                                         = 1,
	TGCYO_Right                                        = 2,
	TGCYO_MAX                                          = 3
};*/

// Enum TgGame.TgPawn_Reaper.ReaperPhases
/*enum ReaperPhases
{
	RP_Launcher                                        = 0,
	RP_LifeSuck                                        = 1,
	RP_AOEBlast                                        = 2,
	RP_MAX                                             = 3
};*/

// Enum TgGame.TgPawn_Siege.TGSiegeAccelDirection
/*enum TGSiegeAccelDirection
{
	SIEGE_Idle                                         = 0,
	Siege_F                                            = 1,
	Siege_B                                            = 2,
	Siege_L                                            = 3,
	Siege_R                                            = 4,
	SIEGE_MAX                                          = 5
};*/

// Enum TgGame.TgPawn_Switchblade.ESwitchBladePhases
/*enum ESwitchBladePhases
{
	SBP_Melee                                          = 0,
	SBP_Vortex                                         = 1,
	SBP_MAX                                            = 2
};*/

// Enum TgGame.TgPawn_ThinkTank.EScannerPhases
/*enum EScannerPhases
{
	ThinkTankPhase_Pistol                              = 0,
	ThinkTankPhase_Shield                              = 1,
	ThinkTankPhase_MAX                                 = 2
};*/

// Enum TgGame.TgPawn_Vulcan.EVulcanPhases
/*enum EVulcanPhases
{
	VulcanPhase_TopGun                                 = 0,
	VulcanPhase_MainGun_Moving                         = 1,
	VulcanPhase_MainGun_Stationary                     = 2,
	VulcanPhase_MAX                                    = 3
};*/

// Enum TgGame.TgPawn_Widow.EWidowPhases
/*enum EWidowPhases
{
	SBP_Base                                           = 0,
	SBP_Vortex                                         = 1,
	SBP_MAX                                            = 2
};*/

// Enum TgGame.TgPhysAnimTestActor.EPATAState
/*enum EPATAState
{
	PATA_FixedAll                                      = 0,
	PATA_FixedLower                                    = 1,
	PATA_MotorRagdoll                                  = 2,
	PATA_Floppy                                        = 3,
	PATA_Recover                                       = 4,
	PATA_MAX                                           = 5
};*/

// Enum TgGame.TgRepInfo_Player.SCORE_TYPE
/*enum SCORE_TYPE
{
	STYPE_REPPTS                                       = 0,
	STYPE_KILLS                                        = 1,
	STYPE_ASSISTS                                      = 2,
	STYPE_DAMAGETAKEN                                  = 3,
	STYPE_DAMAGE                                       = 4,
	STYPE_BUFFVALUE                                    = 5,
	STYPE_HEALING                                      = 6,
	STYPE_DEFENSE                                      = 7,
	STYPE_DEATHS                                       = 8,
	STYPE_OBJS                                         = 9,
	STYPE_KILLS_BOT                                    = 10,
	STYPE_MAX                                          = 11
};*/

// Enum TgGame.TgRepInfo_Player.DEVICE_STATS
/*enum DEVICE_STATS
{
	DS_ID                                              = 0,
	DS_DAMAGE                                          = 1,
	DS_HEALING                                         = 2,
	DS_PLAYER_KILLS                                    = 3,
	DS_BOT_KILLS                                       = 4,
	DS_DPM                                             = 5,
	DS_HPM                                             = 6,
	DS_MODE_COUNT                                      = 7,
	DS_BUFF_VALUE                                      = 8,
	DS_MAX                                             = 9
};*/

// Enum TgGame.TgSeqAct_QuestGetStatus.KismetQuestStatus
/*enum KismetQuestStatus
{
	KQS_Accepted                                       = 0,
	KQS_RequirementsComplete                           = 1,
	KQS_TurnedIn                                       = 2,
	KQS_Available                                      = 3,
	KQS_Unavailable                                    = 4,
	KQS_MAX                                            = 5
};*/

// Enum TgGame.TgSeqAct_QuestRequirementGetStatus.KismetQuestRequirementStatus
/*enum KismetQuestRequirementStatus
{
	KQRS_Incomplete                                    = 0,
	KQRS_Complete                                      = 1,
	KQRS_MAX                                           = 2
};*/

// Enum TgGame.TgSeqAct_RequestMission.EDifficultyLevel
/*enum EDifficultyLevel
{
	DL_Easy                                            = 0,
	DL_Medium                                          = 1,
	DL_Hard                                            = 2,
	DL_MAX                                             = 3
};*/

// Enum TgGame.TgSeqCond_HasCondition.ConditionType
/*enum ConditionType
{
	TGCT_POISON                                        = 0,
	TGCT_DISEASE                                       = 1,
	TGCT_REGENERATION                                  = 2,
	TGCT_STUN                                          = 3,
	TGCT_STEALTH                                       = 4,
	TGCT_EMP_STUN                                      = 5,
	TGCT_IGNITE                                        = 6,
	TGCT_INVULNERABLE                                  = 7,
	TGCT_SLOW                                          = 8,
	TGCT_MAX                                           = 9
};*/

// Enum TgGame.TgSeqEvent_MICParameterEvent.eMICEventType
/*enum eMICEventType
{
	MET_NONE                                           = 0,
	MET_DEFENSE_ALARM                                  = 1,
	MET_DOMECHRISTMAS                                  = 2,
	MET_HALLOFLEGENDS                                  = 3,
	MET_GANEWS                                         = 4,
	MET_SONARMS_DEALER                                 = 5,
	MET_BLACKMARKET_DEALER                             = 6,
	MET_MAX                                            = 7
};*/

// Enum TgGame.TgSeqEvent_Named.TSE_NAME
/*enum TSE_NAME
{
	TSE_NONE                                           = 0,
	TSE_MENU_CLOSE                                     = 1,
	TSE_MOVIE_DONE                                     = 2,
	TSE_MAX                                            = 3
};*/

// Enum TgGame.TgSeqEvent_QuestUpdated.KismetQuestUpdateEvents
/*enum KismetQuestUpdateEvents
{
	KQUE_Accepted                                      = 0,
	KQUE_RequirementsComplete                          = 1,
	KQUE_TurnedIn                                      = 2,
	KQUE_Abandoned                                     = 3,
	KQUE_MAX                                           = 4
};*/

// Enum TgGame.TgSeqEvent_RaidSideObjectiveTaken.ERaidObjectiveType
/*enum ERaidObjectiveType
{
	ROT_ALL                                            = 0,
	ROT_RESPAWN_BONUS                                  = 1,
	ROT_RESPAWN_BONUS01                                = 2,
	ROT_TURRETS                                        = 3,
	ROT_TURRETS01                                      = 4,
	ROT_PATHWAYS                                       = 5,
	ROT_PATHWAYS01                                     = 6,
	ROT_MAX                                            = 7
};*/

// Enum TgGame.TgSkelCon_FootPlacement.EFootPlacementPlayerClass
/*enum EFootPlacementPlayerClass
{
	EPPC_Recon                                         = 0,
	EPPC_Medic                                         = 1,
	EPPC_Robotics                                      = 2,
	EPPC_Assault                                       = 3,
	EPPC_MAX                                           = 4
};*/

// Enum TgGame.TgSkelCon_HoverControl.HoverDirections
/*enum HoverDirections
{
	HOVER_Idle                                         = 0,
	HOVER_F                                            = 1,
	HOVER_B                                            = 2,
	HOVER_L                                            = 3,
	HOVER_R                                            = 4,
	HOVER_FR                                           = 5,
	HOVER_FL                                           = 6,
	HOVER_BR                                           = 7,
	HOVER_BL                                           = 8,
	HOVER_MAX                                          = 9
};*/

// Enum TgGame.TgSkeletalMeshActor_MeleePreVis.MPV_Direction
/*enum MPV_Direction
{
	MPV_Forward                                        = 0,
	MPV_Backward                                       = 1,
	MPV_Left                                           = 2,
	MPV_Right                                          = 3,
	MPV_MAX                                            = 4
};*/

// Enum TgGame.TgSocketOffsetInfo.EAimDirID
/*enum EAimDirID
{
	EADID_LeftUp                                       = 0,
	EADID_LeftDown                                     = 1,
	EADID_RightUp                                      = 2,
	EADID_RightDown                                    = 3,
	EADID_ZeroUp                                       = 4,
	EADID_ZeroDown                                     = 5,
	EADID_ZeroLeft                                     = 6,
	EADID_ZeroRight                                    = 7,
	EADID_CellLU                                       = 8,
	EADID_CellCU                                       = 9,
	EADID_CellRU                                       = 10,
	EADID_CellLC                                       = 11,
	EADID_CellCC                                       = 12,
	EADID_CellRC                                       = 13,
	EADID_CellLD                                       = 14,
	EADID_CellCD                                       = 15,
	EADID_CellRD                                       = 16,
	EADID_MAX                                          = 17
};*/

// Enum TgGame.TgSoundGroup.eTG_SOUNDS
/*enum eTG_SOUNDS
{
	TGS_FOOTSTEP                                       = 0,
	TGS_DODGE                                          = 1,
	TGS_JUMP                                           = 2,
	TGS_LAND                                           = 3,
	TGS_DOUBLEJUMP                                     = 4,
	TGS_DOUBLELAND                                     = 5,
	TGS_DYING                                          = 6,
	TGS_HIT                                            = 7,
	TGS_MAX                                            = 8
};*/

// Enum TgGame.TgSpecialFxLightManager.SpecialFxLightState
/*enum SpecialFxLightState
{
	FxLight_Normal                                     = 0,
	FxLight_Dying                                      = 1,
	FxLight_Kill                                       = 2,
	FxLight_MAX                                        = 3
};*/

// Enum TgGame.TgTeamBeaconManager.BeaconStatus
/*enum BeaconStatus
{
	TG_BEACON_STATUS_NONE                              = 0,
	TG_BEACON_STATUS_PICKED_UP                         = 1,
	TG_BEACON_STATUS_DEPLOYING                         = 2,
	TG_BEACON_STATUS_DEPLOYED                          = 3,
	TG_BEACON_STATUS_FORWARD_SPAWN                     = 4,
	TG_BEACON_STATUS_AT_SPAWN                          = 5,
	TG_BEACON_STATUS_MAX                               = 6
};*/

// Enum TgGame.TgTeleportPlayerVolume.TgTeleportVolumeType
/*enum TgTeleportVolumeType
{
	Inactive                                           = 0,
	Respawn                                            = 1,
	TgTeleportVolumeType_MAX                           = 2
};*/

// Enum TgGame.TgUIAction_TriggerTutorial.ETutorialTypes
/*enum ETutorialTypes
{
	Tut_None                                           = 0,
	Tut_Jetpack                                        = 1,
	Tut_Melee                                          = 2,
	Tut_Ranged                                         = 3,
	Tut_FirstOffhand                                   = 4,
	Tut_SpecialtyOffhandCombo                          = 5,
	Tut_NewPlayerSplash                                = 6,
	Tut_UIVolumes                                      = 7,
	Tut_QuestIndicators                                = 8,
	Tut_BeaconNetwork                                  = 9,
	Tut_MAX                                            = 10
};*/

// Enum TgGame.TgUIHexWidget.HEX_BOUND_STATE
/*enum HEX_BOUND_STATE
{
	HEX_UNSET                                          = 0,
	HEX_INSIDE                                         = 1,
	HEX_OVERLAP                                        = 2,
	HEX_OUTSIDE                                        = 3,
	HEX_MAX                                            = 4
};*/

// Enum TgGame.TgUIInvWidget.TG_WIDGET_SUBTYPES
/*enum TG_WIDGET_SUBTYPES
{
	IST_NONE                                           = 0,
	IST_DEVICE_MELEE                                   = 1,
	IST_DEVICE_RANGED                                  = 2,
	IST_DEVICE_SPECIALTY                               = 3,
	IST_DEVICE_JETPACK                                 = 4,
	IST_DEVICE_OFFHAND                                 = 5,
	IST_DEVICE_OFFHAND01                               = 6,
	IST_DEVICE_OFFHAND02                               = 7,
	IST_DEVICE_MORALE                                  = 8,
	IST_DEVICE_PICKUP                                  = 9,
	IST_DEVICE_CONSUMABLE                              = 10,
	IST_DEVICE_REST                                    = 11,
	IST_ARMOR_HEAD                                     = 12,
	IST_ARMOR_SHOULDER                                 = 13,
	IST_ARMOR_CHEST                                    = 14,
	IST_ARMOR_ARM                                      = 15,
	IST_ARMOR_HAND                                     = 16,
	IST_ARMOR_LEG                                      = 17,
	IST_ARMOR_FEET                                     = 18,
	IST_FLAIR_HELMET                                   = 19,
	IST_FLAIR_SUIT                                     = 20,
	IST_DYE_PRIMARY                                    = 21,
	IST_DYE_SECONDARY                                  = 22,
	IST_DYE_EMISSIVE                                   = 23,
	IST_DYE_WEAPON_PRIMARY                             = 24,
	IST_DYE_WEAPON_EMISSIVE                            = 25,
	IST_DYE_JETPACK_TRAIL                              = 26,
	IST_MAX                                            = 27
};*/

// Enum TgGame.TgUIInvWidget.TimedParamType
/*enum TimedParamType
{
	PT_AVAILABLE_FLASH                                 = 0,
	PT_USE_HIGHLIGHT                                   = 1,
	PT_COOLDOWN_SWOOP                                  = 2,
	PT_MAX                                             = 3
};*/

// Enum TgGame.TgUIMapWidget.EZoneMapStructType
/*enum EZoneMapStructType
{
	ZMST_None                                          = 0,
	ZMST_Objective                                     = 1,
	ZMST_Player                                        = 2,
	ZMST_Volume                                        = 3,
	ZMST_QuestVolume                                   = 4,
	ZMST_QuestPOI                                      = 5,
	ZMST_Portal                                        = 6,
	ZMST_MAX                                           = 7
};*/

// Enum TgGame.TgWindManager.TG_WIND_TYPE
/*enum TG_WIND_TYPE
{
	TG_WIND_Directional                                = 0,
	TG_WIND_Radial                                     = 1,
	TG_WIND_MAX                                        = 2
};*/


/*
# ========================================================================================= #
# Classes
# ========================================================================================= #
*/

// Class TgGame.TgAnimNodeBlendByVerticalAim
// 0x003B (0x011C - 0x00E1)
class UTgAnimNodeBlendByVerticalAim : public UAnimNodeBlendBase
{
public:
	float                                              m_Aim;                                            		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_Range;                                          		// 0x00E8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_AngleOffset;                                    		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_PreviousAim;                                    		// 0x00F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bInitialized : 1;                                 		// 0x00F8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bLoopChildrenOnRelevant : 1;                    		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bPlayChildrenOnRelevant : 1;                    		// 0x00F8 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	struct FName                                       m_AnimName_Up;                                    		// 0x00FC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AnimName_Center;                                		// 0x0104 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AnimName_Down;                                  		// 0x010C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeSequence*                           m_SeqNode1;                                       		// 0x0114 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UAnimNodeSequence*                           m_SeqNode2;                                       		// 0x0118 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1192 ];

		return pClassPointer;
	};

	void eventOnBecomeRelevant ( );
	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimNodeBlendByVerticalAim::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSequence
// 0x000A (0x0128 - 0x011E)
class UTgAnimNodeSequence : public UAnimNodeSequence
{
public:
	unsigned long                                      bAutoStart : 1;                                   		// 0x0120 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bResetOnActivate : 1;                             		// 0x0120 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      HasDynamicLength : 1;                             		// 0x0120 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      EnableFootControlsOnCease : 1;                    		// 0x0120 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	float                                              ChainedSequenceDuration;                          		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1193 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeSequence::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_DeployOffhand
// 0x0000 (0x003C - 0x003C)
class UTgAnimNotify_DeployOffhand : public UAnimNotify
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1194 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_DeployOffhand::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_FootSkelControl
// 0x0008 (0x0044 - 0x003C)
class UTgAnimNotify_FootSkelControl : public UAnimNotify
{
public:
	int                                                c_Foot;                                           		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      c_bDisable : 1;                                   		// 0x0040 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1195 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_FootSkelControl::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_MeleeDamage
// 0x0005 (0x0041 - 0x003C)
class UTgAnimNotify_MeleeDamage : public UAnimNotify
{
public:
	float                                              m_Impulse;                                        		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_AttackDirection;                                		// 0x0040 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1196 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_MeleeDamage::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_PawnCanRefire
// 0x0004 (0x0040 - 0x003C)
class UTgAnimNotify_PawnCanRefire : public UAnimNotify
{
public:
	unsigned long                                      m_bForceLeftAttack : 1;                           		// 0x003C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1197 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_PawnCanRefire::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_SwapDevice
// 0x0000 (0x003C - 0x003C)
class UTgAnimNotify_SwapDevice : public UAnimNotify
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1198 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_SwapDevice::pClassPointer = NULL;

// Class TgGame.TgCaptureComponent
// 0x0010 (0x0130 - 0x0120)
class UTgCaptureComponent : public USceneCapture2DComponent
{
public:
	struct FQWord                                      m_qwShowFlags;                                    		// 0x0120 (0x0008) [0x0000000000000000]              
	unsigned long                                      m_bNeedsFullUpdate : 1;                           		// 0x0128 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FPointer                                    m_CaptureInfo;                                    		// 0x012C (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1199 ];

		return pClassPointer;
	};

	void ForceFullUpdate ( );
};

UClass* UTgCaptureComponent::pClassPointer = NULL;

// Class TgGame.TgCharacterBuilderLight
// 0x0000 (0x01D4 - 0x01D4)
class ATgCharacterBuilderLight : public ASpotLightToggleable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1200 ];

		return pClassPointer;
	};

};

UClass* ATgCharacterBuilderLight::pClassPointer = NULL;

// Class TgGame.TgChestActor
// 0x004C (0x0218 - 0x01CC)
class ATgChestActor : public AActor
{
public:
	struct FString                                     m_sAssemblyName;                                  		// 0x01CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bMeshLoaded : 1;                                		// 0x01D8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bSpawnOnLevelLoad : 1;                          		// 0x01D8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bAutoSpawn : 1;                                 		// 0x01D8 (0x0004) [0x0000000000000000] [0x00000004] 
	class UTgSkeletalMeshComponent*                    m_Mesh;                                           		// 0x01DC (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                 		// 0x01E0 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	int                                                m_nUseMsgId;                                      		// 0x01E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nLootTableId;                                   		// 0x01E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_MinRespawnTime;                                 		// 0x01EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_MaxRespawnTime;                                 		// 0x01F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      r_eChestState;                                    		// 0x01F4 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eCurrentChestState;                             		// 0x01F5 (0x0001) [0x0000000000000000]              
	int                                                m_nTimeTakeToClose;                               		// 0x01F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nUseProxySize;                                  		// 0x01FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_LastUsePawn;                                    		// 0x0200 (0x0004) [0x0000000000000000]              
	class UCylinderComponent*                          CylinderComponent;                                		// 0x0204 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ATgCollisionProxy*                           m_CollisionProxy;                                 		// 0x0208 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UAnimNodeSequence*                           m_AnimNode;                                       		// 0x020C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              AlwaysRelevantDistanceSquared;                    		// 0x0210 (0x0004) [0x0000000000000000]              
	int                                                m_nPlayerTakeforceNumber;                         		// 0x0214 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1201 ];

		return pClassPointer;
	};

	void eventShowMesh ( );
	void eventHideMesh ( );
	void AdjustClientChestState ( );
	void RemoveUserPrompt ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DisplayUseMessage ( class ATgPawn* aPawn, unsigned long bDisplay );
	void OnToggle ( class USeqAct_Toggle* Action );
	void PostBeginPlay ( );
	void ForceNetRelevant ( );
	void CloseChest ( );
	void LootChest ( );
	void OpenChest ( class ATgPawn* aPawn );
	void RespawnChest ( );
	void SpawnChest ( );
	void LoadMesh ( );
};

UClass* ATgChestActor::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy
// 0x0010 (0x01DC - 0x01CC)
class ATgCollisionProxy : public AActor
{
public:
	TArray< class ATgPawn* >                           m_NearByPlayers;                                  		// 0x01CC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bIgnoreStealthPlayers : 1;                      		// 0x01D8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIgnoreNonPlayers : 1;                          		// 0x01D8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bIgnoreHackedPawns : 1;                         		// 0x01D8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bIgnoreInvulnerablePlayers : 1;                 		// 0x01D8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bForwardOwnerOnly : 1;                          		// 0x01D8 (0x0004) [0x0000000000000000] [0x00000010] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1202 ];

		return pClassPointer;
	};

	void GetNearByPlayersTaskforce ( unsigned long bEndWhenMultipleFound, TArray< int >* NearByPlayerTaskForces );
	int GetNearByPlayers ( unsigned long bOnlyValid );
	void OnPlayerRemoved ( class ATgPawn* aPawn );
	void OnPlayerAdded ( class ATgPawn* aPawn );
	void CheckNearByPlayers ( class ATgPawn* aPawn, unsigned long bAdd );
	void ForceClearNearByPlayersList ( );
	bool eventShouldIgnoreActor ( class ATgPawn* aPawn );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgCollisionProxy::pClassPointer = NULL;

// Class TgGame.TgCollisionProxy_Vortex
// 0x0020 (0x01FC - 0x01DC)
class ATgCollisionProxy_Vortex : public ATgCollisionProxy
{
public:
	float                                              m_fGroundSpeedStrafePct;                          		// 0x01DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGroundSpeedToVortex;                           		// 0x01E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGroundSpeedAdditive;                           		// 0x01E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fAirSpeed;                                      		// 0x01E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fFlySpeedToVortex;                              		// 0x01EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fFlySpeedToAdditive;                            		// 0x01F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fInnerRadius;                                   		// 0x01F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bEnabled : 1;                                   		// 0x01F8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bOnlyAffectCurrentTarget : 1;                   		// 0x01F8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1203 ];

		return pClassPointer;
	};

	void OnPlayerRemoved ( class ATgPawn* aPawn );
	void OnPlayerAdded ( class ATgPawn* aPawn );
	bool eventShouldIgnoreActor ( class ATgPawn* aPawn );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgCollisionProxy_Vortex::pClassPointer = NULL;

// Class TgGame.TgDamageType
// 0x0054 (0x00E0 - 0x008C)
class UTgDamageType : public UDamageType
{
public:
	unsigned long                                      m_bImpulseMesh : 1;                               		// 0x008C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bRagdollOnDeathAnimEnd : 1;                     		// 0x008C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bEnableDirectionalDeathAnims : 1;               		// 0x008C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bPoke : 1;                                      		// 0x008C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bShowDamageFromInstigator : 1;                  		// 0x008C (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              m_bMinImpulse;                                    		// 0x0090 (0x0004) [0x0000000000000000]              
	float                                              m_bMaxImpulse;                                    		// 0x0094 (0x0004) [0x0000000000000000]              
	float                                              m_bMinUpKick;                                     		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              m_bMaxUpKick;                                     		// 0x009C (0x0004) [0x0000000000000000]              
	float                                              m_fChanceToPlayDeathAnim;                         		// 0x00A0 (0x0004) [0x0000000000000000]              
	float                                              m_fChanceToPlayWritheAnim;                        		// 0x00A4 (0x0004) [0x0000000000000000]              
	TArray< struct FDamageTypeAnimInfo >               m_DeathAnimHitFromFrontInfo;                      		// 0x00A8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FDamageTypeAnimInfo >               m_DeathAnimHitFromBackInfo;                       		// 0x00B4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FDamageTypeAnimInfo >               m_WritheAnimFaceUpInfo;                           		// 0x00C0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FDamageTypeAnimInfo >               m_WritheAnimFaceDownInfo;                         		// 0x00CC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fRestSpeed;                                     		// 0x00D8 (0x0004) [0x0000000000000000]              
	float                                              m_fPokeIntensity;                                 		// 0x00DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1204 ];

		return pClassPointer;
	};

};

UClass* UTgDamageType::pClassPointer = NULL;

// Class TgGame.TgDebug
// 0x0034 (0x0070 - 0x003C)
class UTgDebug : public UObject
{
public:
	struct FString                                     TgAccountName;                                    		// 0x003C (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	struct FString                                     TgAccountPassword;                                		// 0x0048 (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	struct FString                                     TgSecondAccountName;                              		// 0x0054 (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	struct FString                                     TgSecondAccountPassword;                          		// 0x0060 (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	unsigned long                                      AutomateLogin : 1;                                		// 0x006C (0x0004) [0x0000000000044000] [0x00000001] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      SaveAccountInfo : 1;                              		// 0x006C (0x0004) [0x0000000000044000] [0x00000002] ( CPF_Config | CPF_GlobalConfig )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1205 ];

		return pClassPointer;
	};

	void eventWriteLoginInfo ( struct FString NameString, struct FString Password );
};

UClass* UTgDebug::pClassPointer = NULL;

// Class TgGame.TgDecalActor_Logo
// 0x0000 (0x01E8 - 0x01E8)
class ATgDecalActor_Logo : public ADecalActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1206 ];

		return pClassPointer;
	};

};

UClass* ATgDecalActor_Logo::pClassPointer = NULL;

// Class TgGame.TgDistributionFloatSoundAttenuation
// 0x003C (0x008C - 0x0050)
class UTgDistributionFloatSoundAttenuation : public UDistributionFloat
{
public:
	unsigned char                                      AttenuationType;                                  		// 0x0050 (0x0001) [0x0000000000000000]              
	float                                              Attenuation_Sm_foley;                             		// 0x0054 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Lg_foley;                             		// 0x0058 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Melee_hit;                            		// 0x005C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Sm_gun;                               		// 0x0060 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Med_gun;                              		// 0x0064 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Lg_gun;                               		// 0x0068 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Sm_exp;                               		// 0x006C (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Med_exp;                              		// 0x0070 (0x0004) [0x0000000000004000]              ( CPF_Config )
	float                                              Attenuation_Lg_exp;                               		// 0x0074 (0x0004) [0x0000000000004000]              ( CPF_Config )
	struct FName                                       GroupName;                                        		// 0x0078 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FAttenuationGroup >                 AttenuationGroups;                                		// 0x0080 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1207 ];

		return pClassPointer;
	};

};

UClass* UTgDistributionFloatSoundAttenuation::pClassPointer = NULL;

// Class TgGame.TgDoor
// 0x00C0 (0x02C4 - 0x0204)
class ATgDoor : public ADynamicSMActor
{
public:
	int                                                nPriority;                                        		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nPrevPriority;                                    		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              Position;                                         		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              Seconds;                                          		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FDoorPart                                   DoorParts[ 0x3 ];                                 		// 0x0214 (0x0090) [0x0000000000080001]              ( CPF_Edit | CPF_Component )
	class ANavigationPoint*                            NavPoint;                                         		// 0x02A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                c_nDoorParam;                                     		// 0x02A8 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bOpen : 1;                                      		// 0x02AC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bInitialized : 1;                               		// 0x02AC (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< class UMaterialInstanceConstant* >         DoorMICs;                                         		// 0x02B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class USoundCue*                                   StartSound;                                       		// 0x02BC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USoundCue*                                   EndSound;                                         		// 0x02C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1208 ];

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void eventUpdateState ( unsigned long bOpen );
	void OnToggle ( class USeqAct_Toggle* Action );
	void PostBeginPlay ( );
	void UpdateMICs ( );
	void BuildDoor ( );
};

UClass* ATgDoor::pClassPointer = NULL;

// Class TgGame.TgDrawSkydiveRadiusComponent
// 0x0000 (0x01DC - 0x01DC)
class UTgDrawSkydiveRadiusComponent : public UDrawSphereComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1209 ];

		return pClassPointer;
	};

};

UClass* UTgDrawSkydiveRadiusComponent::pClassPointer = NULL;

// Class TgGame.TgDynamicSMActor
// 0x002C (0x0230 - 0x0204)
class ATgDynamicSMActor : public ADynamicSMActor
{
public:
	struct FString                                     m_sAssembly;                                      		// 0x0204 (0x000C) [0x0000000000400021]              ( CPF_Edit | CPF_Net | CPF_NeedCtorLink )
	class ATgEffectManager*                            r_EffectManager;                                  		// 0x0210 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nHealth;                                        		// 0x0214 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	unsigned long                                      m_bDisplayHealth : 1;                             		// 0x0218 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bDestroyed : 1;                                 		// 0x0218 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bMeshLoaded : 1;                                		// 0x0218 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FName                                       m_nExplosion;                                     		// 0x021C (0x0008) [0x0000000000000000]              
	int                                                c_nMaxHealth;                                     		// 0x0224 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              m_DestroyedMesh;                                  		// 0x0228 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fLifeAfterDeathSecs;                            		// 0x022C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1210 ];

		return pClassPointer;
	};

	bool CanApplyEffects ( );
	void Detach ( class AActor* Other );
	void Attach ( class AActor* Other );
	void HideMesh ( );
	void DrawHealth ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	float GetSize ( );
	void ProcessEffect ( class UTgEffectGroup* Effect, unsigned long bRemove, class AActor* aInstigator, struct FImpactInfo Impact );
	void PlaySpecialFx ( struct FName nDisplayMode );
	void Destroyed ( );
	void DestroyIt ( unsigned long bSkipFx );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
	void eventTick ( float DeltaTime );
	void ForceNetRelevant ( );
	void SwapMeshToDestroyed ( );
	void LoadMesh ( );
};

UClass* ATgDynamicSMActor::pClassPointer = NULL;

// Class TgGame.TgDynamicDestructible
// 0x0008 (0x0238 - 0x0230)
class ATgDynamicDestructible : public ATgDynamicSMActor
{
public:
	int                                                r_nDestructibleId;                                		// 0x0230 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDestructibleFactory*                      r_pFactory;                                       		// 0x0234 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1211 ];

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void InitializeById ( int nDestructibleId );
};

UClass* ATgDynamicDestructible::pClassPointer = NULL;

// Class TgGame.TgEmitterSpawnable
// 0x0000 (0x01D4 - 0x01D4)
class ATgEmitterSpawnable : public AEmitter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1212 ];

		return pClassPointer;
	};

};

UClass* ATgEmitterSpawnable::pClassPointer = NULL;

// Class TgGame.TgFlagCaptureVolume
// 0x0006 (0x020E - 0x0208)
class ATgFlagCaptureVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                   		// 0x0208 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned char                                      r_nTaskForce;                                     		// 0x020C (0x0001) [0x0000000000020020]              ( CPF_Net | CPF_EditConst )
	unsigned char                                      r_eCoalition;                                     		// 0x020D (0x0001) [0x0000000000020020]              ( CPF_Net | CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1213 ];

		return pClassPointer;
	};

	struct FVector GetDisplayLocation ( );
	bool CanCapture ( class APawn* Pawn );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void PreBeginPlay ( );
	void setupFlagCapVolume ( );
};

UClass* ATgFlagCaptureVolume::pClassPointer = NULL;

// Class TgGame.TgFracturedStaticMeshActor
// 0x0044 (0x0274 - 0x0230)
class ATgFracturedStaticMeshActor : public AFracturedStaticMeshActor
{
public:
	class ATgEffectManager*                            r_EffectManager;                                  		// 0x0230 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_TakeHitNotifier;                                		// 0x0234 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vTakeHitLocation;                               		// 0x0238 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vTakeHitMomentum;                               		// 0x0244 (0x000C) [0x0000000000000020]              ( CPF_Net )
	class UClass*                                      r_HitDamageType;                                  		// 0x0250 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FTraceHitInfo                               r_HitInfo;                                        		// 0x0254 (0x001C) [0x0000000000080020]              ( CPF_Net | CPF_Component )
	float                                              r_DamageRadius;                                   		// 0x0270 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1214 ];

		return pClassPointer;
	};

	void ProcessEffect ( class UTgEffectGroup* Effect, unsigned long bRemove, class AActor* aInstigator, struct FImpactInfo Impact );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	bool CanApplyEffects ( );
	void Destroyed ( );
	void PostBeginPlay ( );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgFracturedStaticMeshActor::pClassPointer = NULL;

// Class TgGame.TgHeightFog
// 0x0004 (0x01D0 - 0x01CC)
class ATgHeightFog : public AInfo
{
public:
	class UHeightFogComponent*                         FogComponent;                                     		// 0x01CC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1215 ];

		return pClassPointer;
	};

};

UClass* ATgHeightFog::pClassPointer = NULL;

// Class TgGame.TgHexLandMarkActor
// 0x0008 (0x01D4 - 0x01CC)
class ATgHexLandMarkActor : public AActor
{
public:
	int                                                r_nMeshAsmId;                                     		// 0x01CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgStaticMeshComponent*                      c_Mesh;                                           		// 0x01D0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1216 ];

		return pClassPointer;
	};

	void HideMesh ( );
	void Destroyed ( );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
	void LoadMesh ( );
};

UClass* ATgHexLandMarkActor::pClassPointer = NULL;

// Class TgGame.TgHUD
// 0x0138 (0x059C - 0x0464)
class ATgHUD : public AHUD
{
public:
	class ATgPlayerController*                         m_PlayerOwner;                                    		// 0x0464 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_PawnOwner;                                      		// 0x0468 (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  m_HudTexture;                                     		// 0x046C (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  m_OverheadTexture;                                		// 0x0470 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UFont*                                       m_OverheadFont;                                   		// 0x0474 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UFont*                                       m_OverheadFont2;                                  		// 0x0478 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTgSpecialFxLightManager*                    m_FxLightManager;                                 		// 0x047C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bSettingsNeedRestart : 1;                       		// 0x0480 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bDisablePostRender : 1;                         		// 0x0480 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bDisableTick : 1;                               		// 0x0480 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bTrackedQuestComplete : 1;                      		// 0x0480 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bNeedAllQuestPOI : 1;                           		// 0x0480 (0x0004) [0x0000000000000000] [0x00000010] 
	struct FMultiMap_Mirror                            m_WorldUIVolumesByVVType;                         		// 0x0484 (0x003C) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	struct FMultiMap_Mirror                            m_WorldUIVolumesByAmVolumeId;                     		// 0x04C0 (0x003C) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	struct FMultiMap_Mirror                            m_WorldUIVolumesByQuestId;                        		// 0x04FC (0x003C) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	struct FMultiMap_Mirror                            m_WorldUIPOIByQuestId;                            		// 0x0538 (0x003C) [0x0000000000003002]              ( CPF_Const | CPF_Native | CPF_Transient )
	TArray< class ATgOmegaVolume* >                    m_WorldUISubZones;                                		// 0x0574 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FPointer                                    m_pAmTrackingQuest;                               		// 0x0580 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	TArray< class ATgPointOfInterest* >                m_AllQuestPOI;                                    		// 0x0584 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgPointOfInterest* >                m_ActiveQuestPOI;                                 		// 0x0590 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1217 ];

		return pClassPointer;
	};

	void eventCheckLevelUnlocks ( unsigned long bIsTutorial );
	class UUIScene* eventOpenIntroScene ( float FadeTime, float TotalTime );
	void eventClearTriggeredSceneInfo ( );
	void eventSetTriggeredSceneInfo ( class AActor* triggeredActor );
	void UpdateScoreBoard ( unsigned long bPlayerVictor, unsigned long bTie );
	void eventShowEndRaidScreen ( unsigned long bAttackerWon );
	void ShowEndTrainingMissionScreen ( struct FTG_TRAINING_END_INFO endInfo );
	void ShowQuestEndMissionScene ( unsigned long MissionVictor, unsigned long PlayerVictor, unsigned long bTie );
	void ShowEndMissionScreen ( unsigned long MissionVictor, unsigned long PlayerVictor, unsigned long bTie );
	void OpenScoreboard ( );
	void ToggleDrawAllHUD ( );
	void ToggleDrawPawnHUD ( );
	void ForceUpdateDeviceBar ( int nActiveDeviceId );
	void UpdateReleaseTime ( float fReleaseTime );
	void ShowReleaseDialog ( unsigned long bShow, struct FDeathZoomInfo Info, float fReleaseTime, unsigned long bCanManuallyRelease );
	bool eventTriggerCloseTgUIScene ( class UUIScene* Scene );
	class UObject* GetTgUISceneDriver ( class UUIScene* Scene );
	class UUIScene* TriggerOpenTgUIScene ( class UUIScene* Scene );
	bool eventIsMissionScene ( class UUIScene* Scene );
	void HideWorldInteractionText ( );
	void ShowWorldInteractionTextById ( int nMsgId );
	void ShowWorldInteractionText ( struct FString sMsg );
	void HideProgressBar ( unsigned long bWorldInteractionBar );
	void StartProgressBar ( float fDuration, struct FString sLabel, unsigned long bWorldInteractionBar );
	void UpdateSelectedDevice ( class ATgDevice* Dev );
	bool UsePickupDevice ( );
	void UpdateDeployPointCount ( );
	void OpenDeployPointMenu ( );
	void SetReticuleVisibility ( unsigned long bCrossHairVisible, unsigned long bWeaponStatusVisible );
	void HideTaskForce ( );
	void ShowTaskForce ( );
	bool ShouldDrawPawnHUD ( );
	void PlayHitEffect ( float Damage, struct FVector HitDir );
	void AddNewDisplayMessage ( struct FString sMessage );
	void AddNewKilledTarget ( struct FString KilledName, struct FString KillerName, unsigned long KillerWasPlayer );
	void eventCloseGUIItems ( );
	void eventOpenGUIItems ( );
	void SetZoomScope ( struct FName ScopeName );
	void CancelActiveCombat ( );
	void DisplayActiveCombat ( int nStateParam );
	void CancelInBombRange ( );
	void DisplayInBombRange ( );
	void CancelBeingDetected ( );
	void DisplayBeingDetected ( int nStateParam );
	void CancelBeingTargeted ( );
	void DisplayBeingTargeted ( );
	void CancelBeingLocked ( );
	void DisplayBeingLocked ( );
	void CancelBodyUnderAttack ( );
	void DisplayBodyUnderAttack ( int Damage );
	void DisplayHit ( struct FVector HitDir, int Damage, class UClass* DamageType );
	void SetMouseTargetDrawScale ( float NewScale );
	unsigned char GetCurrTargetMode ( );
	class AActor* GetMouseHoverActor ( );
	struct FVector GetMouseHitNormal ( );
	struct FVector GetMouseHoverLocation ( );
	void SetShowRangeTargeter ( unsigned long bInAimingMode );
	bool CheckShouldSkipEndMission ( );
	void UpdateRangedTargeterState ( unsigned char eNewState );
	void ResubmitPopups ( );
	bool HideObjectiveNames ( );
	bool HideObjectives ( );
	bool HideEnemyTags ( );
	bool ShowCombatText ( );
	bool ShowDeployableHealthBars ( );
	void UpdateUITextBox ( unsigned char TextBoxBitfield, float Duration, int messageID );
	void UpdateUITimer ( unsigned char ClockStateBitfield, float TimerDuration );
	void ResetDeviceHudTimersUI ( int DeviceEqpPoint );
	void UpdateDeviceBarUIItems ( );
	void UpdateInHandDevicesUI ( class ATgDevice* pDevice );
	void UpdateHiddenDevicesUI ( );
	void UpdateMouseTargetMode ( unsigned char NewMode );
	void UseCrosshairForReticule ( struct FName CrosshairName );
	void UpdateModeEquipTimer ( int nIsActive, float fEquipTime );
	void TriggerDeviceRefresh ( );
	void UpdateDeviceSlotTimers ( int nDeviceInstanceId, int nDeviceMode, float fSetup, float fRecharge, float fElaspedCooldown );
};

UClass* ATgHUD::pClassPointer = NULL;

// Class TgGame.TgInterpActor
// 0x0028 (0x0258 - 0x0230)
class ATgInterpActor : public AInterpActor
{
public:
	struct FString                                     m_sAssembly;                                      		// 0x0230 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FString                                     r_sCurrState;                                     		// 0x023C (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FVector                                     m_vMovement;                                      		// 0x0248 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSeconds;                                       		// 0x0254 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1218 ];

		return pClassPointer;
	};

	void PlaySpecialFx ( );
	void eventReplicatedEvent ( struct FName VarName );
	void OnTriggerInterpActor ( class UTgSeqAct_TriggerInterpActor* Action );
	void PostBeginPlay ( );
	void LoadMesh ( );
};

UClass* ATgInterpActor::pClassPointer = NULL;

// Class TgGame.TgKActorSpawnable
// 0x0000 (0x02B4 - 0x02B4)
class ATgKActorSpawnable : public AKActorSpawnable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1219 ];

		return pClassPointer;
	};

};

UClass* ATgKActorSpawnable::pClassPointer = NULL;

// Class TgGame.TgKAsset_ClientSideSim
// 0x0064 (0x0240 - 0x01DC)
class ATgKAsset_ClientSideSim : public AKAsset
{
public:
	float                                              m_fDamageImpulse;                                 		// 0x01DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UArrowComponent*                             m_Arrow;                                          		// 0x01E0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class USpriteComponent*                            m_ForceSprite;                                    		// 0x01E4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned long                                      m_bEnableWind : 1;                                		// 0x01E8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bEnableGusts : 1;                               		// 0x01E8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bAnimates : 1;                                    		// 0x01E8 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              m_fWindForceMin;                                  		// 0x01EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWindForceMax;                                  		// 0x01F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWindForceStrength;                             		// 0x01F4 (0x0004) [0x0000000000000000]              
	float                                              m_fWindForceTargetStrength;                       		// 0x01F8 (0x0004) [0x0000000000000000]              
	float                                              m_fWindFrequency;                                 		// 0x01FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWindForceRemainingTime;                        		// 0x0200 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vWindDirection;                                 		// 0x0204 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fForceDistance;                                 		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fForceZOffsetMultiplier;                        		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGustActiveTime;                                		// 0x0218 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vTimeBetweenGusts;                              		// 0x021C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGustActiveRemainingTime;                       		// 0x0224 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeTillNextGust;                              		// 0x0228 (0x0004) [0x0000000000000000]              
	class ATgWindManager*                              m_WindManager;                                    		// 0x022C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_WindFrequencyMultiplier;                        		// 0x0230 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_WindForceMultiplier;                            		// 0x0238 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1220 ];

		return pClassPointer;
	};

	void OnHit ( struct FVector HitLocation, struct FVector HitNormal, class AActor* SourceActor, struct FTraceHitInfo HitInfo );
};

UClass* ATgKAsset_ClientSideSim::pClassPointer = NULL;

// Class TgGame.TgKAssetSpawnable
// 0x0000 (0x01DC - 0x01DC)
class ATgKAssetSpawnable : public AKAssetSpawnable
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1221 ];

		return pClassPointer;
	};

};

UClass* ATgKAssetSpawnable::pClassPointer = NULL;

// Class TgGame.TgManifestGroup
// 0x002C (0x0068 - 0x003C)
class UTgManifestGroup : public UObject
{
public:
	TArray< struct FPointer >                          m_ItemLists;                                      		// 0x003C (0x000C) [0x0000000000101000]              ( CPF_Native )
	TArray< class UTgObjectReferencer* >               m_pObjectReferencers;                             		// 0x0048 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class UObject*                                     m_OwningObject;                                   		// 0x0054 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsInCallback : 1;                              		// 0x0058 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FScriptDelegate                             __OnAllManifestsLoaded__Delegate;                 		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1222 ];

		return pClassPointer;
	};

	void OnAllManifestsLoaded ( );
};

UClass* UTgManifestGroup::pClassPointer = NULL;

// Class TgGame.TgMeshAssembly
// 0x0014 (0x01E0 - 0x01CC)
class ATgMeshAssembly : public AActor
{
public:
	struct FString                                     m_sAssemblyName;                                  		// 0x01CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bMeshLoaded : 1;                                		// 0x01D8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	class UTgStaticMeshComponent*                      m_Mesh;                                           		// 0x01DC (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1223 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void ForceNetRelevant ( );
	void LoadMesh ( );
};

UClass* ATgMeshAssembly::pClassPointer = NULL;

// Class TgGame.TgNewsStand
// 0x0000 (0x01CC - 0x01CC)
class ATgNewsStand : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1224 ];

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventPostBeginPlay ( );
	void RegisterNewsChannel ( );
};

UClass* ATgNewsStand::pClassPointer = NULL;

// Class TgGame.TgObject
// 0x0000 (0x003C - 0x003C)
class UTgObject : public UObject
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1225 ];

		return pClassPointer;
	};

	struct FColor GetHealTargetColor ( );
	struct FColor GetTeamColor ( );
	struct FColor GetEnemyColor ( );
	struct FColor GetFriendlyColor ( );
	struct FColor GetPlayerColor ( );
	void eventStartFire ( );
	void eventSetTaskForceNumber ( );
	void eventInitializeDefaultProps ( );
	void eventSortDamageDisplay ( );
	void eventIsFriendlyWithLocalPawn ( );
};

UClass* UTgObject::pClassPointer = NULL;

// Class TgGame.TgObjectReferencer
// 0x0004 (0x004C - 0x0048)
class UTgObjectReferencer : public UObjectReferencer
{
public:
	struct FPointer                                    m_Manifest;                                       		// 0x0048 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1226 ];

		return pClassPointer;
	};

};

UClass* UTgObjectReferencer::pClassPointer = NULL;

// Class TgGame.TgPostProcessVolume
// 0x001C (0x02B0 - 0x0294)
class ATgPostProcessVolume : public APostProcessVolume
{
public:
	class UMaterialInterface*                          m_Material;                                       		// 0x0294 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_SceneDPG;                                       		// 0x0298 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UMaterialInstanceConstant*                   m_MaterialMIC;                                    		// 0x029C (0x0004) [0x0000000000000000]              
	float                                              m_FadeInTime;                                     		// 0x02A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FadeOutTime;                                    		// 0x02A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FadeScalarParameterName;                        		// 0x02A8 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1227 ];

		return pClassPointer;
	};

	void eventPostBeginPlay ( );
};

UClass* ATgPostProcessVolume::pClassPointer = NULL;

// Class TgGame.TgProperty
// 0x0014 (0x0050 - 0x003C)
class UTgProperty : public UObject
{
public:
	int                                                m_nPropertyId;                                    		// 0x003C (0x0004) [0x0000000000000000]              
	float                                              m_fBase;                                          		// 0x0040 (0x0004) [0x0000000000000000]              
	float                                              m_fRaw;                                           		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              m_fMinimum;                                       		// 0x0048 (0x0004) [0x0000000000000000]              
	float                                              m_fMaximum;                                       		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1228 ];

		return pClassPointer;
	};

	void eventCopy ( class UTgProperty* pProperty );
};

UClass* UTgProperty::pClassPointer = NULL;

// Class TgGame.TgRandomSMActor
// 0x0014 (0x020C - 0x01F8)
class ATgRandomSMActor : public AStaticMeshActor
{
public:
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                 		// 0x01F8 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )
	int                                                m_nType;                                          		// 0x01FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class AAmbientSound* >                     m_AmbientSounds;                                  		// 0x0200 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1229 ];

		return pClassPointer;
	};

	void HideMesh ( );
	void SetLightEnvironmentToNotBeDynamic ( );
	void PostBeginPlay ( );
	void TogglePaths ( unsigned long bOn );
	void ToggleDisplay ( unsigned long bOn );
};

UClass* ATgRandomSMActor::pClassPointer = NULL;

// Class TgGame.TgRandomSMManager
// 0x000C (0x01D8 - 0x01CC)
class ATgRandomSMManager : public AActor
{
public:
	TArray< struct FRandomSMActorInfo >                m_RandomSMActorInfo;                              		// 0x01CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1230 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void ManageRandomSMActors ( );
};

UClass* ATgRandomSMManager::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_AlarmBots
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_AlarmBots : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1231 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_AlarmBots::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_BotDied
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_BotDied : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1232 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_BotDied::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ClassSelected
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_ClassSelected : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1233 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_ClassSelected::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_DoorStatusChanged
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_DoorStatusChanged : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1234 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_DoorStatusChanged::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_FactoryEmpty
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_FactoryEmpty : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1235 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_FactoryEmpty::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_MICParameterEvent
// 0x0010 (0x011C - 0x010C)
class UTgSeqEvent_MICParameterEvent : public USequenceEvent
{
public:
	unsigned char                                      MICEventType;                                     		// 0x010C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UMaterialInstanceConstant* >         AttachedMICs;                                     		// 0x0110 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1236 ];

		return pClassPointer;
	};

	void SetVectorParameterValue ( struct FName ParamName, struct FLinearColor Value );
	void SetScalarParameterValue ( struct FName ParamName, float fValue );
};

UClass* UTgSeqEvent_MICParameterEvent::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ObjectiveBasedMIC
// 0x000C (0x0118 - 0x010C)
class UTgSeqEvent_ObjectiveBasedMIC : public USequenceEvent
{
public:
	TArray< class UMaterialInstanceConstant* >         AttachedMICs;                                     		// 0x010C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1237 ];

		return pClassPointer;
	};

	int eventGetObjClassVersion ( );
	void SetMICFromObjectiveMICInfo ( struct FObjectiveMICInfo oi );
};

UClass* UTgSeqEvent_ObjectiveBasedMIC::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_PlaceableDestroyed
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_PlaceableDestroyed : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1238 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_PlaceableDestroyed::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_PlayerCountHit
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_PlayerCountHit : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1239 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_PlayerCountHit::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_PlayerInitialized
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_PlayerInitialized : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1240 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_PlayerInitialized::pClassPointer = NULL;

// Class TgGame.TgSoundNodeAttenuation
// 0x0000 (0x00D8 - 0x00D8)
class UTgSoundNodeAttenuation : public USoundNodeAttenuation
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1241 ];

		return pClassPointer;
	};

};

UClass* UTgSoundNodeAttenuation::pClassPointer = NULL;

// Class TgGame.TgSpriteComponent
// 0x0010 (0x01E4 - 0x01D4)
class UTgSpriteComponent : public USpriteComponent
{
public:
	unsigned long                                      m_bUseCustomColor : 1;                            		// 0x01D4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FColor                                      m_Color;                                          		// 0x01D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSizeX;                                         		// 0x01DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSizeY;                                         		// 0x01E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1242 ];

		return pClassPointer;
	};

	void SetColor ( unsigned char R, unsigned char G, unsigned char B, unsigned char A );
};

UClass* UTgSpriteComponent::pClassPointer = NULL;

// Class TgGame.TgStaticMeshActor_Logo
// 0x0000 (0x01F8 - 0x01F8)
class ATgStaticMeshActor_Logo : public AStaticMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1243 ];

		return pClassPointer;
	};

};

UClass* ATgStaticMeshActor_Logo::pClassPointer = NULL;

// Class TgGame.TgTeamMarker
// 0x0008 (0x01D4 - 0x01CC)
class ATgTeamMarker : public AActor
{
public:
	class AEmitter*                                    m_Emitter;                                        		// 0x01CC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bOwnerOnly : 1;                                 		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1244 ];

		return pClassPointer;
	};

	void eventDestroyed ( );
	void eventPostBeginPlay ( );
};

UClass* ATgTeamMarker::pClassPointer = NULL;

// Class TgGame.TgTeleportPlayerVolume
// 0x000C (0x0214 - 0x0208)
class ATgTeleportPlayerVolume : public AVolume
{
public:
	unsigned char                                      TeleportLocation;                                 		// 0x0208 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	int                                                nMessageId;                                       		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bTeleportBots : 1;                                		// 0x0210 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bTeleportPlayers : 1;                             		// 0x0210 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1245 ];

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgTeleportPlayerVolume::pClassPointer = NULL;

// Class TgGame.TgTimerManager
// 0x02E8 (0x04B4 - 0x01CC)
class ATgTimerManager : public AActor
{
public:
	unsigned char                                      r_byEventQueIndex;                                		// 0x01CC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_byEventQue[ 0x20 ];                             		// 0x01CD (0x0020) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_byEventPriorQue[ 0x20 ];                        		// 0x01ED (0x0020) [0x0000000000000000]              
	unsigned char                                      m_byTimer[ 0x20 ];                                		// 0x020D (0x0020) [0x0000000000000000]              
	unsigned long                                      m_bRepeat : 1;                                    		// 0x0230 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bActive : 1;                                    		// 0x0230 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              r_fStartTime[ 0x20 ];                             		// 0x0234 (0x0080) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fRemaining[ 0x20 ];                             		// 0x02B4 (0x0080) [0x0000000000000020]              ( CPF_Net )
	struct FTGT_REG_LINK                               m_Registry[ 0x20 ];                               		// 0x0334 (0x0180) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1246 ];

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void CloseAllTimers ( unsigned long bFireEvent );
	bool IsActiveTimers ( );
	bool RepEvent ( struct FName VarName );
	bool UnRegisterForEvents ( unsigned char byTimerIndex, class UObject* HostObject );
	bool RegisterForEvents ( unsigned char byTimerIndex, class UObject* HostObject, struct FName nmFunc );
	float GetPercentRemaining ( unsigned char byTimerIndex );
	float GetTimeRemaining ( unsigned char byTimerIndex );
	float GetTimeElapsed ( unsigned char byTimerIndex );
	bool IsPaused ( unsigned char byTimerIndex );
	bool IsSet ( unsigned char byTimerIndex );
	bool Close ( unsigned char byTimerIndex, unsigned long bFireEvent );
	bool Pause ( unsigned char byTimerIndex, float fTime );
	bool Update ( unsigned char byTimerIndex, float fTime );
	bool Start ( unsigned char byTimerIndex, float fTime, unsigned long bRepeat );
};

UClass* ATgTimerManager::pClassPointer = NULL;

// Class TgGame.TgViewportClient
// 0x0000 (0x00FC - 0x00FC)
class UTgViewportClient : public UGameViewportClient
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1247 ];

		return pClassPointer;
	};

	void AddDeferredManifest ( class UTgObjectReferencer* ObjReferencer );
};

UClass* UTgViewportClient::pClassPointer = NULL;

// Class TgGame.TgVoiceMacroTree
// 0x0014 (0x0050 - 0x003C)
class UTgVoiceMacroTree : public UObject
{
public:
	unsigned long                                      m_bIsActive : 1;                                  		// 0x003C (0x0004) [0x0000000000000000] [0x00000001] 
	class UTgVoiceMacroTreeNode*                       m_RootNode;                                       		// 0x0040 (0x0004) [0x0000000000000000]              
	TArray< class UTgVoiceMacroTreeNode* >             m_NodePath;                                       		// 0x0044 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1248 ];

		return pClassPointer;
	};

};

UClass* UTgVoiceMacroTree::pClassPointer = NULL;

// Class TgGame.TgVoiceMacroTreeNode
// 0x001C (0x0058 - 0x003C)
class UTgVoiceMacroTreeNode : public UObject
{
public:
	struct FName                                       m_nmKey;                                          		// 0x003C (0x0008) [0x0000000000000000]              
	int                                                m_nMsgId;                                         		// 0x0044 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bActorTarget : 1;                               		// 0x0048 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bRequiresLead : 1;                              		// 0x0048 (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< class UTgVoiceMacroTreeNode* >             m_Children;                                       		// 0x004C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1249 ];

		return pClassPointer;
	};

};

UClass* UTgVoiceMacroTreeNode::pClassPointer = NULL;

// Class TgGame.TgVolumePathNode
// 0x0018 (0x02D8 - 0x02C0)
class ATgVolumePathNode : public AVolumePathNode
{
public:
	unsigned long                                      m_bIsAboveGround : 1;                             		// 0x02C0 (0x0004) [0x0000000000020001] [0x00000001] ( CPF_Edit | CPF_EditConst )
	struct FVector                                     m_vGroundHitLocation;                             		// 0x02C4 (0x000C) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              m_fGroundTraceDistance;                           		// 0x02D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTgSpriteComponent*                          m_GroundSprite;                                   		// 0x02D4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1250 ];

		return pClassPointer;
	};

};

UClass* ATgVolumePathNode::pClassPointer = NULL;

// Class TgGame.TgWeakSpotCylinderComponent
// 0x0010 (0x01E8 - 0x01D8)
class UTgWeakSpotCylinderComponent : public UCylinderComponent
{
public:
	struct FName                                       m_SocketName;                                     		// 0x01D8 (0x0008) [0x0000000000000000]              
	float                                              m_YawAxisOffset;                                  		// 0x01E0 (0x0004) [0x0000000000000000]              
	float                                              m_EffectiveAngle;                                 		// 0x01E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1251 ];

		return pClassPointer;
	};

};

UClass* UTgWeakSpotCylinderComponent::pClassPointer = NULL;

// Class TgGame.TgWindManager
// 0x006D (0x0239 - 0x01CC)
class ATgWindManager : public AActor
{
public:
	class UArrowComponent*                             m_Arrow;                                          		// 0x01CC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class USpriteComponent*                            m_ForceSprite;                                    		// 0x01D0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< struct FTgAffectedWindAssetInfo >          m_AffectedAssets;                                 		// 0x01D4 (0x000C) [0x0000000000420001]              ( CPF_Edit | CPF_EditConst | CPF_NeedCtorLink )
	unsigned long                                      m_bBuildAffectedAssetsList : 1;                   		// 0x01E0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bEnableWind : 1;                                		// 0x01E0 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	float                                              m_fWindForceTargetStrength;                       		// 0x01E4 (0x0004) [0x0000000000000000]              
	float                                              m_fWindFrequency;                                 		// 0x01E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fWindForceRemainingTime;                        		// 0x01EC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vWindDirection;                                 		// 0x01F0 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fForceDistance;                                 		// 0x01FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fForceZOffsetMultiplier;                        		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_bEnableGusts;                                   		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vTimeBetweenGusts;                              		// 0x0208 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGustActiveRemainingTime;                       		// 0x0210 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeTillNextGust;                              		// 0x0214 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_vWindSpeed;                                     		// 0x0218 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vGustActiveTime;                                		// 0x0220 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vWindForceStrength;                             		// 0x0228 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vWindFrequency;                                 		// 0x0230 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_WindType;                                       		// 0x0238 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1252 ];

		return pClassPointer;
	};

};

UClass* ATgWindManager::pClassPointer = NULL;

// Class TgGame.UTLevelCheckCommandlet
// 0x0000 (0x007C - 0x007C)
class UUTLevelCheckCommandlet : public UCommandlet
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1253 ];

		return pClassPointer;
	};

};

UClass* UUTLevelCheckCommandlet::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByPosture_Player
// 0x0000 (0x011E - 0x011E)
class UTgAnimBlendByPosture_Player : public UAnimNodeSequence
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1254 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByPosture_Player::pClassPointer = NULL;

// Class TgGame.TgAnimBlendBySpeed
// 0x008C (0x01B0 - 0x0124)
class UTgAnimBlendBySpeed : public UAnimNodeBlendBySpeed
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0124 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_SpeedType;                                      		// 0x0128 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FResetSynchGroup >                  ResetSynchGroups;                                 		// 0x012C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bIgnoreRootMotion : 1;                          		// 0x0138 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bIgnoreZVelocity : 1;                           		// 0x0138 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bNotifyOwnerOnChildChange : 1;                  		// 0x0138 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bEnableClassOverrides : 1;                      		// 0x0138 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	TArray< int >                                      m_WalkChildren;                                   		// 0x013C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< int >                                      m_SprintChildren;                                 		// 0x0148 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< float >                                    m_BaseSpeed;                                      		// 0x0154 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< unsigned char >                            m_IgnoredPhysics;                                 		// 0x0160 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_nIndexToOverride;                               		// 0x016C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRecon;                                		// 0x0170 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRobotics;                             		// 0x0174 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedAssault;                              		// 0x0178 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedMedic;                                		// 0x017C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedReconFemale;                          		// 0x0180 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRoboticsFemale;                       		// 0x0184 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedAssaultFemale;                        		// 0x0188 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedMedicFemale;                          		// 0x018C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedReconCity;                            		// 0x0190 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRoboticsCity;                         		// 0x0194 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedAssaultCity;                          		// 0x0198 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedMedicCity;                            		// 0x019C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedReconFemaleCity;                      		// 0x01A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedRoboticsFemaleCity;                   		// 0x01A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedAssaultFemaleCity;                    		// 0x01A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBaseSpeedMedicFemaleCity;                      		// 0x01AC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1255 ];

		return pClassPointer;
	};

	void eventOnInit ( );
	class UAnimNodeSynch* FindSynchAnimNode ( struct FName nmNodeName );
};

UClass* UTgAnimBlendBySpeed::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByStance
// 0x0000 (0x0100 - 0x0100)
class UTgAnimBlendByStance : public UAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1256 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByStance::pClassPointer = NULL;

// Class TgGame.TgAnimBlendPerBone
// 0x001C (0x0138 - 0x011C)
class UTgAnimBlendPerBone : public UAnimNodeBlendPerBone
{
public:
	unsigned long                                      m_bLoopSourceChild : 1;                           		// 0x011C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bLoopTargetChild : 1;                           		// 0x011C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bPlaySourceChild : 1;                           		// 0x011C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bPlayTargetChild : 1;                           		// 0x011C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bSetStrengthFromAnimNode : 1;                   		// 0x011C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bInitializedCachedNodeList : 1;                 		// 0x011C (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	TArray< struct FName >                             m_StrengthAnimNodeNameList;                       		// 0x0120 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_CachedNodeList;                                 		// 0x012C (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1257 ];

		return pClassPointer;
	};

	void PlayAnim ( unsigned long bLoop, float Rate, float StartTime );
};

UClass* UTgAnimBlendPerBone::pClassPointer = NULL;

// Class TgGame.TgAnimNodeAimOffset
// 0x0068 (0x0194 - 0x012C)
class UTgAnimNodeAimOffset : public UAnimNodeAimOffset
{
public:
	class ATgPawn*                                     Owner;                                            		// 0x012C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	unsigned long                                      m_bForceAimWhileNotStrafing : 1;                  		// 0x0130 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bDisableVerticalAimFromAnimNode : 1;            		// 0x0130 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bInitializedCachedNodeList : 1;                 		// 0x0130 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bDisableVerticalAiming : 1;                     		// 0x0130 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      bOnlyUpdateIn360Aiming : 1;                       		// 0x0130 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bMirrorOffsetWhenPawnMirrored : 1;              		// 0x0130 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      bInterpolating : 1;                               		// 0x0130 (0x0004) [0x0000000000002002] [0x00000040] ( CPF_Const | CPF_Transient )
	unsigned long                                      m_bBakeAllProfileOffsetsFromAnimations : 1;       		// 0x0130 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_bPopulateAnimNamesWithPrefixes : 1;             		// 0x0130 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_bRandomAimPointsEnabled : 1;                    		// 0x0130 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_bOverrideAim : 1;                               		// 0x0130 (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	unsigned long                                      m_bAimAtTarget : 1;                               		// 0x0130 (0x0004) [0x0000000000000001] [0x00000800] ( CPF_Edit )
	TArray< struct FName >                             m_bDisableVerticalAimAnimNodeNameList;            		// 0x0134 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_CachedNodeList;                                 		// 0x0140 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              TurnInPlaceOffset;                                		// 0x014C (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	float                                              LastAimX;                                         		// 0x0150 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              InterpSpeed;                                      		// 0x0154 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_AimOffsetPct;                                   		// 0x0158 (0x0008) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	struct FVector2D                                   m_RandomAimPointsRangeX;                          		// 0x0160 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_RandomAimPointsRangeY;                          		// 0x0168 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRandomAimPointsInterpRate;                     		// 0x0170 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRandomAimPointsIntervalMin;                    		// 0x0174 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRandomAimPointsIntervalMax;                    		// 0x0178 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fCurrentRandomAimPointsInterval;                		// 0x017C (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_TargetRandomAimLocation;                        		// 0x0180 (0x0008) [0x0000000000000000]              
	float                                              m_fDeltaTime;                                     		// 0x0188 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_OverriddenAim;                                  		// 0x018C (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1258 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeAimOffset::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendAnimsByDirection
// 0x0010 (0x013C - 0x012C)
class UTgAnimNodeBlendAnimsByDirection : public UAnimNodeSequenceBlendBase
{
public:
	float                                              m_BlendSpeed;                                     		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_DirAngle;                                       		// 0x0130 (0x0004) [0x0000000000000000]              
	float                                              m_LastRelevantTime;                               		// 0x0134 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bInterpolateWeights : 1;                        		// 0x0138 (0x0004) [0x0000000000002002] [0x00000001] ( CPF_Const | CPF_Transient )
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;          		// 0x0138 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bForwardLeftCorrection : 1;                     		// 0x0138 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1259 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendAnimsByDirection::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByBlink
// 0x0034 (0x0150 - 0x011C)
class UTgAnimNodeBlendByBlink : public UAnimNodeBlendPerBone
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class USkeletalMeshComponent*                      m_SkelMesh;                                       		// 0x0120 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	float                                              m_fBlinkAnimRate;                                 		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_vTimeBetweenBlinks;                             		// 0x0128 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTimeTillNextBlink;                             		// 0x0130 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_DisableBlinkingAnimNodeNameList;                		// 0x0134 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_CachedNodeList;                                 		// 0x0140 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      m_bInitializedCachedNodeList : 1;                 		// 0x014C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1260 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByBlink::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByDeviceMode
// 0x0017 (0x00F8 - 0x00E1)
class UTgAnimNodeBlendByDeviceMode : public UAnimNodeBlendBase
{
public:
	int                                                PreviousModeIndex;                                		// 0x00E4 (0x0004) [0x0000000000000000]              
	int                                                CurrentModeIndex;                                 		// 0x00E8 (0x0004) [0x0000000000000000]              
	TArray< struct FTransitionAnimInfo >               TransitionInfo;                                   		// 0x00EC (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1261 ];

		return pClassPointer;
	};

	void PlayCollapseAnimation ( );
	void ChangeMode ( int NewModeIndex );
	void PlayDeployAnimation ( );
};

UClass* UTgAnimNodeBlendByDeviceMode::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByOffhand
// 0x0010 (0x0104 - 0x00F4)
class UTgAnimNodeBlendByOffhand : public UAnimNodeBlend
{
public:
	TArray< struct FOffhandAnimation >                 OffhandAnimations;                                		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_fBlendTime;                                     		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1262 ];

		return pClassPointer;
	};

	void PlayOffhandAnimation ( struct FName m_nOffhandUseType );
};

UClass* UTgAnimNodeBlendByOffhand::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByStrafe
// 0x0008 (0x00FC - 0x00F4)
class UTgAnimNodeBlendByStrafe : public UAnimNodeBlend
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x00F4 (0x0004) [0x0000000000000000]              
	float                                              m_fBlendTime;                                     		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1263 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByStrafe::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList
// 0x002C (0x012C - 0x0100)
class UTgAnimNodeBlendList : public UAnimNodeBlendList
{
public:
	float                                              m_fSliderPosition;                                		// 0x0100 (0x0004) [0x0000000000000002]              ( CPF_Const )
	TArray< float >                                    m_ChildBlendInTime;                               		// 0x0104 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_fBlendTime;                                     		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< float >                                    m_ActiveChildTimer;                               		// 0x0114 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_iNextActiveChildIndex;                          		// 0x0120 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	float                                              m_fNextActiveChildBlendTime;                      		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fActiveChildRemainingTime;                      		// 0x0128 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1264 ];

		return pClassPointer;
	};

	void SetTimedActiveChild ( int ChildIndex, float BlendTime, float Duration );
	void SetNextActiveChildIndex ( int NewActiveChild );
	void SetActiveChild ( int ChildIndex, float BlendTime );
};

UClass* UTgAnimNodeBlendList::pClassPointer = NULL;

// Class TgGame.TgAnimBlendBase
// 0x0010 (0x013C - 0x012C)
class UTgAnimBlendBase : public UTgAnimNodeBlendList
{
public:
	float                                              BlendTime;                                        		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< float >                                    ChildBlendTimes;                                  		// 0x0130 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1265 ];

		return pClassPointer;
	};

	float GetBlendTime ( int ChildIndex, unsigned long bGetDefault );
};

UClass* UTgAnimBlendBase::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByDirection
// 0x000C (0x0148 - 0x013C)
class UTgAnimBlendByDirection : public UTgAnimBlendBase
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x013C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_SpeedType;                                      		// 0x0140 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      LastDirection;                                    		// 0x0141 (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned long                                      bAdjustRateByVelocity : 1;                        		// 0x0144 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bNoDirectionIsEnabled : 1;                        		// 0x0144 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bResetLooping : 1;                                		// 0x0144 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                   		// 0x0144 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                       		// 0x0144 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bMirrorDirectionsWhenPawnMirrored : 1;          		// 0x0144 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1266 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByDirection::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFall
// 0x00E8 (0x0224 - 0x013C)
class UTgAnimBlendByFall : public UTgAnimBlendBase
{
public:
	unsigned char                                      m_FallStyle;                                      		// 0x013C (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      FallState;                                        		// 0x013D (0x0001) [0x0000000000000002]              ( CPF_Const )
	unsigned char                                      m_PreviousTickPhysics;                            		// 0x013E (0x0001) [0x0000000000000000]              
	struct FName                                       GrappleUpAnimName;                                		// 0x0140 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       GrappleUpLoopAnimName;                            		// 0x0148 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       GrappleDownAnimName;                              		// 0x0150 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       GrapplePreLandAnimName;                           		// 0x0158 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       GrappleLandAnimName;                              		// 0x0160 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fGrappleBlendTime;                              		// 0x0168 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bForceDismountToFinishBeforeBlendOut : 1;       		// 0x016C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bDismountAnimDone : 1;                          		// 0x016C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bChangeUpAnimsBasedOnFootPlacement : 1;         		// 0x016C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bDebugMeasureJumpUp : 1;                        		// 0x016C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bDebugMeasureJumpDownToLand : 1;                		// 0x016C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bMeasuring : 1;                                 		// 0x016C (0x0004) [0x0000000000000000] [0x00000020] 
	struct FName                                       HangingUpAnimName;                                		// 0x0170 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       WallJumpAnimName;                                 		// 0x0178 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       WallJumpLoopAnimName;                             		// 0x0180 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultUpAnimName;                                		// 0x0188 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultUpLoopAnimName;                            		// 0x0190 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultDownAnimName;                              		// 0x0198 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultPreLandAnimName;                           		// 0x01A0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultLandAnimName;                              		// 0x01A8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultUpFromLeftFootAnimName;                    		// 0x01B0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultUpLoopFromLeftFootAnimName;                		// 0x01B8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultDownFromLeftFootAnimName;                  		// 0x01C0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultPreLandFromLeftFootAnimName;               		// 0x01C8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultUpFromRightFootAnimName;                   		// 0x01D0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultUpLoopFromRightFootAnimName;               		// 0x01D8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultDownFromRightFootAnimName;                 		// 0x01E0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       DefaultPreLandFromRightFootAnimName;              		// 0x01E8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_LeftFootName;                                   		// 0x01F0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_RightFootName;                                  		// 0x01F8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_LeftFootBoneIndex;                              		// 0x0200 (0x0004) [0x0000000000000000]              
	int                                                m_RightFootBoneIndex;                             		// 0x0204 (0x0004) [0x0000000000000000]              
	float                                              LastFallingVelocity;                              		// 0x0208 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class ATgPawn*                                     pOwner;                                           		// 0x020C (0x0004) [0x0000000000000000]              
	float                                              m_fPrelandDistance;                               		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_StartMeasureJump;                               		// 0x0214 (0x000C) [0x0000000000000000]              
	float                                              m_fMeasureTime;                                   		// 0x0220 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1267 ];

		return pClassPointer;
	};

	float GetBlendTime ( int ChildIndex, unsigned long bGetDefault );
};

UClass* UTgAnimBlendByFall::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByFlying
// 0x002C (0x0168 - 0x013C)
class UTgAnimBlendByFlying : public UTgAnimBlendBase
{
public:
	unsigned long                                      bAdjustRateByVelocity : 1;                        		// 0x013C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bAdjustRateByAcceleration : 1;                  		// 0x013C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bPreviewJetpackPerBoneBlend : 1;                		// 0x013C (0x0004) [0x0000000000002001] [0x00000004] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_bIsUsingHandsFreeJetpack : 1;                   		// 0x013C (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              m_fUpLoopStartTime;                               		// 0x0140 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      LastDirection;                                    		// 0x0144 (0x0001) [0x0000000000000002]              ( CPF_Const )
	struct FName                                       m_nmHandsFreeJetpackPerBoneBlendNodeName;         		// 0x0148 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeBlendPerBone*                       m_HandsFreeJetpackPerBoneBlendNode;               		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              m_fHandsFreeJetpackBlendBias;                     		// 0x0154 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmHandsFreeJetpackBiasBlendNodeName;            		// 0x0158 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeBlend*                              m_HandsFreeJetpackBiasBlendNode;                  		// 0x0160 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0164 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1268 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByFlying::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByGrapple
// 0x0005 (0x0141 - 0x013C)
class UTgAnimBlendByGrapple : public UTgAnimBlendBase
{
public:
	unsigned long                                      bAdjustRateByVelocity : 1;                        		// 0x013C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned char                                      LastAction;                                       		// 0x0140 (0x0001) [0x0000000000000002]              ( CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1269 ];

		return pClassPointer;
	};

	void eventOnBecomeRelevant ( );
};

UClass* UTgAnimBlendByGrapple::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByPhysics
// 0x003C (0x0178 - 0x013C)
class UTgAnimBlendByPhysics : public UTgAnimBlendBase
{
public:
	int                                                PhysicsMap[ 0xE ];                                		// 0x013C (0x0038) [0x0000000000000001]              ( CPF_Edit )
	int                                                LastPhysics;                                      		// 0x0174 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1270 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByPhysics::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByHanging
// 0x0005 (0x0141 - 0x013C)
class UTgAnimNodeBlendByHanging : public UTgAnimBlendBase
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x013C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_CurrentHangSurfaceType;                         		// 0x0140 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1271 ];

		return pClassPointer;
	};

	float PlayBuildupDismountAnim ( );
	void SetHangSurfaceType ( unsigned char NewSurfaceType );
};

UClass* UTgAnimNodeBlendByHanging::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByHealth
// 0x0010 (0x014C - 0x013C)
class UTgAnimNodeBlendByHealth : public UTgAnimBlendBase
{
public:
	TArray< float >                                    m_HealthChildren;                                 		// 0x013C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0148 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1272 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByHealth::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByKnockdown
// 0x0030 (0x016C - 0x013C)
class UTgAnimNodeBlendByKnockdown : public UTgAnimBlendBase
{
public:
	unsigned long                                      m_bAdjustPlayRateByVelocity : 1;                  		// 0x013C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_fVelocityMultiplier;                            		// 0x0140 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_PreviewVelocity;                                		// 0x0144 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0148 (0x0004) [0x0000000000000000]              
	struct FName                                       m_FaceDownAnimName;                               		// 0x014C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FaceUpAnimName;                                 		// 0x0154 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FaceDownRecoverAnimName;                        		// 0x015C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FaceUpRecoverAnimName;                          		// 0x0164 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1273 ];

		return pClassPointer;
	};

	void SetDownStateAnim ( unsigned long bFaceDown );
};

UClass* UTgAnimNodeBlendByKnockdown::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendBySkydiving
// 0x0020 (0x015C - 0x013C)
class UTgAnimNodeBlendBySkydiving : public UTgAnimBlendBase
{
public:
	unsigned char                                      CurrentAction;                                    		// 0x013C (0x0001) [0x0000000000000002]              ( CPF_Const )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0140 (0x0004) [0x0000000000000000]              
	float                                              m_fLedgeDetectForwardExtent;                      		// 0x0144 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fLedgeDetectDownwardExtent;                     		// 0x0148 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPreLandDetectExtent;                           		// 0x014C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bDebugLedgeDetection : 1;                       		// 0x0150 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	float                                              m_fTimeForBlendToDown;                            		// 0x0154 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPctToBlendToDown;                              		// 0x0158 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1274 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendBySkydiving::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByAimMode
// 0x0004 (0x0130 - 0x012C)
class UTgAnimBlendByAimMode : public UTgAnimNodeBlendList
{
public:
	float                                              c_BlendTime;                                      		// 0x012C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1275 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByAimMode::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByDeviceType
// 0x0044 (0x0170 - 0x012C)
class UTgAnimBlendByDeviceType : public UTgAnimNodeBlendList
{
public:
	float                                              c_fBlendTime;                                     		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bUseLowerBodyFilter : 1;                        		// 0x0130 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FName                                       m_nmUpperbodyStartBoneName;                       		// 0x0134 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fFilterAtVelocity;                              		// 0x013C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nFilterChild;                                   		// 0x0140 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPrevisVelocity;                                		// 0x0144 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FilterBlendTime;                                		// 0x0148 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_FilterBlendTimeToGo;                            		// 0x014C (0x0004) [0x0000000000000000]              
	float                                              m_FilterBlendWeightTarget;                        		// 0x0150 (0x0004) [0x0000000000000000]              
	TArray< float >                                    m_FilterPerBoneWeight;                            		// 0x0154 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< unsigned char >                            m_LocalToCompReqBones;                            		// 0x0160 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x016C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1276 ];

		return pClassPointer;
	};

	void SetActiveChild ( int ChildIndex, float BlendTime );
};

UClass* UTgAnimBlendByDeviceType::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByDeployableUseType
// 0x0000 (0x0170 - 0x0170)
class UTgAnimBlendByDeployableUseType : public UTgAnimBlendByDeviceType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1277 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByDeployableUseType::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByMeleeUseType
// 0x0000 (0x0170 - 0x0170)
class UTgAnimBlendByMeleeUseType : public UTgAnimBlendByDeviceType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1278 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByMeleeUseType::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByOffhandUseType
// 0x0000 (0x0170 - 0x0170)
class UTgAnimBlendByOffhandUseType : public UTgAnimBlendByDeviceType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1279 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByOffhandUseType::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByRangeUseType
// 0x005C (0x01CC - 0x0170)
class UTgAnimBlendByRangeUseType : public UTgAnimBlendByDeviceType
{
public:
	unsigned long                                      m_bCanPlayRetrieveAnim : 1;                       		// 0x0170 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bPendingFire : 1;                               		// 0x0170 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bIsAnimPlayingFireAnim : 1;                     		// 0x0170 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bNewRange : 1;                                  		// 0x0170 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bContinuousFire : 1;                            		// 0x0170 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bScaleFireAnimsWithRefire : 1;                  		// 0x0170 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bInterruptAnimOnRefire : 1;                     		// 0x0170 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bFireNode2Active : 1;                           		// 0x0170 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      c_bHasActuallyFiredLastPendingFire : 1;           		// 0x0170 (0x0004) [0x0000000000000000] [0x00000100] 
	float                                              m_RefireTime;                                     		// 0x0174 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_FireNode;                                       		// 0x0178 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_FireNode2;                                      		// 0x017C (0x0004) [0x0000000000000000]              
	float                                              m_fRefireTime;                                    		// 0x0180 (0x0004) [0x0000000000000000]              
	float                                              m_fRefireTimeRemaining;                           		// 0x0184 (0x0004) [0x0000000000000000]              
	int                                                m_nNumContinuousShots;                            		// 0x0188 (0x0004) [0x0000000000000000]              
	struct FName                                       m_FireAnimName;                                   		// 0x018C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FireContinuousAnimName;                         		// 0x0194 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FireMovingAnimName;                             		// 0x019C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FireContinuousMovingAnimName;                   		// 0x01A4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FireCrouchAnimName;                             		// 0x01AC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FireCrouchContinuousAnimName;                   		// 0x01B4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FireCrouchMovingAnimName;                       		// 0x01BC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FireCrouchContinuousMovingAnimName;             		// 0x01C4 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1280 ];

		return pClassPointer;
	};

	void PlayPutAwayAnim ( float putAwayTime );
	void PlayFireAnim ( );
	void PlayEquipAnim ( float EquipTime );
	void PlayBuildupAnim ( float BuildupTime );
	void PlayActiveAnim ( );
};

UClass* UTgAnimBlendByRangeUseType::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByMelee
// 0x024C (0x0378 - 0x012C)
class UTgAnimBlendByMelee : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bIsAnimPlayingFireAnim : 1;                     		// 0x012C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bAttackAnimAlreadyEndedThisTick : 1;            		// 0x012C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bPendingFire : 1;                               		// 0x012C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bEnableTrailEffects : 1;                        		// 0x012C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bCanPlayRetrieveAnim : 1;                       		// 0x012C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	float                                              m_fPostAttackPoseHoldTime;                        		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPostAttackPoseHoldRemainingTime;               		// 0x0134 (0x0004) [0x0000000000000000]              
	float                                              m_fBlendTimeToChainedAttacks;                     		// 0x0138 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPostAttackPoseHoldBlendOutTime;                		// 0x013C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPostAttackPoseHoldBlendInTime;                 		// 0x0140 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fLowerBodyAttackRunBlendTime;                   		// 0x0144 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fLowerBodyAttackRunStartPct;                    		// 0x0148 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fLowerBodyAttackRunEndPct;                      		// 0x014C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmCurrentSwooshDisplayGroup;                    		// 0x0150 (0x0008) [0x0000000000000000]              
	int                                                m_nFireMode;                                      		// 0x0158 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendByMeleeWeaponAnim*           m_RightHandWeaponAnimNode;                        		// 0x015C (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendByMeleeWeaponAnim*           m_LeftHandWeaponAnimNode;                         		// 0x0160 (0x0004) [0x0000000000000000]              
	TArray< struct FAnimationGroup >                   m_AttackMovingFromRight;                          		// 0x0164 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackMovingFromLeft;                           		// 0x0170 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackIdleFromRight;                            		// 0x017C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackIdleFromLeft;                             		// 0x0188 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackJumpFromLeft;                             		// 0x0194 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackJumpFromRight;                            		// 0x01A0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackCrouchIdleFromRight;                      		// 0x01AC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackCrouchIdleFromLeft;                       		// 0x01B8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackCrouchMovingFromRight;                    		// 0x01C4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackCrouchMovingFromLeft;                     		// 0x01D0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabIdleFromRight;                    		// 0x01DC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabIdleFromLeft;                     		// 0x01E8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabMovingFromRight;                  		// 0x01F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabMovingFromLeft;                   		// 0x0200 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabCrouchIdleFromRight;              		// 0x020C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabCrouchIdleFromLeft;               		// 0x0218 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabCrouchMovingFromRight;            		// 0x0224 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabCrouchMovingFromLeft;             		// 0x0230 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabJumpFromRight;                    		// 0x023C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBackstabJumpFromLeft;                     		// 0x0248 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakIdleFromRight;                  		// 0x0254 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakIdleFromLeft;                   		// 0x0260 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakMovingFromRight;                		// 0x026C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakMovingFromLeft;                 		// 0x0278 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakCrouchIdleFromRight;            		// 0x0284 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakCrouchIdleFromLeft;             		// 0x0290 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakCrouchMovingFromRight;          		// 0x029C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakCrouchMovingFromLeft;           		// 0x02A8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakJumpFromRight;                  		// 0x02B4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackBlockBreakJumpFromLeft;                   		// 0x02C0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireMovingFromRight;             		// 0x02CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireMovingFromLeft;              		// 0x02D8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireIdleFromRight;               		// 0x02E4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireIdleFromLeft;                		// 0x02F0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireJumpFromLeft;                		// 0x02FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireJumpFromRight;               		// 0x0308 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireCrouchIdleFromRight;         		// 0x0314 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireCrouchIdleFromLeft;          		// 0x0320 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireCrouchMovingFromRight;       		// 0x032C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackSecondaryFireCrouchMovingFromLeft;        		// 0x0338 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackFlyingFromRight;                          		// 0x0344 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FAnimationGroup >                   m_AttackFlyingFromLeft;                           		// 0x0350 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_CurrentSituationalAttackType;                   		// 0x035C (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0360 (0x0004) [0x0000000000000000]              
	float                                              m_RefireTime;                                     		// 0x0364 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_NextFireDirection;                              		// 0x0368 (0x0001) [0x0000000000000000]              
	TArray< struct FTgMeleeOverrideInfo >              m_MeleeOverrides;                                 		// 0x036C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1281 ];

		return pClassPointer;
	};

	void StopSwooshDisplayGroupFx ( );
	void PlayPutAwayAnim ( float putAwayTime );
	void PlayEquipAnim ( float EquipTime );
	void PlayActiveAnim ( );
	void PlayAttackAnim ( );
};

UClass* UTgAnimBlendByMelee::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByObjectiveStatus
// 0x0014 (0x0140 - 0x012C)
class UTgAnimBlendByObjectiveStatus : public UTgAnimNodeBlendList
{
public:
	class ATgObjectiveAttachActor*                     m_ObjectiveActor;                                 		// 0x012C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_LastStatus;                                     		// 0x0130 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_CurrentStatus;                                  		// 0x0131 (0x0001) [0x0000000000000000]              
	TArray< struct Fm_StatusProfile >                  m_StatusProfiles;                                 		// 0x0134 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1282 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByObjectiveStatus::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByPhase
// 0x001C (0x0148 - 0x012C)
class UTgAnimBlendByPhase : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x012C (0x0004) [0x0000000000000000]              
	int                                                m_LastPhase;                                      		// 0x0130 (0x0004) [0x0000000000000000]              
	int                                                m_CurrentPhase;                                   		// 0x0134 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bEnableTransitionAnims : 1;                     		// 0x0138 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	TArray< struct Fm_PhaseProfile >                   m_PhaseProfiles;                                  		// 0x013C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1283 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByPhase::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByPosture
// 0x001C (0x0148 - 0x012C)
class UTgAnimBlendByPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x012C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_LastPosture;                                    		// 0x0130 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_CurrentPosture;                                 		// 0x0131 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_TransitionFromPosture;                          		// 0x0132 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bEnableTransitionAnims : 1;                     		// 0x0134 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	int                                                m_CurrentPostureChildIndex;                       		// 0x0138 (0x0004) [0x0000000000000000]              
	TArray< struct Fm_PostureProfile >                 m_PostureProfiles;                                		// 0x013C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1284 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByPosture::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByStartingPosture
// 0x000C (0x0138 - 0x012C)
class UTgAnimBlendByStartingPosture : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x012C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_StartingPosture;                                		// 0x0130 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bExpired : 1;                                   		// 0x0134 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1285 ];

		return pClassPointer;
	};

};

UClass* UTgAnimBlendByStartingPosture::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByBlockDirection
// 0x000C (0x0138 - 0x012C)
class UTgAnimNodeBlendByBlockDirection : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x012C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bPlayedTurnLastTick : 1;                        		// 0x0130 (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                YawOffset;                                        		// 0x0134 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1286 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByBlockDirection::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByBlocking
// 0x0004 (0x0130 - 0x012C)
class UTgAnimNodeBlendByBlocking : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x012C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1287 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByBlocking::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByCrouch
// 0x000C (0x0138 - 0x012C)
class UTgAnimNodeBlendByCrouch : public UTgAnimNodeBlendList
{
public:
	float                                              m_fBlendToCrouch;                                 		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBlendToStand;                                  		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0134 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1288 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByCrouch::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByDeployPreview
// 0x0000 (0x012C - 0x012C)
class UTgAnimNodeBlendByDeployPreview : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1289 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByDeployPreview::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByDeployStatus
// 0x000C (0x0138 - 0x012C)
class UTgAnimNodeBlendByDeployStatus : public UTgAnimNodeBlendList
{
public:
	class UTgSkeletalMeshComponent*                    m_TgSMC;                                          		// 0x012C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_PreviewAnimPosition;                            		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bPlayAnimationOnlyWhenFullyDeployed : 1;        		// 0x0134 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1290 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByDeployStatus::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByHackingRobot
// 0x0010 (0x013C - 0x012C)
class UTgAnimNodeBlendByHackingRobot : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x012C (0x0004) [0x0000000000000000]              
	int                                                m_SpecialFxHackingID;                             		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTgSpecialFx*                                m_SpecialFxHacking;                               		// 0x0134 (0x0004) [0x0000000000000000]              
	class ATgEmitter*                                  m_HackingEmitter;                                 		// 0x0138 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1291 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByHackingRobot::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByLanding
// 0x0024 (0x0150 - 0x012C)
class UTgAnimNodeBlendByLanding : public UTgAnimNodeBlendList
{
public:
	struct FName                                       m_SoftLandAnimName;                               		// 0x012C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_HardLandAnimName;                               		// 0x0134 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_SkydiveLandAnimName;                            		// 0x013C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSoftLandVelocityThreshold;                     		// 0x0144 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bLandAnimInterruptible : 1;                     		// 0x0148 (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgPawn*                                     m_TgPawn;                                         		// 0x014C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1292 ];

		return pClassPointer;
	};

	void SetLandAnim ( struct FName AnimName );
	void PlaySkydiveLanding ( );
	void PlayHardLanding ( );
	void PlaySoftLanding ( );
};

UClass* UTgAnimNodeBlendByLanding::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByLandingRun
// 0x0024 (0x0150 - 0x012C)
class UTgAnimNodeBlendByLandingRun : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x012C (0x0004) [0x0000000000000000]              
	TArray< struct FImpactTimeScale >                  m_ImpactTimeScale;                                		// 0x0130 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_fRemainingTime;                                 		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              m_fFullyBlendedTime;                              		// 0x0140 (0x0004) [0x0000000000000000]              
	float                                              m_fBlendInTime;                                   		// 0x0144 (0x0004) [0x0000000000000000]              
	float                                              m_fBlendOutTime;                                  		// 0x0148 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bEnabled : 1;                                   		// 0x014C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1293 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByLandingRun::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByMeleeWeaponAnim
// 0x0024 (0x0150 - 0x012C)
class UTgAnimNodeBlendByMeleeWeaponAnim : public UTgAnimNodeBlendList
{
public:
	unsigned char                                      m_WeaponType;                                     		// 0x012C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeSequence*                           m_AttackAnimNodeSequence;                         		// 0x0130 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bReceiveAttackAnimsFromOwner : 1;               		// 0x0134 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UAnimNodeSequence*                           m_RetractAnimNodeSequence;                        		// 0x0138 (0x0004) [0x0000000000000000]              
	float                                              m_RetractRate;                                    		// 0x013C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeBlend*                              m_IdleBlendNode;                                  		// 0x0140 (0x0004) [0x0000000000000000]              
	float                                              m_IdleBlendTime;                                  		// 0x0144 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPostAttackHoldTime;                            		// 0x0148 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRemainingPostAttackHoldTime;                   		// 0x014C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1294 ];

		return pClassPointer;
	};

	void PlayAttackAnim ( );
	void SetAttackAnimNormalizedPosition ( float NewPosition );
	void SetAttackAnim ( struct FName AnimName );
	void PlayIdleAnim ( );
};

UClass* UTgAnimNodeBlendByMeleeWeaponAnim::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByPhysics
// 0x0028 (0x0154 - 0x012C)
class UTgAnimNodeBlendByPhysics : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x012C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_LastPhysics;                                    		// 0x0130 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_CurrentPhysics;                                 		// 0x0131 (0x0001) [0x0000000000000000]              
	int                                                m_CurrentPhysicsChildIndex;                       		// 0x0134 (0x0004) [0x0000000000000000]              
	TArray< unsigned char >                            m_PhysicsChildren;                                		// 0x0138 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bDirectUnspecifiedPhysicsThroughChild0 : 1;     		// 0x0144 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	TArray< struct FChildrenBlendInfo >                m_ChildrenBlendInfo;                              		// 0x0148 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1295 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByPhysics::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByQuestGiver
// 0x0034 (0x0160 - 0x012C)
class UTgAnimNodeBlendByQuestGiver : public UTgAnimNodeBlendList
{
public:
	unsigned char                                      m_CurrentState;                                   		// 0x012C (0x0001) [0x0000000000000000]              
	unsigned char                                      m_PreviousState;                                  		// 0x012D (0x0001) [0x0000000000000000]              
	class ATgSkeletalMeshActorNPC*                     m_NPCOwner;                                       		// 0x0130 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	struct FName                                       m_nmQuestAvailableLookAtSkelControlName;          		// 0x0134 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmNoQuestAvailableLookAtSkelControlName;        		// 0x013C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bInfluenceSkelControl : 1;                      		// 0x0144 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UTgSkelCon_LookAt*                           m_QuestAvailableLookAtSkelControl;                		// 0x0148 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_LookAt*                           m_NoQuestAvailableLookAtSkelControl;              		// 0x014C (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmQuestToNoQuest;                               		// 0x0150 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmNoQuestToQuest;                               		// 0x0158 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1296 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByQuestGiver::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByRappelling
// 0x0008 (0x0134 - 0x012C)
class UTgAnimNodeBlendByRappelling : public UTgAnimNodeBlendList
{
public:
	class ATgPawn*                                     pOwner;                                           		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              m_fPrelandDistance;                               		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1297 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendByRappelling::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_EquipScreen
// 0x0000 (0x012C - 0x012C)
class UTgAnimNodeBlendList_EquipScreen : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1298 ];

		return pClassPointer;
	};

	void PlayIdleAnim ( );
	void PlayBackpackReaction ( );
	void PlaySuitReaction ( );
	void PlayHelmetReaction ( );
	void PlayWeaponReaction ( );
};

UClass* UTgAnimNodeBlendList_EquipScreen::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendList_JetpackDeploy
// 0x000C (0x0138 - 0x012C)
class UTgAnimNodeBlendList_JetpackDeploy : public UTgAnimNodeBlendList
{
public:
	float                                              c_fRemainingTime;                                 		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              c_fTimeTillCollapse;                              		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      c_bHasCollapsed : 1;                              		// 0x0134 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1299 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeBlendList_JetpackDeploy::pClassPointer = NULL;

// Class TgGame.TgAnimNodeRandom
// 0x003C (0x0168 - 0x012C)
class UTgAnimNodeRandom : public UTgAnimNodeBlendList
{
public:
	int                                                m_iDefaultChildIndex;                             		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bConsiderRelevancy : 1;                         		// 0x0130 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bMasterOtherNodes : 1;                          		// 0x0130 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bIsASlave : 1;                                  		// 0x0130 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bEnableTimer : 1;                               		// 0x0130 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_TimeAllChildren : 1;                            		// 0x0130 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	TArray< struct FName >                             m_SlaveNames;                                     		// 0x0134 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UTgAnimNodeRandom* >                 m_Slaves;                                         		// 0x0140 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_nPrimaryChild;                                  		// 0x014C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_TimeRange;                                      		// 0x0150 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRemainingTime;                                 		// 0x0158 (0x0004) [0x0000000000000000]              
	TArray< struct FTgRandomAnimInfo >                 RandomInfo;                                       		// 0x015C (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1300 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeRandom::pClassPointer = NULL;

// Class TgGame.TgAnimSequenceChain
// 0x0004 (0x0130 - 0x012C)
class UTgAnimSequenceChain : public UTgAnimNodeBlendList
{
public:
	unsigned long                                      m_bLoopChain : 1;                                 		// 0x012C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bResetOnRelevant : 1;                           		// 0x012C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bDelayBlendOutToPlayAnim : 1;                   		// 0x012C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bIsAllowedToBlendOut : 1;                       		// 0x012C (0x0004) [0x0000000000000000] [0x00000008] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1301 ];

		return pClassPointer;
	};

};

UClass* UTgAnimSequenceChain::pClassPointer = NULL;

// Class TgGame.TgAnimNodeDodgeCustomAnim
// 0x00CC (0x01C8 - 0x00FC)
class UTgAnimNodeDodgeCustomAnim : public UAnimNodePlayCustomAnim
{
public:
	class ATgPawn*                                     pOwner;                                           		// 0x00FC (0x0004) [0x0000000000000000]              
	float                                              m_BlendInTime;                                    		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_BlendOutTime;                                   		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_DefaultF;                                       		// 0x0108 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_DefaultB;                                       		// 0x0110 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_DefaultL;                                       		// 0x0118 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_DefaultR;                                       		// 0x0120 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_DefaultFL;                                      		// 0x0128 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_DefaultFR;                                      		// 0x0130 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_DefaultBL;                                      		// 0x0138 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_DefaultBR;                                      		// 0x0140 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_CrouchF;                                        		// 0x0148 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_CrouchB;                                        		// 0x0150 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_CrouchL;                                        		// 0x0158 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_CrouchR;                                        		// 0x0160 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_CrouchFL;                                       		// 0x0168 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_CrouchFR;                                       		// 0x0170 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_CrouchBL;                                       		// 0x0178 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_CrouchBR;                                       		// 0x0180 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_InAirF;                                         		// 0x0188 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_InAirB;                                         		// 0x0190 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_InAirL;                                         		// 0x0198 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_InAirR;                                         		// 0x01A0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_InAirFL;                                        		// 0x01A8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_InAirFR;                                        		// 0x01B0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_InAirBL;                                        		// 0x01B8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_InAirBR;                                        		// 0x01C0 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1302 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeDodgeCustomAnim::pClassPointer = NULL;

// Class TgGame.TgAnimNodeEmoteCustomAnim
// 0x0004 (0x0100 - 0x00FC)
class UTgAnimNodeEmoteCustomAnim : public UAnimNodePlayCustomAnim
{
public:
	unsigned long                                      c_bIsInHandDeviceMeshInvisible : 1;               		// 0x00FC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bHasReachedFullWeight : 1;                      		// 0x00FC (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1303 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNodeEmoteCustomAnim::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSlot
// 0x0030 (0x0138 - 0x0108)
class UTgAnimNodeSlot : public UAnimNodeSlot
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0108 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bBlendOutIfVelocityIsGreaterThanZero : 1;       		// 0x010C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bIsTransitionAnim : 1;                          		// 0x010C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bNotifyActorOnChildAnimEnd : 1;                 		// 0x010C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	struct FName                                       m_nmHackingTransitionAnimName;                    		// 0x0110 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmHackingLoopingAnimName;                       		// 0x0118 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmAFKTransitionAnimName;                        		// 0x0120 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmAFKLoopingAnimName;                           		// 0x0128 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmQueuedAnim;                                   		// 0x0130 (0x0008) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1304 ];

		return pClassPointer;
	};

	void StopCustomAnim ( float BlendOutTime );
	void StopHacking ( );
	void PlayHacking ( );
	void StopAFK ( );
	void PlayAFK ( );
	float PlayLoopingCustomAnimWithTransition ( struct FName TransitionAnimName, struct FName LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime );
};

UClass* UTgAnimNodeSlot::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_AudioGroup
// 0x000D (0x0049 - 0x003C)
class UTgAnimNotify_AudioGroup : public UAnimNotify
{
public:
	class USoundCue*                                   c_PreviewSound;                                   		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       c_SoundCueName;                                   		// 0x0040 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      c_eMeshSource;                                    		// 0x0048 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1305 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_AudioGroup::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_DeviceMeshVisibility
// 0x0004 (0x0040 - 0x003C)
class UTgAnimNotify_DeviceMeshVisibility : public UAnimNotify
{
public:
	unsigned long                                      c_bInvisible : 1;                                 		// 0x003C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1306 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_DeviceMeshVisibility::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_NPCVoice
// 0x0010 (0x004C - 0x003C)
class UTgAnimNotify_NPCVoice : public UAnimNotify
{
public:
	unsigned char                                      m_PreviewVoice;                                   		// 0x003C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FVoiceSoundCuePairing >             m_VoiceSoundCuePairings;                          		// 0x0040 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1307 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_NPCVoice::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_ToggleSocketSpecialFX
// 0x0028 (0x0064 - 0x003C)
class UTgAnimNotify_ToggleSocketSpecialFX : public UAnimNotify
{
public:
	struct FName                                       m_nSocketName;                                    		// 0x003C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             PreviewParticleSystem;                            		// 0x0044 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_eMeshSource;                                    		// 0x0048 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_DisplayGroupName;                               		// 0x004C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_LengthOverride;                                 		// 0x0054 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_EquipSlot;                                      		// 0x0058 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UParticleSystem*                             m_ParticleSystem;                                 		// 0x005C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_SpecialFXId;                                    		// 0x0060 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1308 ];

		return pClassPointer;
	};

};

UClass* UTgAnimNotify_ToggleSocketSpecialFX::pClassPointer = NULL;

// Class TgGame.TgAnimTurnInPlace
// 0x0078 (0x016C - 0x00F4)
class UTgAnimTurnInPlace : public UAnimNodeBlend
{
public:
	unsigned long                                      bInitialized : 1;                                 		// 0x00F4 (0x0004) [0x0000000000002002] [0x00000001] ( CPF_Const | CPF_Transient )
	unsigned long                                      bRootRotInitialized : 1;                          		// 0x00F4 (0x0004) [0x0000000000002002] [0x00000002] ( CPF_Const | CPF_Transient )
	unsigned long                                      m_bDisableRotation : 1;                           		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bDelayBlendOutToPlayAnim : 1;                     		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      bPlayingTurnTransition : 1;                       		// 0x00F4 (0x0004) [0x0000000000000002] [0x00000010] ( CPF_Const )
	unsigned long                                      m_bCanChooseNewTransition : 1;                    		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bOverrideInterpolationTime : 1;                 		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_bMirrorOffsetWhenPawnMirrored : 1;              		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_bAlwaysUpdateYawOffset : 1;                     		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_bIgnoreTransitionAnimations : 1;                		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_bOnlyUpdateRotationWhenMoving : 1;              		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	unsigned long                                      m_bTurnTowardsVelocity : 1;                       		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000800] ( CPF_Edit )
	unsigned long                                      m_bUsePawnRotationAtZeroVelocity : 1;             		// 0x00F4 (0x0004) [0x0000000000000001] [0x00001000] ( CPF_Edit )
	unsigned long                                      m_bUse180ShortestRoute : 1;                       		// 0x00F4 (0x0004) [0x0000000000000001] [0x00002000] ( CPF_Edit )
	unsigned long                                      m_bConstrictIdleYawOffset : 1;                    		// 0x00F4 (0x0004) [0x0000000000000001] [0x00004000] ( CPF_Edit )
	unsigned long                                      m_bDisableAllTurning : 1;                         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00008000] ( CPF_Edit )
	int                                                LastPawnYaw;                                      		// 0x00F8 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                LastPawnPitch;                                    		// 0x00FC (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	float                                              PawnRotationRate;                                 		// 0x0100 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                LastRootBoneYaw;                                  		// 0x0104 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                YawOffset;                                        		// 0x0108 (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	int                                                PitchOffset;                                      		// 0x010C (0x0004) [0x0000000000002003]              ( CPF_Edit | CPF_Const | CPF_Transient )
	float                                              RelativeOffset;                                   		// 0x0110 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0114 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	TArray< class UTgAnimNodeAimOffset* >              OffsetNodes2;                                     		// 0x0118 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FRotTransitionInfo >                RotTransitions;                                   		// 0x0124 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              TransitionBlendTime;                              		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                CurrentTransitionIndex;                           		// 0x0134 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              TransitionThresholdAngle;                         		// 0x0138 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_ForcedTransitionAngle;                          		// 0x013C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fChooseNewTransitionPercent;                    		// 0x0140 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fInterpolationTime;                             		// 0x0144 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_RemainingInterpolationTime;                     		// 0x0148 (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimTurnInPlace_Player* >         PlayerNodes;                                      		// 0x014C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fIgnoredTransitionTime;                         		// 0x0158 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTurnInterpTime;                                		// 0x015C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_InterpRotation;                                 		// 0x0160 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1309 ];

		return pClassPointer;
	};

};

UClass* UTgAnimTurnInPlace::pClassPointer = NULL;

// Class TgGame.TgAnimTurnInPlace_Player
// 0x000E (0x012C - 0x011E)
class UTgAnimTurnInPlace_Player : public UAnimNodeSequence
{
public:
	TArray< struct FTIP_Transition >                   TIP_Transitions;                                  		// 0x0120 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1310 ];

		return pClassPointer;
	};

};

UClass* UTgAnimTurnInPlace_Player::pClassPointer = NULL;

// Class TgGame.TgAnimTurnInPlace_Rotator
// 0x002B (0x010C - 0x00E1)
class UTgAnimTurnInPlace_Rotator : public UAnimNodeBlendBase
{
public:
	TArray< class UTgAnimTurnInPlace* >                c_TurnInPlaceNodes;                               		// 0x00E4 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< class UTgAnimNodeBlendByBlockDirection* >  c_BlockNodes;                                     		// 0x00F0 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	struct FName                                       c_StabilizerSkelControlName;                      		// 0x00FC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UTgSkelCon_Stabilizer*                       c_StabilizerSkelControl;                          		// 0x0104 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0108 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1311 ];

		return pClassPointer;
	};

};

UClass* UTgAnimTurnInPlace_Rotator::pClassPointer = NULL;

// Class TgGame.TgMorphNodePose
// 0x004C (0x00C8 - 0x007C)
class UTgMorphNodePose : public UMorphNodePose
{
public:
	unsigned long                                      m_bRandomizeWeight : 1;                           		// 0x007C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bIgnoreRandomization : 1;                       		// 0x007C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bEnabled : 1;                                   		// 0x007C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bResetWeight : 1;                               		// 0x007C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bUpdateNodeNameBasedOnMorphName : 1;            		// 0x007C (0x0004) [0x0000000000000000] [0x00000010] 
	float                                              m_fMinRandomizedWeight;                           		// 0x0080 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMaxRandomizedWeight;                           		// 0x0084 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMaxBiasedValue;                                		// 0x0088 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMinBiasedValue;                                		// 0x008C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_BiasedIterations;                               		// 0x0090 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSliderPosition;                                		// 0x0094 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_MorphGroupID;                                   		// 0x0098 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_nHeadPoseID;                                    		// 0x0099 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmPoseID;                                       		// 0x009C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nOrderWithinMorphGroup;                         		// 0x00A4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FMorphCorrection >                  m_MorphCorrections;                               		// 0x00A8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FMaxMorphWeightInfo >               m_MaxMorphWeightList;                             		// 0x00B4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_fMaxMorphWeight;                                		// 0x00C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fCurrentMaxMorphWeight;                         		// 0x00C4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1312 ];

		return pClassPointer;
	};

	bool IsMatchingHeadPoseID ( int IdToMatch );
	bool IsMatchingUIName ( struct FName IdToMatch );
	void RandomizeWeight ( unsigned long bForceRandom );
	float GetRandomizedWeight ( );
};

UClass* UTgMorphNodePose::pClassPointer = NULL;

// Class TgGame.TgMorphNodeBlendList
// 0x0030 (0x00F8 - 0x00C8)
class UTgMorphNodeBlendList : public UTgMorphNodePose
{
public:
	TArray< struct FTgMorphTargetInfo >                m_MorphTargetInfo;                                		// 0x00C8 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	int                                                m_ActiveChildIndex;                               		// 0x00D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bIgnoreMaterialParameters : 1;                  		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bWriteDiffToLog : 1;                            		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bApplyFindAndReplace : 1;                       		// 0x00D8 (0x0004) [0x0000000000002001] [0x00000004] ( CPF_Edit | CPF_Transient )
	class UAnimTree*                                   m_AnimTreeToDiff;                                 		// 0x00DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_NodeNameToDiff;                                 		// 0x00E0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_FindParamterName;                               		// 0x00E8 (0x0008) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )
	struct FName                                       m_ReplaceWithParamterName;                        		// 0x00F0 (0x0008) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1313 ];

		return pClassPointer;
	};

	struct FName GetCurrentMorphWeightGroup ( );
	void SetMaterialParameters ( );
	void RandomizeWeight ( unsigned long bForceRandom );
	void SetActiveChild ( int ChildIndex );
};

UClass* UTgMorphNodeBlendList::pClassPointer = NULL;

// Class TgGame.TgMorphNodeBlendList_ByHairStyle
// 0x0034 (0x012C - 0x00F8)
class UTgMorphNodeBlendList_ByHairStyle : public UTgMorphNodeBlendList
{
public:
	struct FName                                       m_nmPreviewHairSocket;                            		// 0x00F8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UMeshComponent*                              m_PreviewHairMesh;                                		// 0x0100 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   m_PreviewHairMIC;                                 		// 0x0104 (0x0004) [0x0000000000000000]              
	TArray< int >                                      m_nHairIDs;                                       		// 0x0108 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_nCyberCutsStartIndex;                           		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn_Character*                           m_TgPawnOwner;                                    		// 0x0118 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ATgSkeletalMeshActor_CharacterBuilder*       m_CharacterBuilderOwner;                          		// 0x011C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgMorphNodeBlendList*                       m_HairColorMorphNode;                             		// 0x0120 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgMorphNodeBlendList*                       m_SecondaryColorMorphNode;                        		// 0x0124 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgMorphNodeBlendList*                       m_HairAccessoryMorphNode;                         		// 0x0128 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1314 ];

		return pClassPointer;
	};

	struct FName GetCurrentMorphWeightGroup ( );
	void SetMaterialParameters ( );
	void RandomizeWeight ( unsigned long bForceRandom );
	void SetActiveChild ( int ChildIndex );
};

UClass* UTgMorphNodeBlendList_ByHairStyle::pClassPointer = NULL;

// Class TgGame.TgMorphNodeHealth
// 0x0014 (0x010C - 0x00F8)
class UTgMorphNodeHealth : public UTgMorphNodeBlendList
{
public:
	class ATgPawn*                                     m_TgPawn;                                         		// 0x00F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< float >                                    m_HealthChildren;                                 		// 0x00FC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bStepWise : 1;                                  		// 0x0108 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1315 ];

		return pClassPointer;
	};

};

UClass* UTgMorphNodeHealth::pClassPointer = NULL;

// Class TgGame.TgMorphNodeBlendPoses
// 0x005C (0x0124 - 0x00C8)
class UTgMorphNodeBlendPoses : public UTgMorphNodePose
{
public:
	class UMorphTarget*                                m_Target2;                                        		// 0x00C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FName                                       MorphName1;                                       		// 0x00CC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       MorphName2;                                       		// 0x00D4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTarget2Weight;                                 		// 0x00DC (0x0004) [0x0000000000000000]              
	float                                              m_fBlendWeight;                                   		// 0x00E0 (0x0004) [0x0000000000000000]              
	float                                              m_fMaxMorph1Weight;                               		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMaxMorph2Weight;                               		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FMorphCorrection >                  m_Morph1Corrections;                              		// 0x00EC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FMorphCorrection >                  m_Morph2Corrections;                              		// 0x00F8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FMaxMorphWeightInfo >               m_MaxMorph1WeightList;                            		// 0x0104 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FMaxMorphWeightInfo >               m_MaxMorph2WeightList;                            		// 0x0110 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              m_fCurrentMaxMorph1Weight;                        		// 0x011C (0x0004) [0x0000000000000000]              
	float                                              m_fCurrentMaxMorph2Weight;                        		// 0x0120 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1316 ];

		return pClassPointer;
	};

	void RandomizeWeight ( unsigned long bForceRandom );
	void SetSecondaryMorphTarget ( struct FName MorphTargetName );
};

UClass* UTgMorphNodeBlendPoses::pClassPointer = NULL;

// Class TgGame.TgMorphNodeMasterSlider
// 0x002D (0x00F5 - 0x00C8)
class UTgMorphNodeMasterSlider : public UTgMorphNodePose
{
public:
	TArray< struct FName >                             m_ControlledNodeNames;                            		// 0x00C8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FControlledNodes >                  m_Presets;                                        		// 0x00D4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_CurrentPresetIndex;                             		// 0x00E0 (0x0004) [0x0000000000020003]              ( CPF_Edit | CPF_Const | CPF_EditConst )
	unsigned long                                      m_bSaveHeadMorphDataToNewIndex : 1;               		// 0x00E4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSaveHeadMorphDataToCurrentIndex : 1;           		// 0x00E4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	TArray< class UTgMorphNodePose* >                  m_ControlledMorphNodes;                           		// 0x00E8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned char                                      m_GroupID;                                        		// 0x00F4 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1317 ];

		return pClassPointer;
	};

	void RandomizeWeight ( unsigned long bForceRandom );
};

UClass* UTgMorphNodeMasterSlider::pClassPointer = NULL;

// Class TgGame.TgMorphNodePresets
// 0x0014 (0x00DC - 0x00C8)
class UTgMorphNodePresets : public UTgMorphNodePose
{
public:
	unsigned long                                      m_bSaveHeadMorphDataToNewIndex : 1;               		// 0x00C8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bSaveHeadMorphDataToCurrentIndex : 1;           		// 0x00C8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	TArray< struct FMorphPreset >                      m_Presets;                                        		// 0x00CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_CurrentPresetIndex;                             		// 0x00D8 (0x0004) [0x0000000000020003]              ( CPF_Edit | CPF_Const | CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1318 ];

		return pClassPointer;
	};

	int GetHairPoseIDFromPreset ( int PresetIndex );
	void RandomizeWeight ( unsigned long bForceRandom );
	void SetActiveChild ( int ChildIndex );
	void SaveHeadMorphData ( );
};

UClass* UTgMorphNodePresets::pClassPointer = NULL;

// Class TgGame.TgSkelCon_DownDirection
// 0x0050 (0x0134 - 0x00E4)
class UTgSkelCon_DownDirection : public USkelControlSingleBone
{
public:
	struct FVector                                     m_vPreviewDownDirection;                          		// 0x00E4 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_vPreviousDownDirection;                         		// 0x00F0 (0x000C) [0x0000000000000000]              
	float                                              m_fInterpTime;                                    		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0100 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_RotOffset;                                      		// 0x0104 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_UpAxis;                                         		// 0x0110 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bInvertUpAxis : 1;                              		// 0x0114 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bIsAttachedToWall : 1;                          		// 0x0114 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fRemainingTime;                                 		// 0x0118 (0x0004) [0x0000000000000000]              
	float                                              m_NewAngleTime;                                   		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ThisTimstep;                                    		// 0x0120 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_CachedDownDirection;                            		// 0x0124 (0x000C) [0x0000000000000000]              
	float                                              m_fWallOffsetDistance;                            		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1319 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_DownDirection::pClassPointer = NULL;

// Class TgGame.TgSkelCon_FootPlacement
// 0x006A (0x019E - 0x0134)
class UTgSkelCon_FootPlacement : public USkelControlFootPlacement
{
public:
	unsigned long                                      m_bInitialized : 1;                               		// 0x0134 (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgPawn*                                     m_Owner;                                          		// 0x0138 (0x0004) [0x0000000000000000]              
	struct FClassBasedJointInfo                        m_JointInfoRecon;                                 		// 0x013C (0x0018) [0x0000000000000001]              ( CPF_Edit )
	struct FClassBasedJointInfo                        m_JointInfoMedic;                                 		// 0x0154 (0x0018) [0x0000000000000001]              ( CPF_Edit )
	struct FClassBasedJointInfo                        m_JointInfoRobotics;                              		// 0x016C (0x0018) [0x0000000000000001]              ( CPF_Edit )
	struct FClassBasedJointInfo                        m_JointInfoAssault;                               		// 0x0184 (0x0018) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_PreviewClass;                                   		// 0x019C (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_CurrentClass;                                   		// 0x019D (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1320 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_FootPlacement::pClassPointer = NULL;

// Class TgGame.TgSkelCon_HangingPlacement
// 0x000C (0x00F0 - 0x00E4)
class UTgSkelCon_HangingPlacement : public USkelControlSingleBone
{
public:
	float                                              m_XOffset;                                        		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_YOffset;                                        		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ZOffset;                                        		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1321 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_HangingPlacement::pClassPointer = NULL;

// Class TgGame.TgSkelCon_HoverControl
// 0x0088 (0x016C - 0x00E4)
class UTgSkelCon_HoverControl : public USkelControlSingleBone
{
public:
	float                                              m_fIdleBounceHeight;                              		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fIdleBounceSpeed;                               		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMaxIdlePitchAngle;                             		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMaxIdleRollAngle;                              		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bRotateIdleBounce : 1;                          		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bRotateMovementBounce : 1;                      		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	float                                              m_fIdlePitchTension;                              		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fLastIdleBounceHeight;                          		// 0x00FC (0x0004) [0x0000000000000000]              
	float                                              m_fIdleInterpSpeed;                               		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fIdleRollTension;                               		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fLastRollControl;                               		// 0x0108 (0x0004) [0x0000000000000000]              
	float                                              m_fRollSpeed;                                     		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRollHeight;                                    		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMovementBounceHeight;                          		// 0x0114 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMovementBounceSpeed;                           		// 0x0118 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMaxMovementPitchAngle;                         		// 0x011C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMaxMovementRollAngle;                          		// 0x0120 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMovementPitchTension;                          		// 0x0124 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fLastMovementBounceHeight;                      		// 0x0128 (0x0004) [0x0000000000000000]              
	float                                              m_fMovementInterpSpeed;                           		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMovementToIdleInterpSpeed;                     		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fIdleVelocity;                                  		// 0x0134 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_LastHoverDirection;                             		// 0x0138 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_PreviewHoverDirections;                         		// 0x0139 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_LastVelocity;                                   		// 0x013C (0x000C) [0x0000000000000000]              
	class ATgPawn*                                     m_TgPawn;                                         		// 0x0148 (0x0004) [0x0000000000000000]              
	float                                              m_fBlendTime;                                     		// 0x014C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRemainingBlendTime;                            		// 0x0150 (0x0004) [0x0000000000000000]              
	float                                              m_fBounceHeight;                                  		// 0x0154 (0x0004) [0x0000000000000000]              
	float                                              m_fBounceSpeed;                                   		// 0x0158 (0x0004) [0x0000000000000000]              
	float                                              m_fTest2;                                         		// 0x015C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTest3;                                         		// 0x0160 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTest4;                                         		// 0x0164 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTest5;                                         		// 0x0168 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1322 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_HoverControl::pClassPointer = NULL;

// Class TgGame.TgSkelCon_LookAt
// 0x004C (0x0174 - 0x0128)
class UTgSkelCon_LookAt : public USkelControlLookAt
{
public:
	unsigned long                                      m_bLockEffectorZLocation : 1;                     		// 0x0128 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bAimAtEnemyTarget : 1;                          		// 0x0128 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bHadTargetLastTick : 1;                         		// 0x0128 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_AlwaysInterpolateTarget : 1;                    		// 0x0128 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bEnableRandomPoints : 1;                        		// 0x0128 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      bQuestGiver : 1;                                  		// 0x0128 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	class ATgPawn*                                     m_Owner;                                          		// 0x012C (0x0004) [0x0000000000000000]              
	struct FName                                       m_ParentLookAtControlName;                        		// 0x0130 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	class UTgSkelCon_LookAt*                           m_ParentLookAtControl;                            		// 0x0138 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_MinMaxNewPointTime;                             		// 0x013C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_MinMaxRangeX;                                   		// 0x0144 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_MinMaxRangeY;                                   		// 0x014C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_MinMaxRangeZ;                                   		// 0x0154 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_MinMaxInterpSpeed;                              		// 0x015C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fTimeTillNewRandomPoint;                        		// 0x0164 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FLookAtExtendBoneData >             TwistData;                                        		// 0x0168 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1323 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_LookAt::pClassPointer = NULL;

// Class TgGame.TgSkelCon_MeleeHipCorrection
// 0x0000 (0x00E4 - 0x00E4)
class UTgSkelCon_MeleeHipCorrection : public USkelControlSingleBone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1324 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_MeleeHipCorrection::pClassPointer = NULL;

// Class TgGame.TgSkelCon_MorphCorrection
// 0x000C (0x00F0 - 0x00E4)
class UTgSkelCon_MorphCorrection : public USkelControlSingleBone
{
public:
	struct FName                                       m_MorphCorrectionGroupName;                       		// 0x00E4 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bInvertXAxis : 1;                               		// 0x00EC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bInvertYAxis : 1;                               		// 0x00EC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bInvertZAxis : 1;                               		// 0x00EC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1325 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_MorphCorrection::pClassPointer = NULL;

// Class TgGame.TgSkelCon_MorphCorrectionFloater
// 0x0000 (0x00F0 - 0x00F0)
class UTgSkelCon_MorphCorrectionFloater : public UTgSkelCon_MorphCorrection
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1326 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_MorphCorrectionFloater::pClassPointer = NULL;

// Class TgGame.TgSkelCon_RobotFootPlacement
// 0x002C (0x0160 - 0x0134)
class UTgSkelCon_RobotFootPlacement : public USkelControlFootPlacement
{
public:
	struct FName                                       m_LineTraceEndBoneName;                           		// 0x0134 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_LineTraceStartBoneName;                         		// 0x013C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bDrawDebugLine : 1;                             		// 0x0144 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FVector                                     m_StartLineTrace;                                 		// 0x0148 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_EndLineTrace;                                   		// 0x0154 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1327 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_RobotFootPlacement::pClassPointer = NULL;

// Class TgGame.TgSkelCon_RollToRotation
// 0x0020 (0x0104 - 0x00E4)
class UTgSkelCon_RollToRotation : public USkelControlSingleBone
{
public:
	int                                                m_nPreviousYaw;                                   		// 0x00E4 (0x0004) [0x0000000000000000]              
	float                                              m_fRollAmountNormalized;                          		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              m_fInterpSpeedInToRoll;                           		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fInterpSpeedOutOfRoll;                          		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nMaxDeltaYaw;                                   		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nMaxRollAngle;                                  		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_TgPawn;                                         		// 0x00FC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bInitialized : 1;                               		// 0x0100 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1328 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_RollToRotation::pClassPointer = NULL;

// Class TgGame.TgSkelCon_SingleBone
// 0x0000 (0x00E4 - 0x00E4)
class UTgSkelCon_SingleBone : public USkelControlSingleBone
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1329 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_SingleBone::pClassPointer = NULL;

// Class TgGame.TgSkelCon_LaserTarget
// 0x0008 (0x00EC - 0x00E4)
class UTgSkelCon_LaserTarget : public UTgSkelCon_SingleBone
{
public:
	unsigned long                                      bHasTarget : 1;                                   		// 0x00E4 (0x0004) [0x0000000000000000] [0x00000001] 
	class AActor*                                      Target;                                           		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1330 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_LaserTarget::pClassPointer = NULL;

// Class TgGame.TgSkelCon_SlopeConformer
// 0x0070 (0x0154 - 0x00E4)
class UTgSkelCon_SlopeConformer : public USkelControlSingleBone
{
public:
	unsigned char                                      m_UpAxis;                                         		// 0x00E4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_RotOffset;                                      		// 0x00E8 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bInvertUpAxis : 1;                              		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bUseLowestHeightWhenTraceFails : 1;             		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_ShowLineTraceDebug : 1;                         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bRotateOnly : 1;                                		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bConformForAllPhysicsStates : 1;                		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_fMaxZCorrection : 1;                            		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bPreserveDistance : 1;                          		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	float                                              m_MaxOrientAdjust;                                		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_LineTraceDistance;                              		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_VerticalOffset;                                 		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_NewAngleTime;                                   		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_NewTranslationTime;                             		// 0x0108 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fStartTraceZOffset;                             		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ThisTimstep;                                    		// 0x0110 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_CachedFloorNormal;                              		// 0x0114 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_FloorNormalLastTick;                            		// 0x0120 (0x000C) [0x0000000000000000]              
	float                                              m_fRemainingTime;                                 		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingTranslationTime;                      		// 0x0130 (0x0004) [0x0000000000000000]              
	float                                              m_TargetDeltaAngle;                               		// 0x0134 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_PreviousDeltaAxis;                              		// 0x0138 (0x000C) [0x0000000000000000]              
	float                                              m_fZDiffLastTick;                                 		// 0x0144 (0x0004) [0x0000000000000000]              
	float                                              m_fAngleToNormalLastTick;                         		// 0x0148 (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmBoneToPreserveAgainst;                        		// 0x014C (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1331 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_SlopeConformer::pClassPointer = NULL;

// Class TgGame.TgSkelCon_SpinControl
// 0x0030 (0x0114 - 0x00E4)
class UTgSkelCon_SpinControl : public USkelControlSingleBone
{
public:
	float                                              m_fDegreesPerSecond;                              		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_vAxis;                                          		// 0x00E8 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_PreviewStartStop : 1;                           		// 0x00F4 (0x0004) [0x0000000000002001] [0x00000001] ( CPF_Edit | CPF_Transient )
	unsigned long                                      m_bIsSpinning : 1;                                		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bSpinningUp : 1;                                		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bSpinningDown : 1;                              		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bRotateToTargetRotation : 1;                    		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	float                                              m_fSpinUpTime;                                    		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSpinDownTime;                                  		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fCurrentDegreesPerSecond;                       		// 0x0100 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_TargetRotation;                                 		// 0x0104 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_TimeToInterpToTargetRotation;                   		// 0x0110 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1332 ];

		return pClassPointer;
	};

	void SpinToTargetRotation ( struct FRotator TargetRotation, float Time, unsigned long bReset );
	void Spin ( unsigned long bEnabled );
};

UClass* UTgSkelCon_SpinControl::pClassPointer = NULL;

// Class TgGame.TgSkelCon_Spinner
// 0x0004 (0x00E8 - 0x00E4)
class UTgSkelCon_Spinner : public USkelControlSingleBone
{
public:
	float                                              DeltaRotation;                                    		// 0x00E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1333 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_Spinner::pClassPointer = NULL;

// Class TgGame.TgSkelCon_Stabilizer
// 0x0018 (0x00FC - 0x00E4)
class UTgSkelCon_Stabilizer : public USkelControlSingleBone
{
public:
	int                                                m_YawOffset;                                      		// 0x00E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_PitchOffsetDegrees;                             		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_YawOffsetDegrees;                               		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_RollOffsetDegrees;                              		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bCancelOutOwnersPitch : 1;                      		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bInitialized : 1;                               		// 0x00F4 (0x0004) [0x0000000000000000] [0x00000002] 
	class ATgPawn*                                     m_TgPawn;                                         		// 0x00F8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1334 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_Stabilizer::pClassPointer = NULL;

// Class TgGame.TgSkelCon_Trail
// 0x0024 (0x00D8 - 0x00B4)
class UTgSkelCon_Trail : public USkelControlBase
{
public:
	int                                                m_ChainLength;                                    		// 0x00B4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_ChainBoneAxis;                                  		// 0x00B8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bInvertChainBoneAxis : 1;                       		// 0x00BC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bLimitStretch : 1;                              		// 0x00BC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bHadValidStrength : 1;                          		// 0x00BC (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_TrailRelaxation;                                		// 0x00C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_StretchLimit;                                   		// 0x00C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ThisTimstep;                                    		// 0x00C8 (0x0004) [0x0000000000000000]              
	TArray< struct FVector >                           m_TrailBoneLocations;                             		// 0x00CC (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1335 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_Trail::pClassPointer = NULL;

// Class TgGame.TgSkelCon_TreadPlacement
// 0x0048 (0x012C - 0x00E4)
class UTgSkelCon_TreadPlacement : public USkelControlSingleBone
{
public:
	unsigned char                                      m_UpAxis;                                         		// 0x00E4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    m_RotOffset;                                      		// 0x00E8 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bInvertUpAxis : 1;                              		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_ShowLineTraceDebug : 1;                         		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	float                                              m_MaxOrientAdjust;                                		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_LineTraceDistance;                              		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_VerticalOffset;                                 		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_NewAngleTime;                                   		// 0x0104 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_ThisTimstep;                                    		// 0x0108 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_PreviousFloorNormal;                            		// 0x010C (0x000C) [0x0000000000000000]              
	float                                              m_fRemainingTime;                                 		// 0x0118 (0x0004) [0x0000000000000000]              
	float                                              m_TargetDeltaAngle;                               		// 0x011C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_PreviousDeltaAxis;                              		// 0x0120 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1336 ];

		return pClassPointer;
	};

};

UClass* UTgSkelCon_TreadPlacement::pClassPointer = NULL;

// Class TgGame.TgSkelCon_Twist
// 0x0044 (0x00F8 - 0x00B4)
class UTgSkelCon_Twist : public USkelControlBase
{
public:
	TArray< struct FTwistBoneData >                    TwistData;                                        		// 0x00B4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FLeanBoneData >                     LeanData;                                         		// 0x00C0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                HeadYaw;                                          		// 0x00CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                LastHeadYaw;                                      		// 0x00D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              LastZeroed;                                       		// 0x00D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      bInitialized : 1;                                 		// 0x00D8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      bDormant : 1;                                     		// 0x00D8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      bForcedLookAt : 1;                                		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bRecentering : 1;                                 		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FVector                                     ForceFocalPoint;                                  		// 0x00DC (0x000C) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      ForceFocalActor;                                  		// 0x00E8 (0x0004) [0x0000000000000000]              
	struct FString                                     debugstr;                                         		// 0x00EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1337 ];

		return pClassPointer;
	};

	void UnlockLook ( );
	void ForceLookAt ( class AActor* FocalActor, struct FVector FocalPoint );
	void TwistDisplayDebug ( class AHUD* HUD, class ATgPawn_Character* PawnOwner, float* out_YL, float* out_YPos );
	int Fix ( int Num );
	void ResetAbove ( struct FName BoneName, int NewYaw );
	void Reset ( int NewYaw );
};

UClass* UTgSkelCon_Twist::pClassPointer = NULL;

// Class TgGame.TgSkelControl_TankTread
// 0x0030 (0x00E4 - 0x00B4)
class UTgSkelControl_TankTread : public USkelControlBase
{
public:
	float                                              SpaceAbove;                                       		// 0x00B4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              SpaceBelow;                                       		// 0x00B8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       TreadBone;                                        		// 0x00BC (0x0008) [0x0000000000000001]              ( CPF_Edit )
	int                                                TreadIndex;                                       		// 0x00C4 (0x0004) [0x0000000000000000]              
	float                                              CenterOffset;                                     		// 0x00C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< float >                                    AlternateScanOffsets;                             		// 0x00CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      bAlwaysScan : 1;                                  		// 0x00D8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bInitialized : 1;                                 		// 0x00D8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      bDormant : 1;                                     		// 0x00D8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      bLastDirWasBackwards : 1;                         		// 0x00D8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	float                                              Adjustment;                                       		// 0x00DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              TargetAdjustment;                                 		// 0x00E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1338 ];

		return pClassPointer;
	};

};

UClass* UTgSkelControl_TankTread::pClassPointer = NULL;

// Class TgGame.TgSocketOffsetInfo
// 0x0048 (0x0084 - 0x003C)
class UTgSocketOffsetInfo : public UObject
{
public:
	class UAnimTree*                                   m_AnimTree;                                       		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMesh*                               m_SkeletalMesh;                                   		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMeshComponent*                      m_PreviewSkelComp;                                		// 0x0044 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UAnimSet*                                    m_AnimSet;                                        		// 0x0048 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FSocketOffsetInfo >                 m_SocketOffsets;                                  		// 0x004C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FName                                       m_AimOffsetNodeName;                              		// 0x0058 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_TurnInPlaceNodeName;                            		// 0x0060 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_TransitionTime;                                 		// 0x0068 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bIgnoreTransitionAnims : 1;                     		// 0x006C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bCanChooseNewTransition : 1;                    		// 0x006C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bForceAimDir : 1;                               		// 0x006C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	float                                              m_fChooseNewTransitionPercent;                    		// 0x0070 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_ForcedAimDir;                                   		// 0x0074 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmCachedSocketName;                             		// 0x0078 (0x0008) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nCachedSocketIndex;                             		// 0x0080 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1339 ];

		return pClassPointer;
	};

	bool GetInterpLocation ( struct FVector2D Aim, struct FName SocketName, struct FName ProfileName, struct FVector* OutInterpLocation );
};

UClass* UTgSocketOffsetInfo::pClassPointer = NULL;

// Class TgGame.TgDevice
// 0x00C0 (0x02D8 - 0x0218)
class ATgDevice : public AWeapon
{
public:
	int                                                m_CurrentSituationalAttackType;                   		// 0x0218 (0x0004) [0x0000000000000000]              
	int                                                r_nDeviceId;                                      		// 0x021C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDeviceInstanceId;                              		// 0x0220 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nQualityValueId;                                		// 0x0224 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eEquippedAt;                                    		// 0x0228 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      CurrentFireMode;                                  		// 0x0229 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_bDeployModeStatus;                              		// 0x022A (0x0001) [0x0000000000000000]              
	unsigned char                                      FiredFireMode;                                    		// 0x022B (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bSocketMaxCalculated : 1;                       		// 0x022C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bPendingFire : 1;                                 		// 0x022C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bEquipEffectsApplied : 1;                       		// 0x022C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bAimCharging : 1;                               		// 0x022C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bIsCurrentlyDoingBlockBreaker : 1;              		// 0x022C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bServerSaysBlock : 1;                           		// 0x022C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bAutoLock : 1;                                  		// 0x022C (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bHandDevice : 1;                                		// 0x022C (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bEffectsOnlyInHand : 1;                         		// 0x022C (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      r_bIsStealthDevice : 1;                           		// 0x022C (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	unsigned long                                      m_bUsesDeployMode : 1;                            		// 0x022C (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      r_bConsumedOnUse : 1;                             		// 0x022C (0x0004) [0x0000000000000020] [0x00000800] ( CPF_Net )
	unsigned long                                      r_bConsumedOnDeath : 1;                           		// 0x022C (0x0004) [0x0000000000000020] [0x00001000] ( CPF_Net )
	unsigned long                                      c_bCustomLeftClickBehavior : 1;                   		// 0x022C (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      c_bCustomLeftClickBehaviorLoaded : 1;             		// 0x022C (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bIsOffHand : 1;                                 		// 0x022C (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bIsBeaconPlacing : 1;                           		// 0x022C (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_bIsRestDevice : 1;                              		// 0x022C (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_bDeviceCanFire : 1;                             		// 0x022C (0x0004) [0x0000000000000000] [0x00040000] 
	int                                                m_nSocketIndex;                                   		// 0x0230 (0x0004) [0x0000000000000000]              
	int                                                m_nSocketMax;                                     		// 0x0234 (0x0004) [0x0000000000000000]              
	TArray< class UTgDeviceFire* >                     m_FireMode;                                       		// 0x0238 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nMeleeComboSeed;                                		// 0x0244 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgDeviceForm*                               c_DeviceForm;                                     		// 0x0248 (0x0004) [0x0000000000000000]              
	float                                              s_fLastRecharge;                                  		// 0x024C (0x0004) [0x0000000000000000]              
	class ATgTimerManager*                             m_CooldownTimers;                                 		// 0x0250 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_SoundImpactProxy;                               		// 0x0254 (0x0004) [0x0000000000000000]              
	TArray< struct FImpactInfo >                       PendingImpactList;                                		// 0x0258 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	float                                              m_fChargeTime;                                    		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              m_fAimCharge;                                     		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              m_fLastAimCharge;                                 		// 0x026C (0x0004) [0x0000000000000000]              
	float                                              m_nExtraRangeForAcquiringTargetsHack;             		// 0x0270 (0x0004) [0x0000000000000000]              
	struct FVector                                     c_DeployModeSpawnLocation;                        		// 0x0274 (0x000C) [0x0000000000000000]              
	struct FRotator                                    c_DeployModeSpawnRotation;                        		// 0x0280 (0x000C) [0x0000000000000000]              
	class ATgPawn*                                     c_PreviousTarget;                                 		// 0x028C (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_pwzDeviceName;                                  		// 0x0290 (0x0004) [0x0000000000001000]              ( CPF_Native )
	class UTgEffectGroup*                              m_EquipEffect;                                    		// 0x0294 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceType;                                    		// 0x0298 (0x0004) [0x0000000000000000]              
	float                                              EquipTime;                                        		// 0x029C (0x0004) [0x0000000000000000]              
	float                                              PutDownTime;                                      		// 0x02A0 (0x0004) [0x0000000000000000]              
	float                                              WeaponRange;                                      		// 0x02A4 (0x0004) [0x0000000000000000]              
	int                                                s_nEquipAsmId;                                    		// 0x02A8 (0x0004) [0x0000000000000000]              
	class UTgInventoryObject*                          s_InventoryObject;                                		// 0x02AC (0x0004) [0x0000000000000000]              
	int                                                m_nSkillId;                                       		// 0x02B0 (0x0004) [0x0000000000000000]              
	int                                                m_nSkillLevel;                                    		// 0x02B4 (0x0004) [0x0000000000000000]              
	int                                                m_nRightClickBehaviorType;                        		// 0x02B8 (0x0004) [0x0000000000000000]              
	int                                                r_nInventoryId;                                   		// 0x02BC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgHexItemInstance*                          s_HexItem;                                        		// 0x02C0 (0x0004) [0x0000000000000000]              
	float                                              m_fLastDeviceCanFireTimeStamp;                    		// 0x02C4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vCachedWeaponStartTraceLocation;                		// 0x02C8 (0x000C) [0x0000000000000000]              
	float                                              m_fLastWeaponTraceLocTimeStamp;                   		// 0x02D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1340 ];

		return pClassPointer;
	};

	bool ApplyGlobalOffhandCooldown ( );
	struct FVector GetStartTraceLocation ( );
	void CacheStartTraceLocation ( struct FVector vLoc );
	void eventDestroyed ( );
	void OnBuffChange ( );
	bool IsRightClickAimMode ( );
	void UpdateIndex ( );
	bool IsMovementDevice ( );
	void RefireCheckTimer ( );
	void DropBlock ( );
	void ClientStartBlock ( );
	void ClientDropBlock ( );
	void EndBlockCooldown ( );
	void PauseFiringInHandWeapon ( );
	bool eventIsOffhand ( );
	void NotifySwitchMode ( );
	void NotifyPutAway ( );
	void eventClientStartCooldown ( int nMode, float fCooldownTime );
	void eventStartCooldown ( int nMode, float fCooldownTimeOverride );
	void ClientCooldownTimerExpired ( int nTimerId, unsigned char eEvent );
	void CooldownTimerExpired ( int nTimerId, unsigned char eEvent );
	void DeactivateAllModes ( );
	void eventRemoveAllDeviceEffects ( );
	void RemoveAimEffects ( int nMode );
	void ApplyAimEffects ( int nMode );
	void RemoveEquipEffects ( );
	void eventApplyEquipEffects ( );
	void ApplyBlockersCounterEffects ( class AActor* attacker, class AActor* Blocker, class UTgDeviceFire* BlockDeviceFire, int SituationalMeleeGroupToApply );
	class UTgDeviceFire* GetOpponentsBlockEffect ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	void FireAmmunition ( );
	void TrackDeviceModeFired ( class ATgPawn* PawnFiring );
	bool GetProjectileTraceImpact ( struct FVector StartTrace, struct FVector AimDir, unsigned long bTracking, struct FImpactInfo* TraceImpact );
	class ATgPawn* GetTrackingTarget ( );
	struct FVector GetPhysicalFireStartLoc ( struct FVector AimDir );
	class AProjectile* ProjectileFire ( );
	void CustomFire ( );
	void AOEArcingFlash ( TArray< struct FImpactInfo > ImpactList, struct FVector StartLocation );
	void ArcingFire ( );
	void eventInstantFire ( );
	class ATgPawn* eventAcquireMeleeTarget ( int* bExactTarget );
	float LinePointDist ( struct FVector A, struct FVector B, struct FVector pt );
	void eventDeliverQueuedPendingHits ( );
	void ProcessInstantHit ( unsigned char FiringMode, struct FImpactInfo Impact );
	void MakeNoiseExternal ( struct FVector vLocation, float fLoudness );
	struct FImpactInfo CalcWeaponFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	void ServerStopFire ( );
	void eventServerStopFireAsEvent ( );
	void StopFire ( );
	void ServerStartFire ( class ATgPawn* TargetPawn, unsigned long bIsBlockBreaker );
	void eventServerStartFireAsEvent ( );
	void CheckTeamStealth ( );
	int GetSituationalMeleeEffectToApply ( class ATgPawn* attacker );
	void GlobalOffhandCooldownCompleteClient ( );
	void GlobalOffhandCooldownCompleteServer ( );
	bool eventStartFire ( unsigned long bIsBlockBreaker );
	void ServerSetTrackingTarget ( class ATgPawn* TargetPawn );
	class ATgPawn* ClientSetTrackingTarget ( );
	bool CheckCustomStartFire ( );
	bool NeedCustomLeftClickBehavior ( );
	bool eventCanDeviceStartFiringNow ( unsigned char FireModeNum, unsigned long bDebugRelevant );
	void CacheDeviceCanFire ( unsigned long bDeviceCanFire );
	bool eventCanDeviceFireNow ( unsigned char FireModeNum, unsigned long bDeviceFailLog );
	bool IsNonCombatJetpack ( );
	bool eventIsMoraleDevice ( );
	float eventAmountCurrentlyOffOfTargetAccuracy ( unsigned char FireModeNum );
	bool CanFireWhileHanging ( );
	bool CanFireWhileDoingRoutineTasks ( int FireModeNum );
	bool CanUseDeviceInThisPhysicsState ( int FireModeNum );
	void eventConsumeDevice ( );
	bool UsesPower ( );
	void DeviceConsumePowerPool ( unsigned char FireModeNum );
	void ClientInterrupt ( );
	void InterruptFiring ( );
	void DeviceShutDown ( unsigned long bDeactiveMode, unsigned long bResetCooldowns );
	void eventExitDeployMode ( );
	void eventEnterDeployMode ( );
	bool CanEnterDeployMode ( );
	void ServerDoRemoteDetonation ( int nFireMode );
	void eventSetActiveState ( );
	void ClearModeEquippingHUDTimerAndReticle ( );
	void SetModeEquippingHUDTimerAndReticle ( );
	void UpdateHudActionButtons ( );
	struct FRotator GetAdjustedAim ( struct FVector StartFireLoc );
	struct FRotator AddSpread ( struct FRotator BaseAim, float fAccuracy );
	float GetEffectiveRange ( );
	float GetRange ( );
	bool IsEquipping ( );
	bool eventIsFiring ( );
	int GetRestrictType ( );
	void DisplayMessage ( struct FString sMessage );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void WeaponLog ( struct FString msg, struct FString FuncStr );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsGameTypeDisabled ( );
	bool ShowUICanFire ( );
	class ATgTimerManager* GetCooldownTimerManager ( );
	bool IsDeviceRefiring ( );
	bool IsDeviceCoolingDown ( unsigned char FireModeNum );
	bool HasMinimumPowerPool ( unsigned char FireModeNum );
	bool HasEnoughPowerPoolToBlock ( );
	bool HasEnoughPowerPool ( unsigned char FireModeNum );
	bool IsMeleeAttack ( );
	bool IsRangedAttack ( );
	int GetModeRange ( int nMode );
	bool CheckModeRange ( int nMode, struct FVector vDelta );
	bool IsOffhandJetpack ( );
	void SetHexItem ( class UTgHexItemInstance* newHexItem );
	void ApplyInventoryEquipEffects ( unsigned long bRemove );
	bool IsAPickupFlagDevice ( );
	bool IsRestDevice ( );
	class UTgDeviceFire* GetDeviceFire ( int nMode );
	class UTgDeviceFire* GetCurrentFire ( );
	void TickInHandWeapon ( float DeltaSeconds );
	void ClearInstigatorEquippedDevices ( );
	void PopulateInstigatorEquippedDevices ( );
	bool NeedServerDetonate ( int nFireMode );
	bool ServerDetonate ( int nFireMode );
	bool LogDebugInfo ( );
	bool IsABeaconPlacingDevice ( );
	void RemoveConsumableFromOwnerInventory ( );
	void UpdateDeployModeStatus ( );
	struct FString GetDeviceName ( );
	void CalcFireSocketIndexMax ( );
	struct FName GetFireSocketName ( );
	struct FName QueryDeployableClass ( int nMode );
	struct FName QueryProjectileClass ( int nMode );
	bool ApplyDeviceSetup ( );
};

UClass* ATgDevice::pClassPointer = NULL;

// Class TgGame.TgDevice_Grenade
// 0x0000 (0x02D8 - 0x02D8)
class ATgDevice_Grenade : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1341 ];

		return pClassPointer;
	};

	struct FRotator GetAdjustedAim ( struct FVector StartFireLoc );
};

UClass* ATgDevice_Grenade::pClassPointer = NULL;

// Class TgGame.TgDevice_HitPulse
// 0x0008 (0x02E0 - 0x02D8)
class ATgDevice_HitPulse : public ATgDevice
{
public:
	float                                              s_fPersistTime;                                   		// 0x02D8 (0x0004) [0x0000000000000000]              
	float                                              s_fPersistHitPulse;                               		// 0x02DC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1342 ];

		return pClassPointer;
	};

	void FireAmmunition ( );
	void PersistTimer ( );
	bool eventStartFire ( unsigned long bIsBlockBreaker );
};

UClass* ATgDevice_HitPulse::pClassPointer = NULL;

// Class TgGame.TgDevice_Morale
// 0x0008 (0x02E8 - 0x02E0)
class ATgDevice_Morale : public ATgDevice_HitPulse
{
public:
	int                                                m_nReadySoundCueId;                               		// 0x02E0 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bIsActivelyFiring : 1;                          		// 0x02E4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1343 ];

		return pClassPointer;
	};

	void Destroyed ( );
	bool eventHasEnoughMorale ( );
	bool eventCanDeviceStartFiringNow ( unsigned char FireModeNum, unsigned long bDebugRelevant );
	bool CanFireMoraleDevice ( );
	bool eventIsMoraleDevice ( );
	bool ShowUICanFire ( );
	void SetRequiredMoralePoints ( );
	void SendMoraleBoostMessage ( );
};

UClass* ATgDevice_Morale::pClassPointer = NULL;

// Class TgGame.TgDevice_NewMelee
// 0x0000 (0x02D8 - 0x02D8)
class ATgDevice_NewMelee : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1344 ];

		return pClassPointer;
	};

	struct FImpactInfo MeleeMouseOver ( class AActor* TraceActor, struct FVector StartTrace, struct FVector EndTrace );
	class ATgPawn* eventAcquireMeleeTarget ( int* bExactTarget );
	void ProcessInstantHit ( unsigned char FiringMode, struct FImpactInfo Impact );
	void DeliverMeleeHit ( );
	void FireAmmunition ( );
	bool eventIsFiring ( );
};

UClass* ATgDevice_NewMelee::pClassPointer = NULL;

// Class TgGame.TgDevice_MeleeDualWield
// 0x0000 (0x02D8 - 0x02D8)
class ATgDevice_MeleeDualWield : public ATgDevice_NewMelee
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1345 ];

		return pClassPointer;
	};

};

UClass* ATgDevice_MeleeDualWield::pClassPointer = NULL;

// Class TgGame.TgDevice_NewRange
// 0x0000 (0x02D8 - 0x02D8)
class ATgDevice_NewRange : public ATgDevice
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1346 ];

		return pClassPointer;
	};

};

UClass* ATgDevice_NewRange::pClassPointer = NULL;

// Class TgGame.TgDeviceFire
// 0x0128 (0x0164 - 0x003C)
class UTgDeviceFire : public UObject
{
public:
	class AActor*                                      m_Owner;                                          		// 0x003C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_nFireType;                                      		// 0x0040 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eTargetMode;                                    		// 0x0041 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eTargeterType;                                  		// 0x0042 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bIsAOE : 1;                                     		// 0x0044 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIsCone : 1;                                    		// 0x0044 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bContinuousFire : 1;                            		// 0x0044 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bRequireLOS : 1;                                		// 0x0044 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bRestrictInCombat : 1;                          		// 0x0044 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bRequireAimMode : 1;                            		// 0x0044 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bDoNotPauseAIDuringBuildup : 1;                 		// 0x0044 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bAllowPetDomination : 1;                        		// 0x0044 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bBackstabCapable : 1;                           		// 0x0044 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      s_bSpawnTurret : 1;                               		// 0x0044 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bAllowMultipleTargets : 1;                      		// 0x0044 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      s_bUseProgression : 1;                            		// 0x0044 (0x0004) [0x0000000000000000] [0x00000800] 
	TArray< class UTgEffectGroup* >                    s_EffectGroupList;                                		// 0x0048 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgProperty* >                       m_Properties;                                     		// 0x0054 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FTGDFM_ANIM_SEQUENCE >              s_AnimSeqArrayRightSide;                          		// 0x0060 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FTGDFM_ANIM_SEQUENCE >              s_AnimSeqArrayLeftSide;                           		// 0x006C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FPointer                                    m_pAmSetup;                                       		// 0x0078 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_pFireModeSetup;                                 		// 0x007C (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                m_nId;                                            		// 0x0080 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_pwzDeviceFireName;                              		// 0x0084 (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                m_nAttackType;                                    		// 0x0088 (0x0004) [0x0000000000000000]              
	int                                                m_nRemoteType;                                    		// 0x008C (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmOffhandAnimationType;                         		// 0x0090 (0x0008) [0x0000000000000000]              
	int                                                m_nCameraType;                                    		// 0x0098 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetAffectsType;                             		// 0x009C (0x0004) [0x0000000000000000]              
	int                                                s_nAttackRating;                                  		// 0x00A0 (0x0004) [0x0000000000000000]              
	struct FName                                       c_nmReticule;                                     		// 0x00A4 (0x0008) [0x0000000000000000]              
	struct FName                                       c_nmZoomScopeMaterial;                            		// 0x00AC (0x0008) [0x0000000000000000]              
	int                                                m_nRestrictFiringFlags;                           		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                m_nRestrictPhysicsFlags;                          		// 0x00B8 (0x0004) [0x0000000000000000]              
	int                                                m_nDamageType;                                    		// 0x00BC (0x0004) [0x0000000000000000]              
	int                                                m_nArcingJumps;                                   		// 0x00C0 (0x0004) [0x0000000000000000]              
	int                                                m_nRangeIndex;                                    		// 0x00C4 (0x0004) [0x0000000000000000]              
	int                                                m_nMinRangeIndex;                                 		// 0x00C8 (0x0004) [0x0000000000000000]              
	int                                                m_nConeAttackAngleIndex;                          		// 0x00CC (0x0004) [0x0000000000000000]              
	int                                                m_nDamageRadiusIndex;                             		// 0x00D0 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyIndex;                                 		// 0x00D4 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyCrouchIndex;                           		// 0x00D8 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracySprintIndex;                           		// 0x00DC (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyWalkIndex;                             		// 0x00E0 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyAimModeBonusIndex;                     		// 0x00E4 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyCorrectionRateIndex;                   		// 0x00E8 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyCorrectionRateCrouchIndex;             		// 0x00EC (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyLossMaxIndex;                          		// 0x00F0 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyLossOnJumpIndex;                       		// 0x00F4 (0x0004) [0x0000000000000000]              
	int                                                m_nAccuracyLossOnShootIndex;                      		// 0x00F8 (0x0004) [0x0000000000000000]              
	int                                                m_nEffectiveRangeIndex;                           		// 0x00FC (0x0004) [0x0000000000000000]              
	int                                                m_nInterruptChanceIndex;                          		// 0x0100 (0x0004) [0x0000000000000000]              
	int                                                s_nMaxDeployableIndex;                            		// 0x0104 (0x0004) [0x0000000000000000]              
	int                                                m_nScopePowerIndex;                               		// 0x0108 (0x0004) [0x0000000000000000]              
	int                                                m_nCoolDownTimeIndex;                             		// 0x010C (0x0004) [0x0000000000000000]              
	int                                                m_nBuildupChargeTimeIndex;                        		// 0x0110 (0x0004) [0x0000000000000000]              
	int                                                m_nActivationTimeIndex;                           		// 0x0114 (0x0004) [0x0000000000000000]              
	int                                                m_nEffectiveRadiusIndex;                          		// 0x0118 (0x0004) [0x0000000000000000]              
	int                                                s_nPetLifeSpanIndex;                              		// 0x011C (0x0004) [0x0000000000000000]              
	int                                                s_nProjectileSpeedIndex;                          		// 0x0120 (0x0004) [0x0000000000000000]              
	int                                                s_nRequiredMoralePointsIndex;                     		// 0x0124 (0x0004) [0x0000000000000000]              
	float                                              m_fPowerPoolCost;                                 		// 0x0128 (0x0004) [0x0000000000000000]              
	float                                              m_fPowerPoolMinCost;                              		// 0x012C (0x0004) [0x0000000000000000]              
	float                                              m_fPowerPoolCostBlock;                            		// 0x0130 (0x0004) [0x0000000000000000]              
	float                                              m_fFireTime;                                      		// 0x0134 (0x0004) [0x0000000000000000]              
	float                                              m_fEquipTime;                                     		// 0x0138 (0x0004) [0x0000000000000000]              
	float                                              m_fBuildupTime;                                   		// 0x013C (0x0004) [0x0000000000000000]              
	float                                              m_fTimeToHoldBlock;                               		// 0x0140 (0x0004) [0x0000000000000000]              
	float                                              s_fMaxControlRange;                               		// 0x0144 (0x0004) [0x0000000000000000]              
	int                                                m_nShotsPerFire;                                  		// 0x0148 (0x0004) [0x0000000000000000]              
	float                                              m_fTeamPassthroughDistance;                       		// 0x014C (0x0004) [0x0000000000000000]              
	float                                              m_fMeleeHitTime;                                  		// 0x0150 (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmDamageTypeClass;                              		// 0x0154 (0x0008) [0x0000000000000000]              
	float                                              m_fFullBodyAnimTime;                              		// 0x015C (0x0004) [0x0000000000000000]              
	int                                                s_nNumProgressions;                               		// 0x0160 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1347 ];

		return pClassPointer;
	};

	bool SpawnPetFire ( );
	float eventGetConeAttackAngle ( );
	float GetAimChargeBuildupTime ( );
	float GetBuildupChargeTime ( );
	float eventGetContagiousRadius ( );
	void PayAccuracyForWeaponSwitch ( );
	void PayAccuracyForJump ( );
	void PayAccuracyForShot ( );
	float GetCooldownTime ( );
	float GetBuildupTime ( );
	float GetRefireTime ( );
	float GetTimeByAttackRate ( float fTime );
	float GetEquipModeTime ( );
	bool UseRemoteTrigger ( );
	bool IsConeAttack ( );
	bool IsSelfTargeter ( );
	bool eventIsFreeTargetMode ( );
	bool CheckForShieldHitAvoidance ( class AActor* Target, class UTgEffectGroup* EffectGroup );
	bool ShouldSituationalApplyEffect ( class ATgPawn* TargetPawn, class UTgEffectGroup* EffectGroup );
	bool ValidateApplyHit ( struct FImpactInfo Impact );
	void SubmitHitEffects ( class AActor* DamageInstigator, struct FImpactInfo Impact, unsigned char eSource, int nType, int nSituationalType );
	void ApplyHit ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	void TrackDeviceModeHit ( class ATgPawn* Hitter, float fDistance, unsigned long bHitPlayer );
	bool IsValidAOETarget ( class ATgPawn* P, struct FVector vHitLocation, float fRadius );
	void RemoveEffectType ( class AActor* Target, unsigned long bForceRemove, int nEffectGroupType );
	void ApplyEffectType ( class AActor* Target, int nEffectGroupType );
	struct FString GetTargetName ( class AActor* TargetActor );
	struct FImpactInfo CalcWeaponModeFire ( class AActor* DamageInstigator, struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	bool IsInConeWithDir ( struct FVector Dir, class AActor* TargetActor, struct FVector StartCone, float coneHalf );
	bool IsInCone ( class AActor* SourceActor, class AActor* TargetActor, struct FVector StartCone, float coneHalf );
	void CalcAoeFire ( class AActor* DamageInstigator, TArray< struct FImpactInfo >* ImpactList );
	bool IsTraceBlocked ( class AActor* DamageInstigator, class AActor* Target );
	void CalcConeFire ( class AActor* DamageInstigator, struct FVector StartTrace, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcArcingFire ( class AActor* DamageInstigator, struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	struct FImpactInfo CalcInstantFire ( class AActor* DamageInstigator, struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	float LinePointDist ( struct FVector A, struct FVector B, struct FVector pt );
	void eventDrawCheeseSlice ( class AActor* DamageInstigator, struct FVector FacingDir, struct FVector StartCone, float Radius, float ConeSetBack, float ConeAngle );
	void DrawPie ( struct FVector Center, float Radius, struct FVector Dir, float Angle );
	bool IsValidTraceTarget ( class AActor* P );
	void DisplayMessage ( struct FString sMessage );
	class ATgDevice* CheckSimutainousFiring ( );
	float GetAttackRate ( );
	int GetAttackRating ( );
	float eventGetInterruptionChance ( );
	float GetNetEffectiveRangeReduction ( struct FImpactInfo Impact, class AActor* DamageInstigator );
	void SubmitEffect ( struct FImpactInfo Impact, class UTgEffectGroup* EffectGroup, unsigned long bRemove );
	bool IsDecoyEffect ( );
	void Deactivate ( );
	void Activate ( );
	float GetShotPowerMinCost ( );
	float GetBlockPowerCost ( );
	float GetShotPowerCost ( );
	bool IsArcingAttack ( );
	bool IsRangedAttack ( );
	bool IsMeleeAttack ( );
	bool ShouldAddToImpactList ( class AActor* HitActor, TArray< struct FImpactInfo > ImpactList );
	bool IsInSlice ( class AActor* SourceActor, class AActor* TargetActor, struct FVector StartCone, float ConeAngle, float Radius );
	struct FImpactInfo CalcMeleeAttack ( class AActor* DamageInstigator, TArray< struct FImpactInfo >* ImpactList );
	bool IsBlockedByBlocker ( class AActor* DamageInstigator, class AActor* Target, class AActor* OriginActor );
	struct FImpactInfo GetTraceImpact ( class AActor* TraceActor, struct FVector StartTrace, struct FVector EndTrace );
	bool IsEnemy ( class AActor* TargetActor );
	bool IsSelfOrOwner ( class AActor* Target );
	bool IsValidTarget ( class AActor* P, unsigned char eTargeterType );
	bool CheckTeamPassThrough ( class AActor* HitActor );
	bool IsWithinEffectiveRange ( float fDistance );
	bool IsWithinRange ( float fDistance );
	float GetEffectiveRange ( );
	float GetMinRange ( );
	float GetRange ( );
	float GetRequiredMoralePoints ( );
	float GetProjectileSpeed ( );
	float GetDeployTime ( );
	float GetPetControlRange ( );
	float GetPetLifeSpan ( );
	float GetEffectiveRadius ( );
	float GetRemoteActivationTime ( );
	float GetDamageRadius ( );
	void RestoreAccuracy ( float fTimeStep );
	float GetTargetAccuracy ( );
	float GetAccuracy ( );
	bool WillFireTrackingMissile ( );
	bool WillSpawnStickyProjectile ( );
	bool LogDebugInfo ( );
	void VerifyProjectile ( );
	struct FString GetDeviceFireName ( );
	bool IsBlockedByGeometry ( class AActor* SourceActor, class AActor* TargetActor );
	struct FName QueryClass ( int nMode );
	class UTgEffectGroup* GetEffectGroup ( int nType, int* nIndex );
	float GetPropertyValueById ( int nPropertyId, int nPropertyIndex );
	float GetUnBuffedPropertyValueById ( int nPropertyId, int nPropertyIndex );
	float GetPropertyValue ( int nPropertyId );
	void CustomFire ( );
	void SpawnPet ( unsigned long bPet );
	void Deploy ( );
	void InitializeProjectile ( class AProjectile* Proj );
	class UClass* GetProjectileClass ( );
};

UClass* UTgDeviceFire::pClassPointer = NULL;

// Class TgGame.TgDeviceForm
// 0x00D8 (0x0114 - 0x003C)
class UTgDeviceForm : public UObject
{
public:
	class ATgPawn*                                     PawnOwner;                                        		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                c_nBehaviorType;                                  		// 0x0040 (0x0004) [0x0000000000000000]              
	struct FEquipDeviceInfo                            c_EquipDeviceInfo;                                		// 0x0044 (0x000C) [0x0000000000000000]              
	int                                                m_nDeviceType;                                    		// 0x0050 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bUsesDeployMode : 1;                            		// 0x0054 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bHandDevice : 1;                                		// 0x0054 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bUseOwnerSockets : 1;                           		// 0x0054 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bIsTransitioningToNewMode : 1;                  		// 0x0054 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bIsInFirstPerson : 1;                           		// 0x0054 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bDeployModeEnabled : 1;                         		// 0x0054 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      c_bUseInstigatorMesh : 1;                         		// 0x0054 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bInitializingAssets : 1;                        		// 0x0054 (0x0004) [0x0000000000000000] [0x00000080] 
	class UAnimSet*                                    c_DeviceAnimSetOverride;                          		// 0x0058 (0x0004) [0x0000000000000000]              
	TArray< class UAnimSet* >                          c_PawnAnimSetOverrideList;                        		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FModeData >                         ModeDatas;                                        		// 0x0068 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FPointer                                    m_pAmSetup;                                       		// 0x0074 (0x0004) [0x0000000000001000]              ( CPF_Native )
	class UMeshComponent*                              c_Mesh;                                           		// 0x0078 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMeshComponent*                              c_AttachedMesh;                                   		// 0x007C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FName                                       c_nmMountPoint;                                   		// 0x0080 (0x0008) [0x0000000000000000]              
	struct FDeviceAnimInfo                             c_CurrentDeviceAnimList;                          		// 0x0088 (0x0004) [0x0000000000000000]              
	int                                                c_nDamageLevel;                                   		// 0x008C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_DamageMIC;                                      		// 0x0090 (0x0004) [0x0000000000000000]              
	class UTgAnimBlendByRangeUseType*                  c_DeviceRangeAnimNodeBlendList;                   		// 0x0094 (0x0004) [0x0000000000000000]              
	class UAnimNodePlayCustomAnim*                     c_DeviceTransitionNode;                           		// 0x0098 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendByDeviceMode*                c_TransitionsAnimNode;                            		// 0x009C (0x0004) [0x0000000000000000]              
	struct FName                                       FormState;                                        		// 0x00A0 (0x0008) [0x0000000000000000]              
	int                                                c_nFireMode;                                      		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              c_fTimeToEquipDevice;                             		// 0x00AC (0x0004) [0x0000000000000000]              
	int                                                c_nLastFxMode;                                    		// 0x00B0 (0x0004) [0x0000000000000000]              
	int                                                c_nLastEquipSlot;                                 		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                c_nLastSocketIndex;                               		// 0x00B8 (0x0004) [0x0000000000000000]              
	struct FVector                                     c_vBaseFirstPersonTranslation;                    		// 0x00BC (0x000C) [0x0000000000000000]              
	struct FVector                                     c_vCustomFirstPersonTranslation;                  		// 0x00C8 (0x000C) [0x0000000000000000]              
	struct FVector                                     c_vCustomFirstPersonRotation;                     		// 0x00D4 (0x000C) [0x0000000000000000]              
	class ATgSkeletalMeshActor*                        c_DeployModeMeshIndicator;                        		// 0x00E0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_DeployModeFxOK;                                 		// 0x00E4 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_DeployModeFxNotOK;                              		// 0x00E8 (0x0004) [0x0000000000000000]              
	unsigned char                                      c_bDeployModeStatus;                              		// 0x00EC (0x0001) [0x0000000000000000]              
	class UTgSpecialFx*                                c_ArcFx;                                          		// 0x00F0 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_ArcFxSuccessfulHit;                             		// 0x00F4 (0x0004) [0x0000000000000000]              
	int                                                m_CurrentSituationalAttackType;                   		// 0x00F8 (0x0004) [0x0000000000000000]              
	struct FName                                       c_nmContinuousFire;                               		// 0x00FC (0x0008) [0x0000000000000000]              
	struct FName                                       c_nmContinuousHit;                                		// 0x0104 (0x0008) [0x0000000000000000]              
	class UObjectReferencer*                           m_AssetReference;                                 		// 0x010C (0x0004) [0x0000000000000000]              
	class AActor*                                      m_OwnerActor;                                     		// 0x0110 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1348 ];

		return pClassPointer;
	};

	void eventStopFire ( int nFireModeNum );
	void eventOnBlockBreakAnimDone ( );
	void eventOnRetrieveAnimDone ( );
	void eventGotoFormState ( struct FName NewState, int nNewFireMode );
	void EndCurrentState ( );
	void eventAttachAndDeploy_DA ( );
	void eventDeviceAnimNotify ( );
	void eventBlockFx ( int nFireModeNum );
	void eventBlockDone ( int nFireModeNum );
	void eventBlockStart ( int nFireModeNum );
	void eventDoInterrupt ( );
	void eventCooldownComplete ( );
	void eventCooldown ( int nFireModeNum );
	void eventFire ( struct FVector HitLocation, int nFireMode, int seqIndex, int nEquipSlot, int nSocketIndex, unsigned long bSuccessfulHit, unsigned long bSecondaryShotOfMultiFire, int SituationalAttackType, float fRefireTime );
	void eventStartFire ( struct FVector HitLocation, int nFireMode, int seqIndex, int nEquipSlot, int nSocketIndex, unsigned long bSuccessfulHit, unsigned long bSecondaryShotOfMultiFire, int SituationalAttackType, float fRefireTime );
	void SetNameOfFireAnimation ( );
	bool eventIsCurrentInHandWeapon ( );
	class UTgDeviceForm* InHandWeaponForm ( );
	void eventBuildUp ( int nFireMode, int nEquipSlot, int nSocketIndex );
	void eventSetFireMode ( int nFireMode, unsigned long Force );
	void eventExitDeployMode ( );
	void eventEnterDeployMode ( );
	void EndDevicePuttingDown ( );
	void PutAway ( float putAwayTime );
	void eventBeginDeviceTakingOut ( int DesiredInHandMode, unsigned long PlayEquipAnim );
	void eventBeginActive ( int desiredIdleState );
	void eventPlayImpactEffects ( struct FVector HitLocation, int nEquipSlot, int nSocketIndex, unsigned long bSuccessfulHit, struct FVector FireOrigin );
	void eventStopContinuousHitFx ( );
	void eventUpdateContinuousHitFx ( struct FVector HitLocation );
	void eventUpdateContinuousFireFx ( struct FVector HitLocation );
	bool IsOffhandJetpack ( );
	void GetCurrentUsedResourceList ( TArray< struct FString > List );
	void RecalculateMaterial ( );
	void UpdateDeployModeLocation ( struct FVector NewLocation, struct FRotator NewRotation );
	void UpdateDeployModeStatus ( unsigned char Status );
	class UTgSpecialFx* SpawnSpecialFxIndependent ( int nSpecialFxId, int nHideMask );
	void ResetAfterRagDoll ( );
	void Destruct ( struct FVector vLocation );
	void PlayDeployAnimation ( );
	void PlaySoundAt ( class USoundCue* ASound, struct FVector SourceLocation );
	bool AllowImpactEffects ( class AActor* HitActor, struct FVector HitLocation, struct FVector HitNormal );
	void SpawnArcingTracer ( struct FVector HitLocation, struct FVector HitOrigin, unsigned long bSuccessfulHit );
	void SpawnFxTracer ( int nFireModeNum, struct FVector HitLocation, int nEquipSlot, int nSocketIndex, unsigned long bHitTracer );
	void DeactivateFxGroup ( struct FName nmGroup, int nFireModeNum, int nEquipSlot, int nSocketIndex );
	class UTgSpecialFx* ActivateFxIndependent ( struct FName nmGroup, int nFireModeNum, unsigned long bSkipActivate, int nHideMask );
	void ActivateFxGroup ( struct FName nmGroup, int nFireModeNum, int nEquipSlot, int nSocketIndex, float Duration );
	bool UsesSuitDye ( );
	bool IsBackpack ( );
	bool IsJetpack ( );
	bool LogDebugInfo ( );
	void FormManageFirstPersonWeapon ( unsigned long bOn );
	void ResetDeviceAnimNodes ( );
	void DeviceAddRemoveAnimSet ( class UAnimSet* pAnimSet, unsigned long bAdd );
	void InitDeviceAnimNodes ( );
	void SetVisibility ( unsigned long bVisible );
	void DetachInHandDevice_DA ( );
	void DetachDevice_DA ( class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh );
	bool AttachInHandDevice_DA ( unsigned long bFirstPerson );
	void AttachDevice_DA ( class USkeletalMeshComponent* ParentMesh, class UMeshComponent* AttachedMesh, struct FName nmSocket );
	void SetSkin ( class UMaterial* NewMaterial );
};

UClass* UTgDeviceForm::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_NewMelee
// 0x0004 (0x0118 - 0x0114)
class UTgDeviceForm_NewMelee : public UTgDeviceForm
{
public:
	int                                                c_DesiredMode;                                    		// 0x0114 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1349 ];

		return pClassPointer;
	};

	void eventBuildUp ( int nFireMode, int nEquipSlot, int nSocketIndex );
	void eventBeginActive ( int desiredIdleState );
	void EndCurrentState ( );
	void PutAway ( float putAwayTime );
	void eventBeginDeviceTakingOut ( int DesiredInHandMode, unsigned long PlayEquipAnim );
	void eventStopFire ( int nFireModeNum );
	void eventFire ( struct FVector HitLocation, int nFireMode, int seqIndex, int nEquipSlot, int nSocketIndex, unsigned long bSuccessfulHit, unsigned long bSecondaryShotOfMultiFire, int SituationalAttackType, float fRefireTime );
	void eventSetFireMode ( int nFireMode, unsigned long Force );
};

UClass* UTgDeviceForm_NewMelee::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_MeleeDualWield
// 0x0004 (0x011C - 0x0118)
class UTgDeviceForm_MeleeDualWield : public UTgDeviceForm_NewMelee
{
public:
	class UTgSkeletalMeshComponent*                    c_LeftHandMesh;                                   		// 0x0118 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1350 ];

		return pClassPointer;
	};

	void SetVisibility ( unsigned long bVisible );
	void DetachInHandDevice_DA ( );
	bool AttachInHandDevice_DA ( unsigned long bFirstPerson );
};

UClass* UTgDeviceForm_MeleeDualWield::pClassPointer = NULL;

// Class TgGame.TgDeviceForm_NewRange
// 0x0004 (0x0118 - 0x0114)
class UTgDeviceForm_NewRange : public UTgDeviceForm
{
public:
	int                                                c_DesiredMode;                                    		// 0x0114 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1351 ];

		return pClassPointer;
	};

	void eventBeginActive ( int desiredIdleState );
	void PutAway ( float putAwayTime );
	void eventBeginDeviceTakingOut ( int DesiredInHandMode, unsigned long PlayEquipAnim );
	void eventStopFire ( int nFireModeNum );
	void eventFire ( struct FVector HitLocation, int nFireMode, int seqIndex, int nEquipSlot, int nSocketIndex, unsigned long bSuccessfulHit, unsigned long bSecondaryShotOfMultiFire, int SituationalAttackType, float fRefireTime );
	void eventBuildUp ( int nFireMode, int nEquipSlot, int nSocketIndex );
	void eventSetFireMode ( int nFireMode, unsigned long Force );
};

UClass* UTgDeviceForm_NewRange::pClassPointer = NULL;

// Class TgGame.TgDeployable
// 0x0158 (0x0324 - 0x01CC)
class ATgDeployable : public AActor
{
public:
	int                                                r_nDeployableId;                                  		// 0x01CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      c_bInitialized : 1;                               		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bConsumedOnFire : 1;                            		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bInstantFire : 1;                               		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      r_bTakeDamage : 1;                                		// 0x01D0 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      c_bDisplayHealth : 1;                             		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bInDestroyedState : 1;                          		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      s_bDestroyedThisTick : 1;                         		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      s_bServerWillDetonateThisTick : 1;                		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      s_bIsActivated : 1;                               		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bIsDeployed : 1;                                		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bRequireLOS : 1;                                		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bEnemyMatLoaded : 1;                            		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      s_bWasPickedUp : 1;                               		// 0x01D0 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bPickupConsumeOnDeath : 1;                      		// 0x01D0 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bPickupConsumeOnUse : 1;                        		// 0x01D0 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bPickupOnlyOnce : 1;                            		// 0x01D0 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                   		// 0x01D0 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      r_bDelayDeployed : 1;                             		// 0x01D0 (0x0004) [0x0000000000000020] [0x00020000] ( CPF_Net )
	unsigned long                                      c_bStatRendered : 1;                              		// 0x01D0 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_bOverrideTargetComponentHeight : 1;             		// 0x01D0 (0x0004) [0x0000000000000001] [0x00080000] ( CPF_Edit )
	unsigned long                                      r_bInitialIsEnemy : 1;                            		// 0x01D0 (0x0004) [0x0000000000000020] [0x00100000] ( CPF_Net )
	int                                                m_nDeployableType;                                		// 0x01D4 (0x0004) [0x0000000000000000]              
	int                                                r_nPhysicalType;                                  		// 0x01D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nHealth;                                        		// 0x01DC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgEffectManager*                            r_EffectManager;                                  		// 0x01E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgEffectGroup*                              m_EquipEffect;                                    		// 0x01E4 (0x0004) [0x0000000000000000]              
	float                                              s_fProximityRadius;                               		// 0x01E8 (0x0004) [0x0000000000000000]              
	float                                              r_fClientProximityRadius;                         		// 0x01EC (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgProperty* >                       s_Properties;                                     		// 0x01F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FName                                       c_nmName;                                         		// 0x01FC (0x0008) [0x0000000000000000]              
	class UTgDeviceForm*                               c_Form;                                           		// 0x0204 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_FireFx;                                         		// 0x0208 (0x0004) [0x0000000000000000]              
	class UTgImpactFx*                                 c_FireImpact;                                     		// 0x020C (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              c_Mesh;                                           		// 0x0210 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AActor*                                      m_Target;                                         		// 0x0214 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_vFlashLocation;                                 		// 0x0218 (0x000C) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nFlashCount;                                    		// 0x0224 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nFlashFireCount;                                		// 0x0225 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_nPreviousFlashFireCount;                        		// 0x0226 (0x0001) [0x0000000000000000]              
	class UTgDeviceFire*                               m_FireMode;                                       		// 0x0228 (0x0004) [0x0000000000000000]              
	int                                                m_FireSkillId;                                    		// 0x022C (0x0004) [0x0000000000000000]              
	float                                              m_fStateTime;                                     		// 0x0230 (0x0004) [0x0000000000000000]              
	int                                                c_nVisibleToLocalPlayer[ 0x2 ];                   		// 0x0234 (0x0008) [0x0000000000000000]              
	class ATgPawn*                                     m_TouchedPlayer;                                  		// 0x023C (0x0004) [0x0000000000000000]              
	class ATgActorFactory*                             s_DeployFactory;                                  		// 0x0240 (0x0004) [0x0000000000000000]              
	int                                                m_TimeCreated;                                    		// 0x0244 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              m_DestroyedMesh;                                  		// 0x0248 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fLifeAfterDeathSecs;                            		// 0x024C (0x0004) [0x0000000000000000]              
	int                                                m_nGlobalAlarmId;                                 		// 0x0250 (0x0004) [0x0000000000000000]              
	int                                                r_nReplicateDestroyIt;                            		// 0x0254 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fPersistTime;                                   		// 0x0258 (0x0004) [0x0000000000000000]              
	float                                              s_fActivationTime;                                		// 0x025C (0x0004) [0x0000000000000000]              
	int                                                m_nSensorConfigId;                                		// 0x0260 (0x0004) [0x0000000000000000]              
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x0264 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              m_fDefaultDeployAnimLength;                       		// 0x026C (0x0004) [0x0000000000000000]              
	float                                              r_fTimeToDeploySecs;                              		// 0x0270 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fInitDeployTime;                                		// 0x0274 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fCurrentDeployPercentage;                       		// 0x0278 (0x0004) [0x0000000000000000]              
	float                                              r_fDeployRate;                                    		// 0x027C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fCurrentDeployTime;                             		// 0x0280 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fLastDeployedHealth;                            		// 0x0284 (0x0004) [0x0000000000000000]              
	float                                              m_fDamagedDuringDeploy;                           		// 0x0288 (0x0004) [0x0000000000000000]              
	float                                              m_BaseEyeHeight;                                  		// 0x028C (0x0004) [0x0000000000000000]              
	int                                                r_nTickingTime;                                   		// 0x0290 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fStartTickingTime;                              		// 0x0294 (0x0004) [0x0000000000000000]              
	float                                              s_fUseDeviceChance;                               		// 0x0298 (0x0004) [0x0000000000000000]              
	int                                                s_nLootTableId;                                   		// 0x029C (0x0004) [0x0000000000000000]              
	int                                                s_nVulnerableToAttackFlag;                        		// 0x02A0 (0x0004) [0x0000000000000000]              
	int                                                m_nPickupDeviceId;                                		// 0x02A4 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               s_SpawnerDeviceMode;                              		// 0x02A8 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   r_Owner;                                          		// 0x02AC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nOwnerFireMode;                                 		// 0x02B0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgHexItemInstance*                          s_HexItem;                                        		// 0x02B4 (0x0004) [0x0000000000000000]              
	float                                              AlwaysRelevantDistanceSquared;                    		// 0x02B8 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_DeployableTagMIC;                               		// 0x02BC (0x0004) [0x0000000000000000]              
	int                                                c_nDeployableMICResId;                            		// 0x02C0 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MaterialHealthBarMIC;                           		// 0x02C4 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MaterialDeployBarMIC;                           		// 0x02C8 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MaterialHealthBarParent;                        		// 0x02CC (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MaterialDeployBarParent;                        		// 0x02D0 (0x0004) [0x0000000000000000]              
	class UCylinderComponent*                          m_TargetComponent;                                		// 0x02D4 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_TargetCollisionTraceDistance;                   		// 0x02D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fOverriddenTargetComponentHeight;               		// 0x02DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgPawn*                                     m_LastDamager;                                    		// 0x02E0 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_SecondToLastDamager;                            		// 0x02E4 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_LastDebuffer;                                   		// 0x02E8 (0x0004) [0x0000000000000000]              
	int                                                m_LastDamagerTimeStamp;                           		// 0x02EC (0x0004) [0x0000000000000000]              
	int                                                m_SecondToLastDamagerTimeStamp;                   		// 0x02F0 (0x0004) [0x0000000000000000]              
	int                                                m_LastDebufferTimeStamp;                          		// 0x02F4 (0x0004) [0x0000000000000000]              
	class ATgRepInfo_Deployable*                       r_DRI;                                            		// 0x02F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< struct FDamageDisplay >                    c_DamageDisplayList;                              		// 0x02FC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   c_MatTextMIC;                                     		// 0x0308 (0x0004) [0x0000000000000000]              
	class UFont*                                       c_MatTextFont;                                    		// 0x030C (0x0004) [0x0000000000000000]              
	int                                                c_nMatTextMICResId;                               		// 0x0310 (0x0004) [0x0000000000000000]              
	int                                                c_nMatTextFontResId;                              		// 0x0314 (0x0004) [0x0000000000000000]              
	float                                              c_fMatFontScale;                                  		// 0x0318 (0x0004) [0x0000000000000000]              
	class ATgPlayerController*                         c_LocalPC;                                        		// 0x031C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_DRIClass;                                       		// 0x0320 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1352 ];

		return pClassPointer;
	};

	void UpdateHealth ( int nCurrHealth );
	void eventInitReplicationInfo ( );
	bool CanBeRepaired ( );
	float GetSaveHealthPercent ( );
	bool PickUpDeployable ( class ATgPawn* pReceiver );
	unsigned char eventGetPickupEquipPoint ( );
	bool CanBePickedUp ( );
	bool CanApplyEffects ( );
	void HideMesh ( );
	void DrawDeployableIcon ( class APlayerController* PC, class UCanvas* Canvas, struct FVector ScreenLoc, float ScaleFactor );
	bool LoadDeployableIcon ( );
	bool ShouldDrawIcon ( );
	void eventPostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	struct FString GetDeployableNameById ( int deployableId );
	void DrawNewHealth ( class APlayerController* PC, class UCanvas* Canvas, struct FVector ScreenLoc, float ScaleFactor );
	void DrawHealth ( class APlayerController* PC, class UCanvas* Canvas, struct FVector ScreenLoc, float ScaleFactor );
	float GetSize ( );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void Destroyed ( );
	void CheckLocalPlayerWithinProximity ( );
	void Tick ( float DeltaSeconds );
	void eventDestroyIt ( unsigned long bSkipFx );
	void eventTornOff ( );
	void eventReplicatedEvent ( struct FName VarName );
	void TickDeploy ( float DeltaSeconds );
	float ExtractDeployTimeFromMyAnimation ( );
	void UpdateTimeToDeploySecs ( float fValue );
	void DeployComplete ( );
	void CalcDeployPercentage ( );
	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void RefireCheckTimer ( );
	void eventStartDeploy ( );
	bool CheckTargetWithinProximity ( );
	void eventDelayDeploy ( );
	void TimeDeviceFiring ( );
	bool IsFiring ( );
	void FlashLocationUpdated ( );
	void FlashCountUpdated ( );
	void eventPlayFireFx ( );
	void ClearFlashLocation ( );
	void SetFlashLocation ( struct FVector NewLoc );
	void ClearFlashCount ( );
	void IncrementFlashCount ( );
	void FireAmmunitionDeployable ( );
	bool ShouldRefire ( );
	struct FVector GetPhysicalFireAimDirection ( struct FVector fireLoc, struct FVector TargetLocation );
	struct FVector GetPhysicalFireStartLoc ( );
	class AProjectile* ProjectileFireDeployable ( );
	void ProcessInstantHit ( struct FImpactInfo Impact );
	void InstantFireDeployable ( );
	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	void DeviceFired ( );
	void eventStopFire ( );
	void eventStartFire ( );
	bool ShouldStartFire ( );
	class ATgPlayerController* eventGetLocalPlayerController ( );
	void OnGetTaskForceNumber ( class UTgSeqAct_GetTaskForceNumber* Action );
	bool CheckPlayerInfo ( class ATgRepInfo_Player* PlayerInfo );
	void CheckTouchedPlayer ( );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ProcessEffect ( class UTgEffectGroup* Effect, unsigned long bRemove, class AActor* aInstigator, struct FImpactInfo Impact );
	void eventApplyEquipEffects ( );
	int eventGetDeployableUniqueId ( );
	void eventPostBeginPlay ( );
	bool IsFriendlyWithLocalPawn ( );
	void DisplayDamageInfo ( class UCanvas* Canvas, struct FVector ScreenLocation );
	int GetFireDeviceSkillId ( );
	int GetSpawnerDeviceInstanceId ( );
	int GetSpawnerDeviceSkillId ( );
	void SetTaskForceNumber ( int nTaskForceId );
	int GetTaskForceNumber ( );
	class ATgRepInfo_TaskForce* GetTaskForce ( );
	void SetInitialHealthPercent ( float fPercent );
	void SetHexItem ( class UTgHexItemInstance* newHexItem );
	void AddDamageInfo ( class ATgPawn* SourcePawn, struct FString DamageString, unsigned char Type );
	void UpdateDebuffer ( class ATgPawn* Debuffer );
	void UpdateDamagers ( class ATgPawn* Damager );
	void UpdateTargetCylinder ( );
	float CalcMeshOffset ( );
	void AdjustMeshToGround ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn );
	void NotifyGroupChanged ( );
	int GetMaxDeployHealth ( );
	int GetMaxHealth ( );
	void DeployableDestroyed ( );
	bool IsInLOS ( class AActor* TouchedActor );
	void SwapMeshToDestroyed ( );
	void ResetProperties ( );
	void SetProperty ( int nPropertyId, float fNewValue );
	class UTgProperty* GetProperty ( int nPropertyId );
	void AddProperty ( int nPropId, float fBase, float fRaw, float FMin, float FMax );
	void InitializeDefaultProps ( );
	bool ApplyDeployableSetup ( );
};

UClass* ATgDeployable::pClassPointer = NULL;

// Class TgGame.TgDeploy_Artillery
// 0x001C (0x0340 - 0x0324)
class ATgDeploy_Artillery : public ATgDeployable
{
public:
	float                                              s_fTargetRadius;                                  		// 0x0324 (0x0004) [0x0000000000000000]              
	float                                              s_fStartHeight;                                   		// 0x0328 (0x0004) [0x0000000000000000]              
	float                                              s_fDeflectionDegrees;                             		// 0x032C (0x0004) [0x0000000000000000]              
	unsigned char                                      s_eArtilleryType;                                 		// 0x0330 (0x0001) [0x0000000000000000]              
	struct FVector                                     s_fCurrentAimLocation;                            		// 0x0334 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1353 ];

		return pClassPointer;
	};

	struct FVector GetPhysicalFireAimDirection ( struct FVector fireLoc, struct FVector TargetLocation );
	struct FVector GetPhysicalFireStartLoc ( );
	struct FVector CalcAimLocation ( class AActor* Target );
	void FireAmmunitionDeployable ( );
	bool ShouldStartFire ( );
	void DeployComplete ( );
	class ATgMissionObjective* FindActiveObjective ( );
	class ATgPawn* FindEnemyPlayer ( );
	class AActor* FindTarget ( );
};

UClass* ATgDeploy_Artillery::pClassPointer = NULL;

// Class TgGame.TgDeploy_Beacon
// 0x000C (0x0330 - 0x0324)
class ATgDeploy_Beacon : public ATgDeployable
{
public:
	struct FString                                     m_Name;                                           		// 0x0324 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1354 ];

		return pClassPointer;
	};

	bool PickUpDeployable ( class ATgPawn* pReceiver );
	void StopFire ( );
	void StartFire ( );
	void eventSetActiveState ( );
	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void Destroyed ( );
	void DestroyIt ( unsigned long bSkipFx );
	void SendBeaconDestroyedMessage ( class ATgRepInfo_TaskForce* tfri, class ATgPawn* destroyer );
};

UClass* ATgDeploy_Beacon::pClassPointer = NULL;

// Class TgGame.TgDeploy_BeaconEntrance
// 0x0008 (0x032C - 0x0324)
class ATgDeploy_BeaconEntrance : public ATgDeployable
{
public:
	float                                              m_nDelay;                                         		// 0x0324 (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bActive : 1;                                    		// 0x0328 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1355 ];

		return pClassPointer;
	};

	void RecheckActiveTimer ( );
	bool HasExit ( );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventUpdateLocalFx ( );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
};

UClass* ATgDeploy_BeaconEntrance::pClassPointer = NULL;

// Class TgGame.TgDeploy_DestructibleCover
// 0x0004 (0x0328 - 0x0324)
class ATgDeploy_DestructibleCover : public ATgDeployable
{
public:
	unsigned long                                      r_bHasFired : 1;                                  		// 0x0324 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1356 ];

		return pClassPointer;
	};

	bool ShouldTakeDamageFromAttack ( int nDeviceAttackType );
	bool ShouldStartFire ( );
	void CheckDeathBehavior ( );
	void StartFire ( );
	void DestroyIt ( unsigned long SkipFx );
	void SpawnLoot ( );
};

UClass* ATgDeploy_DestructibleCover::pClassPointer = NULL;

// Class TgGame.TgDeploy_ForceField
// 0x001C (0x0340 - 0x0324)
class ATgDeploy_ForceField : public ATgDeployable
{
public:
	int                                                m_nDamageBlocked[ 0x3 ];                          		// 0x0324 (0x000C) [0x0000000000000000]              
	unsigned long                                      m_bBlockFriendlyFire : 1;                         		// 0x0330 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FVector                                     m_vExtent;                                        		// 0x0334 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1357 ];

		return pClassPointer;
	};

	bool CanBeRepaired ( );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void StopFire ( );
	void StartFire ( );
	void eventSetActiveState ( );
	float GetDamageReduction ( int nDamageType );
	void Destroyed ( );
	void eventPostBeginPlay ( );
	void AdjustMeshToGround ( );
};

UClass* ATgDeploy_ForceField::pClassPointer = NULL;

// Class TgGame.TgDeploy_Sensor
// 0x003C (0x0360 - 0x0324)
class ATgDeploy_Sensor : public ATgDeployable
{
public:
	TArray< class ATgPawn* >                           m_TouchedPlayers;                                 		// 0x0324 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nTouchedPlayerCount;                            		// 0x0330 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nCounter;                                       		// 0x0334 (0x0004) [0x0000000000000000]              
	float                                              c_fSensorTriggerTime;                             		// 0x0338 (0x0004) [0x0000000000000000]              
	int                                                r_nSensorAudioWarning;                            		// 0x033C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fProximityDistance;                             		// 0x0340 (0x0004) [0x0000000000000000]              
	int                                                c_nAlertSoundFxId;                                		// 0x0344 (0x0004) [0x0000000000000000]              
	TArray< struct FDeploySensorConfig >               m_DeploySensorConfig;                             		// 0x0348 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgCollisionProxy* >                 s_CollisionProxies;                               		// 0x0354 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1358 ];

		return pClassPointer;
	};

	void SendWarning ( class ATgPawn* TouchedPlayer );
	void DestroyIt ( unsigned long bSkipFx );
	void RemoveAllPlayersFromList ( unsigned long bForceClear );
	void RecalcSensorAlertLevel ( class ATgPawn* Pawn, int nActionFlag, int nTriggerEventFlag, unsigned long bRemove );
	int GeneratePawnFlag ( class ATgPawn* P );
	bool RemovePlayerFromList ( class ATgPawn* Pawn, int indx );
	bool AddPlayerToList ( class ATgPawn* P, int indx );
	bool ShouldPawnTriggerSensor ( int nPawnFlag, int indx );
	void ClearCounter ( );
	void UpdateCounter ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool eventShouldTriggerAudioWarning ( class ATgPawn* P, int nActionFlag );
	void CheckPlayersWithInProximity ( );
	void eventUnTouch ( class AActor* Other );
	void eventPostBeginPlay ( );
};

UClass* ATgDeploy_Sensor::pClassPointer = NULL;

// Class TgGame.TgDeploy_SweepSensor
// 0x0070 (0x0394 - 0x0324)
class ATgDeploy_SweepSensor : public ATgDeployable
{
public:
	class ATgEmitter*                                  c_BeamEffect;                                     		// 0x0324 (0x0004) [0x0000000000000000]              
	class UParticleSystemComponent*                    c_BeamPSC;                                        		// 0x0328 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_fBeamLength;                                    		// 0x032C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eSweepType;                                     		// 0x0330 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eSweepAxis;                                     		// 0x0331 (0x0001) [0x0000000000000000]              
	float                                              m_fSweepRate;                                     		// 0x0334 (0x0004) [0x0000000000000000]              
	int                                                m_nSweepRange;                                    		// 0x0338 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vStartLocation;                                 		// 0x033C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vEndLocation;                                   		// 0x0348 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vTargetLocation;                                		// 0x0354 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vCurrLocation;                                  		// 0x0360 (0x000C) [0x0000000000000000]              
	float                                              m_fStartRot;                                      		// 0x036C (0x0004) [0x0000000000000000]              
	float                                              m_fEndRot;                                        		// 0x0370 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetRot;                                     		// 0x0374 (0x0004) [0x0000000000000000]              
	float                                              m_fCurrRot;                                       		// 0x0378 (0x0004) [0x0000000000000000]              
	float                                              NetCullDistanceSquared;                           		// 0x037C (0x0004) [0x0000000000000000]              
	TArray< struct FTouchedPlayer >                    m_TouchedPlayers;                                 		// 0x0380 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nTouchInterval;                                 		// 0x038C (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bShowClientDebug : 1;                           		// 0x0390 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1359 ];

		return pClassPointer;
	};

	void FireAmmunitionDeployable ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void eventReplicatedEvent ( struct FName VarName );
	struct FImpactInfo CalcDeviceFire ( struct FVector StartTrace, struct FVector EndTrace, TArray< struct FImpactInfo >* ImpactList );
	void eventUnTouch ( class AActor* Other );
	bool ShouldStartFire ( );
	void Destroyed ( );
	void eventPostBeginPlay ( );
	void UpdateBeamEnd ( );
	void eventPostDeploySetup ( );
	void eventTick ( float DeltaTime );
	void InterpolateMoveRotation ( float DeltaTime );
	void InterpolateMoveLocation ( float DeltaTime );
	void eventBump ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitNormal );
	void eventBumpLevel ( );
	float GetMeshLength ( );
	void PostInitialize ( );
	void DrawClientDebug ( );
	bool ApplyDeployableSetup ( );
};

UClass* ATgDeploy_SweepSensor::pClassPointer = NULL;

// Class TgGame.TgProjectile
// 0x0080 (0x0288 - 0x0208)
class ATgProjectile : public AProjectile
{
public:
	class UTgDeviceFire*                               s_LastDefaultMode;                                		// 0x0208 (0x0004) [0x0000000000000000]              
	int                                                r_nProjectileId;                                  		// 0x020C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fDuration;                                      		// 0x0210 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fPersistTime;                                   		// 0x0214 (0x0004) [0x0000000000000000]              
	float                                              m_fPersistHitPulse;                               		// 0x0218 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              c_Mesh;                                           		// 0x021C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSpecialFx*                                c_ExplosionFx;                                    		// 0x0220 (0x0004) [0x0000000000000000]              
	class UTgImpactFx*                                 c_ImpactFx;                                       		// 0x0224 (0x0004) [0x0000000000000000]              
	class UTgImpactFx*                                 c_MeshImpactFx;                                   		// 0x0228 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bSuppressExplosionFX : 1;                       		// 0x022C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bRotationFollowsVelocity : 1;                   		// 0x022C (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bStickToWalls : 1;                              		// 0x022C (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bTrackTarget : 1;                               		// 0x022C (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bTrackToWorldLocation : 1;                      		// 0x022C (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bAimFromSocket : 1;                             		// 0x022C (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bHasExploded : 1;                               		// 0x022C (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bPIEInitialized : 1;                            		// 0x022C (0x0004) [0x0000000000000000] [0x00000080] 
	float                                              r_fAccelRate;                                     		// 0x0230 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_FiringOwnerStatsID;                             		// 0x0234 (0x0004) [0x0000000000000000]              
	int                                                c_FiringWeaponStatsID;                            		// 0x0238 (0x0004) [0x0000000000000000]              
	int                                                c_FiringWeaponMode;                               		// 0x023C (0x0004) [0x0000000000000000]              
	float                                              m_fTossZ;                                         		// 0x0240 (0x0004) [0x0000000000000000]              
	class AActor*                                      r_Owner;                                          		// 0x0244 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nOwnerFireModeId;                               		// 0x0248 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgDeviceFire*                               s_OwnerFireMode;                                  		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              r_fRange;                                         		// 0x0250 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fAcquireDistance;                               		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              m_fProximityDistance;                             		// 0x0258 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy*                           m_CollisionProxy;                                 		// 0x025C (0x0004) [0x0000000000000000]              
	int                                                s_nSpawnBotId;                                    		// 0x0260 (0x0004) [0x0000000000000000]              
	int                                                s_nSpawnDeployableId;                             		// 0x0264 (0x0004) [0x0000000000000000]              
	float                                              m_fDelayTrackSeconds;                             		// 0x0268 (0x0004) [0x0000000000000000]              
	float                                              m_fDamageRadius;                                  		// 0x026C (0x0004) [0x0000000000000000]              
	struct FVector                                     r_vSpawnLocation;                                 		// 0x0270 (0x000C) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fMinTravelRange;                                		// 0x027C (0x0004) [0x0000000000000000]              
	int                                                s_nSpawnTime;                                     		// 0x0280 (0x0004) [0x0000000000000000]              
	class UDynamicLightEnvironmentComponent*           LightEnvironment;                                 		// 0x0284 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1360 ];

		return pClassPointer;
	};

	void PlayLandingSound ( class AActor* LandingHitActor );
	void eventReplicatedEvent ( struct FName VarName );
	void eventServerDetonate ( );
	bool ProjectileCalcCamera ( float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV );
	void MyOnParticleSystemFinished ( class UParticleSystemComponent* PSC );
	void Destroyed ( );
	void HideProjectile ( );
	void eventTornOff ( );
	void ShutDown ( );
	void SpawnExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal, struct FIMPACT_FX ImpactFx );
	void eventSpawnFlightEffects ( );
	void ExplodeOnTarget ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal );
	void Explode ( struct FVector HitLocation, struct FVector HitNormal );
	void ApplyHit ( class AActor* Target, struct FVector HitLocation, struct FVector HitNormal, int HitItem );
	bool CheckTeamPassThrough ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitRotation );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	bool IsOutsideMinRange ( );
	void SetAcceleration ( );
	bool ProximityReached ( class ATgPawn* P );
	bool IsInsideMinProxyRange ( );
	void RangeReached ( );
	void CheckProjectileRange ( );
	void Init ( struct FVector Direction );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void TimerExplode ( );
	void TimerPulse ( );
	void eventClientSetExplode ( );
	void StartPulse ( );
	void eventPostProjectileInitialize ( );
	void PostBeginPlay ( );
	float GetBuffedRange ( );
};

UClass* ATgProjectile::pClassPointer = NULL;

// Class TgGame.TgProj_Bounce
// 0x000C (0x0294 - 0x0288)
class ATgProj_Bounce : public ATgProjectile
{
public:
	float                                              m_fMaxSpeed;                                      		// 0x0288 (0x0004) [0x0000000000000000]              
	float                                              m_fMinSpeed;                                      		// 0x028C (0x0004) [0x0000000000000000]              
	float                                              m_fMaxRange;                                      		// 0x0290 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1361 ];

		return pClassPointer;
	};

	void Destroyed ( );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void AdjustedInit ( struct FVector StartLocation, struct FVector HitLocation );
	void SetSpeed ( float Distance );
	bool SuggestProjVelocity ( struct FVector End, struct FVector Start, float projSpeed, float* BaseTossZ );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void MyOnParticleSystemFinished ( class UParticleSystemComponent* PSC );
};

UClass* ATgProj_Bounce::pClassPointer = NULL;

// Class TgGame.TgProj_Grapple
// 0x0030 (0x02C4 - 0x0294)
class ATgProj_Grapple : public ATgProj_Bounce
{
public:
	class AEmitter*                                    c_GrappleEffect;                                  		// 0x0294 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_vTargetLocation;                                		// 0x0298 (0x000C) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_ClimbDir;                                       		// 0x02A4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_LookDir;                                        		// 0x02B0 (0x000C) [0x0000000000000000]              
	struct FName                                       c_nmBoneName;                                     		// 0x02BC (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1362 ];

		return pClassPointer;
	};

	void Destroyed ( );
	void eventReplicatedEvent ( struct FName VarName );
	void InitGrapple ( );
	void AdjustedInit ( struct FVector StartLocation, struct FVector HitLocation );
	void PostBeginPlay ( );
};

UClass* ATgProj_Grapple::pClassPointer = NULL;

// Class TgGame.TgProj_FreeGrenade
// 0x0008 (0x0290 - 0x0288)
class ATgProj_FreeGrenade : public ATgProjectile
{
public:
	unsigned long                                      m_bFFTouched : 1;                                 		// 0x0288 (0x0004) [0x0000000000000000] [0x00000001] 
	class ATgDeploy_ForceField*                        m_touchedFF;                                      		// 0x028C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1363 ];

		return pClassPointer;
	};

	void Destroyed ( );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void Timer ( );
	void ShutDown ( );
	void PostBeginPlay ( );
};

UClass* ATgProj_FreeGrenade::pClassPointer = NULL;

// Class TgGame.TgProj_Bot
// 0x0000 (0x0290 - 0x0290)
class ATgProj_Bot : public ATgProj_FreeGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1364 ];

		return pClassPointer;
	};

	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void SpawnExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal, struct FIMPACT_FX ImpactFx );
	void SpawnTheBot ( struct FVector HitLocation, class AActor* TargetActor );
	class ATgPawn* SpawnBot ( struct FVector vLocation );
};

UClass* ATgProj_Bot::pClassPointer = NULL;

// Class TgGame.TgProj_Deployable
// 0x0000 (0x0290 - 0x0290)
class ATgProj_Deployable : public ATgProj_FreeGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1365 ];

		return pClassPointer;
	};

	void RangeReached ( );
	void ServerDetonate ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void SpawnTheDeployable ( struct FVector HitLocation, class AActor* TargetActor, struct FVector HitNormal );
	class ATgDeployable* SpawnDeployable ( struct FVector vLocation, class AActor* TargetActor, struct FVector vNormal );
};

UClass* ATgProj_Deployable::pClassPointer = NULL;

// Class TgGame.TgProj_Mortar
// 0x0000 (0x0290 - 0x0290)
class ATgProj_Mortar : public ATgProj_FreeGrenade
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1366 ];

		return pClassPointer;
	};

	void ProcessTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
};

UClass* ATgProj_Mortar::pClassPointer = NULL;

// Class TgGame.TgProj_Missile
// 0x0038 (0x02C0 - 0x0288)
class ATgProj_Missile : public ATgProjectile
{
public:
	float                                              m_fDefaultExplosionRange;                         		// 0x0288 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vInitialDir;                                    		// 0x028C (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vInitialPos;                                    		// 0x0298 (0x000C) [0x0000000000000000]              
	class AActor*                                      r_aSeeking;                                       		// 0x02A4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nNumBounces;                                    		// 0x02A8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vTargetWorldLocation;                           		// 0x02AC (0x000C) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      s_bInitializedSeekingWorldLocation : 1;           		// 0x02B8 (0x0004) [0x0000000000000000] [0x00000001] 
	class UStaticMeshComponent*                        c_PhotonMesh;                                     		// 0x02BC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1367 ];

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	class ATgPlayerController* GetLocalPlayerPawn ( );
	void ShutDown ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void CheckAcquireRange ( );
	void CheckSeekingTarget ( );
	void PostBeginPlay ( );
	void CheckRange ( );
	void SetInitSeekingTarget ( class AActor* LockedTarget );
	void eventSetInitialState ( );
	int GetMaxNumBounces ( );
};

UClass* ATgProj_Missile::pClassPointer = NULL;

// Class TgGame.TgProj_Rocket
// 0x002C (0x02B4 - 0x0288)
class ATgProj_Rocket : public ATgProjectile
{
public:
	unsigned char                                      FlockIndex;                                       		// 0x0288 (0x0001) [0x0000000000000020]              ( CPF_Net )
	class ATgProj_Rocket*                              Flock[ 0x2 ];                                     		// 0x028C (0x0008) [0x0000000000000000]              
	float                                              FlockRadius;                                      		// 0x0294 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FlockStiffness;                                   		// 0x0298 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FlockMaxForce;                                    		// 0x029C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              FlockCurlForce;                                   		// 0x02A0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bCurl : 1;                                        		// 0x02A4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	struct FVector                                     Dir;                                              		// 0x02A8 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1368 ];

		return pClassPointer;
	};

	void FlockTimer ( );
	void eventReplicatedEvent ( struct FName VarName );
	void Destroyed ( );
	void Init ( struct FVector Direction );
};

UClass* ATgProj_Rocket::pClassPointer = NULL;

// Class TgGame.TgEmitter
// 0x0008 (0x01DC - 0x01D4)
class ATgEmitter : public AEmitter
{
public:
	struct FName                                       BoneName;                                         		// 0x01D4 (0x0008) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1369 ];

		return pClassPointer;
	};

	void ScaleEmitter ( float ScaleFactor );
	void AttachTo ( class APawn* P, struct FName NewBoneName );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgEmitter::pClassPointer = NULL;

// Class TgGame.TgImpactFx
// 0x0038 (0x0074 - 0x003C)
class UTgImpactFx : public UObject
{
public:
	float                                              c_fMaxFxDistance;                                 		// 0x003C (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bAlignToSurfaceNormal : 1;                      		// 0x0040 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FIMPACT_FX                                  c_EmptyImpact;                                    		// 0x0044 (0x0024) [0x0000000000000000]              
	TArray< struct FIMPACT_FX >                        c_Impacts;                                        		// 0x0068 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1370 ];

		return pClassPointer;
	};

	void ApplyImpact ( class AActor* Instigator, class AActor* HitActor, struct FVector HitLocation, struct FVector HitNormal, struct FIMPACT_FX Impact );
	struct FIMPACT_FX GetImpactFx ( class UPhysicalMaterial* HitMaterial );
	bool IsEffectRelevant ( class AActor* Viewer, struct FVector HitLocation );
};

UClass* UTgImpactFx::pClassPointer = NULL;

// Class TgGame.TgParticleModuleTypeDataLight
// 0x0008 (0x005C - 0x0054)
class UTgParticleModuleTypeDataLight : public UParticleModuleTypeDataBase
{
public:
	class UPointLightComponent*                        m_PointLightComponent;                            		// 0x0054 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UPointLightComponent*                        m_PLCDuplicate;                                   		// 0x0058 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1371 ];

		return pClassPointer;
	};

};

UClass* UTgParticleModuleTypeDataLight::pClassPointer = NULL;

// Class TgGame.TgPhysicalMaterialProperty
// 0x0008 (0x0044 - 0x003C)
class UTgPhysicalMaterialProperty : public UPhysicalMaterialPropertyBase
{
public:
	struct FName                                       MaterialType;                                     		// 0x003C (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1372 ];

		return pClassPointer;
	};

};

UClass* UTgPhysicalMaterialProperty::pClassPointer = NULL;

// Class TgGame.TgSoundGroup
// 0x0018 (0x0054 - 0x003C)
class UTgSoundGroup : public UObject
{
public:
	TArray< class USoundCue* >                         c_SoundCues;                                      		// 0x003C (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )
	TArray< struct FFootstepSoundInfo >                c_FootstepSounds;                                 		// 0x0048 (0x000C) [0x0000000000400002]              ( CPF_Const | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1373 ];

		return pClassPointer;
	};

	void PlayFootStepSound ( class APawn* P, int FootDown, struct FName MaterialType );
	void PlaySound ( unsigned char eSound, class APawn* P );
};

UClass* UTgSoundGroup::pClassPointer = NULL;

// Class TgGame.TgSpecialFx
// 0x0078 (0x00B4 - 0x003C)
class UTgSpecialFx : public UObject
{
public:
	int                                                c_nFxId;                                          		// 0x003C (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              c_OwnerMesh;                                      		// 0x0040 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class AActor*                                      c_Owner;                                          		// 0x0044 (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bAttached : 1;                                  		// 0x0048 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bSelfManage : 1;                                		// 0x0048 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bVisualComplete : 1;                            		// 0x0048 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bMuteSound : 1;                                 		// 0x0048 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bIsDebuff : 1;                                  		// 0x0048 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bHasTeamMaterials : 1;                          		// 0x0048 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      c_bActive : 1;                                    		// 0x0048 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      c_bIsSpawnFx : 1;                                 		// 0x0048 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      c_bUseBeam : 1;                                   		// 0x0048 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      c_bLocalPawnIsOwner : 1;                          		// 0x0048 (0x0004) [0x0000000000100000] [0x00000200] 
	int                                                c_nPriorityType;                                  		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                c_nPrioritySort;                                  		// 0x0050 (0x0004) [0x0000000000000000]              
	struct FName                                       c_nmSocket;                                       		// 0x0054 (0x0008) [0x0000000000000000]              
	struct FName                                       c_nmDisplayGroup;                                 		// 0x005C (0x0008) [0x0000000000000000]              
	int                                                c_nDisplayMode;                                   		// 0x0064 (0x0004) [0x0000000000000000]              
	int                                                c_nIndex;                                         		// 0x0068 (0x0004) [0x0000000000000000]              
	int                                                c_nEquipSlot;                                     		// 0x006C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MIC;                                            		// 0x0070 (0x0004) [0x0000000000000000]              
	float                                              c_fTransition;                                    		// 0x0074 (0x0004) [0x0000000000000000]              
	int                                                c_nHitEffectBase;                                 		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              c_fMaxEffectDistance;                             		// 0x007C (0x0004) [0x0000000000000000]              
	unsigned char                                      c_LightComponentState;                            		// 0x0080 (0x0001) [0x0000000000000000]              
	class ULightComponent*                             c_LightComponent;                                 		// 0x0084 (0x0004) [0x0000000004180008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FPointer                                    c_ManagedLightEmitter;                            		// 0x0088 (0x0004) [0x0000000000100000]              
	TArray< struct FFx_Sound >                         c_SoundList;                                      		// 0x008C (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	TArray< struct FFx_PSC >                           c_PSCList;                                        		// 0x0098 (0x000C) [0x0000000000480000]              ( CPF_Component | CPF_NeedCtorLink )
	TArray< struct FFx_Material >                      c_MaterialList;                                   		// 0x00A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgTimerManager*                             c_ActiveTimer;                                    		// 0x00B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1374 ];

		return pClassPointer;
	};

	void SetDepthPriorityGroup ( unsigned char NewDepthPriorityGroup );
	void SetKillOnDeactivate ( );
	void ListSounds ( );
	void eventUpdateBeamFx ( struct FVector HitLocation, struct FVector HitOrigin );
	void eventSpawnTracer ( struct FVector HitLocation, struct FVector HitOrigin );
	class AActor* GetHitActor ( struct FVector EffectLocation, struct FVector HitLocation );
	bool HasSoundCue ( );
	void StopSound ( );
	void PlaySound ( );
	void CheckDeactivate ( );
	void OnParticleSystemFinished ( class UParticleSystemComponent* FinishedComponent );
	void Deactivate ( unsigned long bForceDeactivate );
	float Activate ( struct FVector HitLocation, unsigned long bSkipRelevantChecking );
	void AdjustEffectScale ( int nPSCIndex, float fScale );
	void AdjustFxScaleByRadius ( float fScale );
	void AdjustEffectRadius ( int nPSCIndex, float fScale );
	class ATgPawn* FindLocalPlayerPawn ( );
	class ATgPlayerController* FindLocalPlayerController ( );
	bool IsFxRelevant ( struct FVector SpawnLocation );
	void SetHitEffectScaleBasedOnDamage ( int nHealthChange );
	class UAudioComponent* SpawnSound ( struct FVector Location );
	class ATgEmitter* SpawnEmitter ( struct FVector HitLocation, struct FVector HitNormal, float fScale );
	void CleanupRunningState ( );
	void SetPSCRunning ( class UParticleSystemComponent* pPSC, unsigned long bOn );
	bool AreAnyPSCRunning ( );
	void ResetParticles ( );
	void PlaySoundAt ( struct FVector Location );
	bool ShouldShowWhenStealthed ( );
	void SetHidden ( unsigned long bNewHidden );
	void AdjustHidden ( unsigned long bStealthed, unsigned long bFirstPerson );
	void OnActiveTimeExpired ( );
	void SetActiveTime ( float Duration, class ATgPawn* Owner );
	class AActor* SpawnActor ( class UClass* InClass, struct FVector Location, struct FRotator Rotation );
	void SetPSCHideMask ( class UParticleSystemComponent* PSC, unsigned long bOnlyAllowNonZeroMask );
	void ActivateLocalPlayerFx ( class UParticleSystemComponent* ActivePSC );
	bool RepairCulledFx ( class UParticleSystemComponent* ActivePSC );
	void CullFxUsingMask ( int MaskOfEmittersToDisable );
	void CullToLocalPlayerFx ( class UParticleSystemComponent* ActivePSC );
	class UMeshComponent* GetOwnerMesh ( class AActor* pOwner );
	struct FVector GetEffectLocation ( );
	void Detach ( );
	void AttachToOwner ( class AActor* pOwner );
	void Attach ( class UMeshComponent* pMesh, struct FName nmSocket, struct FName nmGroup, int nMode, int nIndex, int nEquipSlot );
};

UClass* UTgSpecialFx::pClassPointer = NULL;

// Class TgGame.TgSpecialFxLightManager
// 0x0028 (0x0064 - 0x003C)
class UTgSpecialFxLightManager : public UObject
{
public:
	unsigned long                                      c_FxLightsEnabled : 1;                            		// 0x003C (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      c_FxLightsUnconstrained : 1;                      		// 0x003C (0x0004) [0x0000000000004000] [0x00000002] ( CPF_Config )
	int                                                c_FxLightsMaxActive;                              		// 0x0040 (0x0004) [0x0000000000004000]              ( CPF_Config )
	int                                                c_FxLightsMaxDying;                               		// 0x0044 (0x0004) [0x0000000000004000]              ( CPF_Config )
	TArray< struct FPointer >                          m_ActiveEmitters;                                 		// 0x0048 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< struct FPointer >                          m_DyingEmitters;                                  		// 0x0054 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class ATgPawn*                                     c_LocalPawn;                                      		// 0x0060 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1375 ];

		return pClassPointer;
	};

	void UserSetLevel ( int LightLevel );
	void SetLevelInternal ( int LightLevel );
	void LightKilledElsewhere ( struct FPointer FxEmitterKilled );
	void SetLightState ( struct FPointer ExtantFxEmitter, unsigned char NewFxLightState );
	void AddLight ( struct FPointer NewFxEmitter );
	void InitializeFxLightManager ( );
};

UClass* UTgSpecialFxLightManager::pClassPointer = NULL;

// Class TgGame.TgEffect
// 0x0034 (0x0070 - 0x003C)
class UTgEffect : public UObject
{
public:
	class UTgEffectGroup*                              m_EffectGroup;                                    		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                m_nPropertyId;                                    		// 0x0040 (0x0004) [0x0000000000000000]              
	int                                                m_nCalcMethodCode;                                		// 0x0044 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bUseOnInterval : 1;                             		// 0x0048 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bRemovable : 1;                                 		// 0x0048 (0x0004) [0x0000000000000000] [0x00000002] 
	int                                                m_nPropertyValueId;                               		// 0x004C (0x0004) [0x0000000000000000]              
	float                                              m_fCurrent;                                       		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_fBase;                                          		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              m_fMinimum;                                       		// 0x0058 (0x0004) [0x0000000000000000]              
	float                                              m_fMaximum;                                       		// 0x005C (0x0004) [0x0000000000000000]              
	float                                              m_fStaticValueOffset;                             		// 0x0060 (0x0004) [0x0000000000000000]              
	float                                              m_MaxKnockbackZ;                                  		// 0x0064 (0x0004) [0x0000000000000000]              
	float                                              m_MinKnockbackZ;                                  		// 0x0068 (0x0004) [0x0000000000000000]              
	float                                              m_KnockbackZMultiplier;                           		// 0x006C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1376 ];

		return pClassPointer;
	};

	void ChargeModifier ( struct FImpactInfo Impact, float* NewValue );
	void eventRemove ( class AActor* Target, unsigned long bResetToFollow );
	void Reapply ( class AActor* Target );
	float GetProratedValue ( unsigned long bConvertDOT );
	void CheckSuperJump ( struct FImpactInfo Impact, class AActor* Target, float fNewValue );
	void ApplyToProperty ( class AActor* Target, int nPropertyId, float fProratedAmount, unsigned long bRemove );
	class UTgProperty* GetTargetProperty ( class AActor* Target, int nPropertyId );
	bool ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	bool IsValidInstigator ( class ATgPawn* InstigatorPawn );
	int GetDeviceIdFromMode ( class UTgDeviceFire* DeviceFireMode );
	bool CanBeApplied ( class AActor* Target );
	void SetProperty ( class AActor* Target, int nPropertyId, float fNewValue );
	void TrackStats ( class ATgPawn* Instigator, class AActor* Target, struct FImpactInfo Impact, float fDamage, int iTargetDeviceModeId, unsigned long bIsEnemy, float fMissingHealth );
	void CheckOwnerPetBuff ( int nPropertyId, float fCurrAmount, float* fNewAmount );
	void CheckEffectThreatModifier ( float* NewValue );
	void CheckEffectBuffModifier ( float* NewValue );
	class UTgEffect* CloneEffect ( );
};

UClass* UTgEffect::pClassPointer = NULL;

// Class TgGame.TgEffectDamage
// 0x0010 (0x0080 - 0x0070)
class UTgEffectDamage : public UTgEffect
{
public:
	class UClass*                                      m_DamageTypeClass;                                		// 0x0070 (0x0004) [0x0000000000000000]              
	class UClass*                                      m_DefaultDamageTypeClass;                         		// 0x0074 (0x0004) [0x0000000000000000]              
	float                                              m_fBuffedDamageInitial;                           		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              m_fSelfBuffedDamageInitial;                       		// 0x007C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1377 ];

		return pClassPointer;
	};

	void CheckDamageTakenModifier ( struct FImpactInfo Impact, float* fProratedAmount );
	void ProtectionModifier ( struct FImpactInfo Impact, unsigned long bSubmitMitigation, float* NewValue, float* fPercReduction );
	int Ceiling ( float fNumber );
	bool ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	void SendDamageMessages ( class AActor* Source, class AActor* Target, float fDamage, float fMitigated, struct FImpactInfo thisImpact );
	bool CanBeApplied ( class AActor* Target );
	void PostDamageHandler ( class AActor* pTarget, class ATgPawn* pInstigator, struct FImpactInfo Impact, float fHealthChange, float fBuffedDamage, float fMitigatedDamage );
	void SetDamageTypeClass ( );
};

UClass* UTgEffectDamage::pClassPointer = NULL;

// Class TgGame.TgEffectHeal
// 0x0004 (0x0074 - 0x0070)
class UTgEffectHeal : public UTgEffect
{
public:
	float                                              m_MissingHealthInitial;                           		// 0x0070 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1378 ];

		return pClassPointer;
	};

	void CheckSelfEffectBuffModifier ( class ATgPawn* Target, float* NewValue );
	bool ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	bool CanTargetBeRepaired ( class AActor* Target );
	bool CanBeApplied ( class AActor* Target );
	void AddHealingThreat ( float fHealthChange );
};

UClass* UTgEffectHeal::pClassPointer = NULL;

// Class TgGame.TgEffectSensor
// 0x0000 (0x0070 - 0x0070)
class UTgEffectSensor : public UTgEffect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1379 ];

		return pClassPointer;
	};

	void CalcSensorVisConfig ( class ATgPawn* PawnTarget, int nIndex );
	void ApplyScannerSetting ( class ATgPawn* PawnTarget );
	int GetPawnScannerSettingIndex ( class ATgPawn* PawnTarget );
	void Remove ( class AActor* Target, unsigned long bResetToFollow );
	bool ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	void GetSensorVisConfig ( int* nSeeFlag, int* nDisplayFlag );
};

UClass* UTgEffectSensor::pClassPointer = NULL;

// Class TgGame.TgEffectVisibility
// 0x0000 (0x0070 - 0x0070)
class UTgEffectVisibility : public UTgEffect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1380 ];

		return pClassPointer;
	};

	void Remove ( class AActor* Target, unsigned long bResetToFollow );
	class UTgProperty* GetTargetProperty ( class AActor* Target, int nPropertyId );
	bool ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
};

UClass* UTgEffectVisibility::pClassPointer = NULL;

// Class TgGame.TgEffectForm
// 0x002C (0x0068 - 0x003C)
class UTgEffectForm : public UObject
{
public:
	int                                                c_nEffectGroupId;                                 		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                c_nType;                                          		// 0x0040 (0x0004) [0x0000000000000000]              
	class AActor*                                      c_Owner;                                          		// 0x0044 (0x0004) [0x0000000000000000]              
	struct FPointer                                    c_pwzEffectName;                                  		// 0x0048 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    c_pwzDescription;                                 		// 0x004C (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                c_nEffectIconId;                                  		// 0x0050 (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_AppliedFxArray;                                 		// 0x0054 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      c_bHiddenDueToStealth : 1;                        		// 0x0060 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bHiddenDueToFirstPerson : 1;                    		// 0x0060 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bIsStealthGroup : 1;                            		// 0x0060 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bIsDebuff : 1;                                  		// 0x0060 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bIsShowStealthDelayed : 1;                      		// 0x0060 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bIsHideStealthDelayed : 1;                      		// 0x0060 (0x0004) [0x0000000000000000] [0x00000020] 
	int                                                c_nHealthChange;                                  		// 0x0064 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1381 ];

		return pClassPointer;
	};

	void AdjustHidden ( );
	void Detach ( );
	void HideEffectForm ( );
	void ShowEffectForm ( unsigned long bLocal );
	void RecalculateFx ( );
};

UClass* UTgEffectForm::pClassPointer = NULL;

// Class TgGame.TgEffectGroup
// 0x0104 (0x0140 - 0x003C)
class UTgEffectGroup : public UObject
{
public:
	int                                                m_nType;                                          		// 0x003C (0x0004) [0x0000000000000000]              
	int                                                m_nSituationalType;                               		// 0x0040 (0x0004) [0x0000000000000000]              
	float                                              m_fSituationalValue;                              		// 0x0044 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_Target;                                         		// 0x0048 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_Instigator;                                     		// 0x004C (0x0004) [0x0000000000000000]              
	int                                                m_nEffectGroupId;                                 		// 0x0050 (0x0004) [0x0000000000000000]              
	float                                              m_fLifeTime;                                      		// 0x0054 (0x0004) [0x0000000000000000]              
	float                                              m_fModLifeTime;                                   		// 0x0058 (0x0004) [0x0000000000000000]              
	float                                              m_fApplyInterval;                                 		// 0x005C (0x0004) [0x0000000000000000]              
	TArray< class UTgEffect* >                         m_Effects;                                        		// 0x0060 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nDamageType;                                    		// 0x006C (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eAttackType;                                    		// 0x0070 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bIsManaged : 1;                                 		// 0x0074 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bSkillEffect : 1;                               		// 0x0074 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bItemEffect : 1;                                		// 0x0074 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bEfficiencyEffect : 1;                          		// 0x0074 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bContagious : 1;                                		// 0x0074 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bDeviceSpecificFlag : 1;                        		// 0x0074 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bReflectDamage : 1;                             		// 0x0074 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bHasVisual : 1;                                 		// 0x0074 (0x0004) [0x0000000000000000] [0x00000080] 
	float                                              m_fPercAbsorbedDamage;                            		// 0x0078 (0x0004) [0x0000000000000000]              
	float                                              m_fPctDamageDecreaseDueToWeakSpot;                		// 0x007C (0x0004) [0x0000000000000000]              
	int                                                m_nApplicationType;                               		// 0x0080 (0x0004) [0x0000000000000000]              
	float                                              m_fApplicationValue;                              		// 0x0084 (0x0004) [0x0000000000000000]              
	float                                              m_fApplicationChance;                             		// 0x0088 (0x0004) [0x0000000000000000]              
	int                                                m_nCategoryCode;                                  		// 0x008C (0x0004) [0x0000000000000000]              
	int                                                m_nReqCategoryCode;                               		// 0x0090 (0x0004) [0x0000000000000000]              
	int                                                m_nRequiredSkillId;                               		// 0x0094 (0x0004) [0x0000000000000000]              
	int                                                m_nReqDeviceInstanceId;                           		// 0x0098 (0x0004) [0x0000000000000000]              
	float                                              m_fBuffValue;                                     		// 0x009C (0x0004) [0x0000000000000000]              
	int                                                m_nNumMaxStacks;                                  		// 0x00A0 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              s_NonContagiousEffectGroup;                       		// 0x00A4 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_pwzDeviceName;                                  		// 0x00A8 (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FPointer                                    m_pwzModeName;                                    		// 0x00AC (0x0004) [0x0000000000001000]              ( CPF_Native )
	struct FImpactInfo                                 m_SavedImpact;                                    		// 0x00B0 (0x0060) [0x0000000000080000]              ( CPF_Component )
	int                                                m_nPosture;                                       		// 0x0110 (0x0004) [0x0000000000000000]              
	int                                                m_nFxAppliedId;                                   		// 0x0114 (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmDisplayGroup;                                 		// 0x0118 (0x0008) [0x0000000000000000]              
	int                                                m_nHealth;                                        		// 0x0120 (0x0004) [0x0000000000000000]              
	int                                                m_nHealthMitigated;                               		// 0x0124 (0x0004) [0x0000000000000000]              
	int                                                s_ManagedEffectListIndex;                         		// 0x0128 (0x0004) [0x0000000000000000]              
	class ATgEffectManager*                            s_OwnerEffectManager;                             		// 0x012C (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmDamageTypeClass;                              		// 0x0130 (0x0008) [0x0000000000000000]              
	int                                                m_nSourceDeviceSkillId;                           		// 0x0138 (0x0004) [0x0000000000000000]              
	int                                                m_nSourceDeviceInstId;                            		// 0x013C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1382 ];

		return pClassPointer;
	};

	bool IsBuff ( );
	void LifeDone ( );
	void ApplyInterval ( );
	class UTgProperty* GetProperty ( class AActor* Target, int nPropertyId );
	float CalcProtection ( class AActor* Target, int nProtectionType, int nDeviceRating, float fValue, unsigned long bSubmitMitigation, float* fPercReduction );
	float CalcAttackTypeProtection ( class AActor* Target, int nAttackRating, float fValue, unsigned long bSubmitMitigation, float* fPercReduction );
	float CalcDamageTypeProtection ( class AActor* Target, int nAttackRating, float fValue, unsigned long bSubmitMitigation, float* fPercReduction );
	float CalcCategoryProtection ( class AActor* Target, int nAttackRating, float fValue, unsigned long bSubmitMitigation, float* fPercReduction );
	float ProtectionModifier ( struct FImpactInfo Impact );
	bool StartInterval ( struct FImpactInfo Impact );
	bool ReapplyEffects ( class AActor* Target );
	class AActor* DetermineActorToApplyEffectsTo ( );
	void ApplyPosture ( );
	bool ApplyEventBasedEffects ( class AActor* Target, struct FImpactInfo Impact );
	bool ApplyEffects ( struct FImpactInfo Impact );
	void ContagiousPulse ( struct FImpactInfo Impact );
	float eventGetEffectHealth ( struct FImpactInfo Impact );
	float eventGetLifeTime ( struct FImpactInfo Impact );
	float eventGetPercentTimeRemaining ( );
	float eventGetTimeRemaining ( );
	float eventGetTimeElapsed ( );
	float GetBuffValueRefresh ( );
	float GetBuffValueApplied ( );
	void eventTrackBuffValue ( struct FImpactInfo Impact, unsigned long bRefresh );
	void InitInstance ( class AActor* Target, class AActor* aInstigator, struct FImpactInfo Impact );
	bool EffectExists ( int nPropId );
	float QueryFxTransitionTime ( );
	float TotalPropertyEffectAmt ( int nPropertyId );
	void RemoveEffects ( class AActor* Target, unsigned long bResetToFollow );
	class UTgEffectGroup* CloneEffectGroup ( );
};

UClass* UTgEffectGroup::pClassPointer = NULL;

// Class TgGame.TgEffectManager
// 0x02CC (0x0498 - 0x01CC)
class ATgEffectManager : public AActor
{
public:
	struct FEffectListEntry                            r_ManagedEffectList[ 0x10 ];                      		// 0x01CC (0x0100) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_byCounterList[ 0x10 ];                          		// 0x02CC (0x0010) [0x0000000000000000]              
	float                                              m_fTimeRemaining[ 0x10 ];                         		// 0x02DC (0x0040) [0x0000000000000000]              
	class UTgEffectForm*                               c_Forms[ 0x10 ];                                  		// 0x031C (0x0040) [0x0000000000000000]              
	unsigned long                                      c_ActiveTimers : 1;                               		// 0x035C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bRelevancyNotify : 1;                           		// 0x035C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	struct FEffectQueueEntry                           r_EventQueue[ 0x20 ];                             		// 0x0360 (0x0100) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nNextQueueIndex;                                		// 0x0460 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nLastQueueIndex;                                		// 0x0464 (0x0004) [0x0000000000000000]              
	TArray< class UTgEffectGroup* >                    s_AppliedEffectGroups;                            		// 0x0468 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgEffectGroup* >                    s_SkillBasedEffectGroups;                         		// 0x0474 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AActor*                                      r_Owner;                                          		// 0x0480 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgEffectGroup*                              m_ApplyDamageEffectGroup;                         		// 0x0484 (0x0004) [0x0000000000000000]              
	class UTgEffect*                                   m_ApplyDamageEffect;                              		// 0x0488 (0x0004) [0x0000000000000000]              
	class UTgEffectGroup*                              m_ApplyHealthEffectGroup;                         		// 0x048C (0x0004) [0x0000000000000000]              
	class UTgEffect*                                   m_ApplyHealthEffect;                              		// 0x0490 (0x0004) [0x0000000000000000]              
	int                                                r_nInvulnerableCount;                             		// 0x0494 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1383 ];

		return pClassPointer;
	};

	void CheckDelayedStealthEffectForms ( );
	void eventReplicatedEvent ( struct FName VarName );
	void LifeOver ( class UTgEffectGroup* EffectGroup );
	class UTgEffectGroup* GetRefreshedEffectGroup ( class UTgEffectGroup* eg, int* nRefreshCode );
	class UTgEffectGroup* GetStackingEffectGroup ( class UTgEffectGroup* eg );
	class UTgEffectGroup* GetClonedEffectGroup ( class UTgEffectGroup* eg );
	class UTgEffectGroup* GetNewEffectGroupByApp ( class UTgEffectGroup* eg, int* nRefreshCode );
	bool DidEffectGroupHit ( class UTgEffectGroup* eg, struct FImpactInfo Impact, class AActor* aInstigator );
	void eventProcessEffect ( class UTgEffectGroup* EffectGroup, unsigned long bRemove, class UTgEffectGroup* Buffers, class AActor* aInstigator, struct FImpactInfo Impact );
	int GetHealth ( );
	void PostBeginPlay ( );
	void ApplyHealth ( int nHealth, class AActor* aInstigator, int nAttackType, int nDamageType, struct FImpactInfo Impact, int nEffectGroupCategory );
	void ApplyDamage ( int nDamage, class AActor* aInstigator, int nAttackType, int nDamageType, struct FImpactInfo Impact, int nEffectGroupCategory );
	void RecalculateFx ( );
	int GetCombatMsgIdFromEffectGroup ( class UTgEffectGroup* EffectGroup );
	bool IsInvulnerable ( );
	void SubmitMitigationDamage ( int nProtectionType, int nDamage );
	void ClearAllClientEffectForms ( );
	void ConfigureEffectFormsForFirstPerson ( unsigned long bIsFirstPerson );
	void ConfigureEffectFormsForStealth ( unsigned long bIsStealthed );
	void ProcessReactiveSkillBasedEffectGroup ( int nCategory, unsigned long bRemove );
	class UTgEffectGroup* GetSkillBasedEffectGroup ( int nType, int* nIndex );
	void ClearSkillBasedEffectGroups ( );
	void AddSkillBasedEffectGroup ( class UTgEffectGroup* pEffectGroup );
	class UTgEffectGroup* GetEffectGroupByCategory ( int nCategoryCode );
	class UTgEffectGroup* GetEffectGroup ( int nEffectGroupID );
	void RemoveAllEffects ( TArray< int > ExludeCategoryCodes );
	bool IsStrongest ( class UTgEffectGroup* eg, unsigned long bConsiderLifetime );
	bool RemoveAllEffectGroups ( class UTgEffectGroup* eg );
	bool RemoveEffectGroupsByCategory ( int nCategoryCode, int nQuantity );
	bool RemoveEffectGroup ( class UTgEffectGroup* EffectGroup );
	void UpdateManagedEffectForms ( );
	void UpdateQueueEffectForms ( );
	void UpdateEffectForms ( );
	void ClearEffectRep ( int nEffectId, int nManagedListIndex );
	void RefreshEffectRep ( int nEffectGroupIndex, float fTime );
	int SetEffectRep ( int nEffectGroupID, float nTime, unsigned long bIsBuff, int nHealthChange );
};

UClass* ATgEffectManager::pClassPointer = NULL;

// Class TgGame.TgActorFactory
// 0x002C (0x01F8 - 0x01CC)
class ATgActorFactory : public AActor
{
public:
	int                                                m_nMapObjectId;                                   		// 0x01CC (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned long                                      s_bAutoSpawn : 1;                                 		// 0x01D0 (0x0004) [0x0000000000020000] [0x00000001] ( CPF_EditConst )
	int                                                s_nTeamNumber;                                    		// 0x01D4 (0x0004) [0x0000000000020000]              ( CPF_EditConst )
	unsigned char                                      s_nTaskForce;                                     		// 0x01D8 (0x0001) [0x0000000000020000]              ( CPF_EditConst )
	unsigned char                                      s_eCoalition;                                     		// 0x01D9 (0x0001) [0x0000000000020000]              ( CPF_EditConst )
	unsigned char                                      s_eSelectionMethod;                               		// 0x01DA (0x0001) [0x0000000000020000]              ( CPF_EditConst )
	int                                                s_nSelectionListId;                               		// 0x01DC (0x0004) [0x0000000000000000]              
	int                                                s_nSelectedObjectId;                              		// 0x01E0 (0x0004) [0x0000000000000000]              
	class USpriteComponent*                            m_Sprite;                                         		// 0x01E4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nSelectionListPropId;                           		// 0x01E8 (0x0004) [0x0000000000000000]              
	int                                                s_nNameId;                                        		// 0x01EC (0x0004) [0x0000000000000000]              
	int                                                s_nCurListIndex;                                  		// 0x01F0 (0x0004) [0x0000000000000000]              
	class UMeshComponent*                              c_DemoMesh;                                       		// 0x01F4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1384 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void PreBeginPlay ( );
	void CalcFactoryPlacement ( struct FVector Extent, unsigned long bCenterOnGround, struct FVector* OutLocation, struct FRotator* OutRotation );
	void SpawnDemoMesh ( int nSelectedObjectId );
	void SpawnObject ( );
	void LoadObjectConfig ( );
};

UClass* ATgActorFactory::pClassPointer = NULL;

// Class TgGame.TgBeaconFactory
// 0x000C (0x0204 - 0x01F8)
class ATgBeaconFactory : public ATgActorFactory
{
public:
	int                                                m_nPriority;                                      		// 0x01F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nPrevPriority;                                  		// 0x01FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bBeaconExit : 1;                                		// 0x0200 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bIsFallback : 1;                                		// 0x0200 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1385 ];

		return pClassPointer;
	};

	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void OnKillBots ( class UTgSeqAct_KillBots* inAction );
	void OnToggle ( class USeqAct_Toggle* Action );
	void SpawnObject ( );
};

UClass* ATgBeaconFactory::pClassPointer = NULL;

// Class TgGame.TgBotFactory
// 0x0094 (0x028C - 0x01F8)
class ATgBotFactory : public ATgActorFactory
{
public:
	unsigned char                                      LocationSelection;                                		// 0x01F8 (0x0001) [0x0000000000000000]              
	unsigned char                                      TypeSelection;                                    		// 0x01F9 (0x0001) [0x0000000000000000]              
	TArray< class ANavigationPoint* >                  LocationList;                                     		// 0x01FC (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	int                                                s_nCurLocationIndex;                              		// 0x0208 (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            SafetyLocation;                                   		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bPatrolLoop : 1;                                  		// 0x0210 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bAlwaysPatrol : 1;                                		// 0x0210 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bSpawnOnAlarm : 1;                                		// 0x0210 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bAutoSpawn : 1;                                   		// 0x0210 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bFirstSpawn : 1;                                		// 0x0210 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      bBulkSpawn : 1;                                   		// 0x0210 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      bRespawn : 1;                                     		// 0x0210 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bIgnoreCollisionOnSpawn : 1;                    		// 0x0210 (0x0004) [0x0000000000000000] [0x00000080] 
	TArray< class ANavigationPoint* >                  PatrolPath;                                       		// 0x0214 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                nGlobalAlarmId;                                   		// 0x0220 (0x0004) [0x0000000000000000]              
	int                                                nBotCount;                                        		// 0x0224 (0x0004) [0x0000000000000000]              
	int                                                nCurrentCount;                                    		// 0x0228 (0x0004) [0x0000000000000000]              
	int                                                nActiveCount;                                     		// 0x022C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nTotalSpawns;                                     		// 0x0230 (0x0004) [0x0000000000000000]              
	int                                                nSpawnTableId;                                    		// 0x0234 (0x0004) [0x0000000000020000]              ( CPF_EditConst )
	int                                                nDefaultSpawnTableId;                             		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              fSpawnDelay;                                      		// 0x023C (0x0004) [0x0000000000000000]              
	TArray< struct FSpawnQueueEntry >                  m_SpawnQueue;                                     		// 0x0240 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgBotEncounterVolume*                       m_SpawnVolume;                                    		// 0x024C (0x0004) [0x0000000000000000]              
	TArray< struct FSpawnGroupDetail >                 m_SpawnGroups;                                    		// 0x0250 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nLastGroup;                                     		// 0x025C (0x0004) [0x0000000000000000]              
	int                                                nPriority;                                        		// 0x0260 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nPrevPriority;                                    		// 0x0264 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTexture2D*                                  m_TextureNormal;                                  		// 0x0268 (0x0004) [0x0000000000000000]              
	class UTexture2D*                                  m_TextureAlarm;                                   		// 0x026C (0x0004) [0x0000000000000000]              
	float                                              fLastKillTime;                                    		// 0x0270 (0x0004) [0x0000000000000000]              
	float                                              fBalance;                                         		// 0x0274 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FString >                           TypeList;                                         		// 0x0278 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	float                                              fRespawnDelay;                                    		// 0x0284 (0x0004) [0x0000000000000000]              
	int                                                m_nSpawnOrder;                                    		// 0x0288 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1386 ];

		return pClassPointer;
	};

	void OnGetBot ( class UTgSeqAct_GetBot* inAction );
	void OnHackBot ( class UTgSeqAct_HackBot* inAction );
	void eventSetTarget ( class ATgPawn* Target, unsigned long bAlarmBot );
	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void OnTriggerBots ( class UTgSeqAct_TriggerBots* Action );
	void OnJoinTeam ( class UTgSeqAct_JoinTeam* Action );
	void eventKillBots ( unsigned long bDespawn );
	void Despawn ( );
	void eventStartEncounter ( class ATgBotEncounterVolume* Volume );
	void eventContinueEncounter ( );
	void eventEndEncounter ( );
	void OnDespawnBots ( class UTgSeqAct_DespawnBots* inAction );
	void OnKillBots ( class UTgSeqAct_KillBots* inAction );
	void OnToggle ( class USeqAct_Toggle* Action );
	void PostBeginPlay ( );
	int GetRemainingTotalSpawns ( );
	void BotDied ( class ATgPawn* Pawn, class ATgAIController* aic );
	void UseSpawnTable ( );
	void JoinTeam ( class ATgPawn* pLeader );
	void SpawnDemoMesh ( int nSelectedObjectId );
	void SpawnBotAdjusted ( int nBotId, float fAdjustment );
	void SpawnBotId ( int nBotId );
	void SpawnWave ( int Num );
	void SpawnNextBot ( );
	void SpawnBot ( );
	void ClearQueue ( );
	void ResetQueue ( int nOverrideSpawnTableId );
	void LoadObjectConfig ( );
};

UClass* ATgBotFactory::pClassPointer = NULL;

// Class TgGame.TgBotFactorySpawnable
// 0x0000 (0x028C - 0x028C)
class ATgBotFactorySpawnable : public ATgBotFactory
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1387 ];

		return pClassPointer;
	};

};

UClass* ATgBotFactorySpawnable::pClassPointer = NULL;

// Class TgGame.TgDeployableFactory
// 0x000C (0x0204 - 0x01F8)
class ATgDeployableFactory : public ATgActorFactory
{
public:
	int                                                nCurrentCount;                                    		// 0x01F8 (0x0004) [0x0000000000000000]              
	float                                              s_fLastSpawnTime;                                 		// 0x01FC (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bSpawnOnce : 1;                                 		// 0x0200 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1388 ];

		return pClassPointer;
	};

	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void OnKillBots ( class UTgSeqAct_KillBots* inAction );
	void OnToggle ( class USeqAct_Toggle* Action );
	void DeployableDied ( );
	void PostBeginPlay ( );
	void SpawnDemoMesh ( int nSelectedObjectId );
	void SpawnObject ( );
};

UClass* ATgDeployableFactory::pClassPointer = NULL;

// Class TgGame.TgDestructibleFactory
// 0x0004 (0x01FC - 0x01F8)
class ATgDestructibleFactory : public ATgActorFactory
{
public:
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x01F8 (0x0004) [0x00000000040A000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_EditConst | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1389 ];

		return pClassPointer;
	};

	void SpawnObject ( );
};

UClass* ATgDestructibleFactory::pClassPointer = NULL;

// Class TgGame.TgHexItemFactory
// 0x000C (0x0204 - 0x01F8)
class ATgHexItemFactory : public ATgActorFactory
{
public:
	class UTgHexItemInstance*                          s_HexItem;                                        		// 0x01F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class AActor*                                      s_SpawnedActor;                                   		// 0x01FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      s_bNeedsSpawn : 1;                                		// 0x0200 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1390 ];

		return pClassPointer;
	};

	void Tick ( float DeltaSeconds );
	void PostBeginPlay ( );
	void SpawnObject ( );
	bool CanSpawn ( class UTgHexItemInstance* newHexItem );
	void SetHexItem ( class UTgHexItemInstance* newHexItem );
};

UClass* ATgHexItemFactory::pClassPointer = NULL;

// Class TgGame.TgBotFactoryComponent
// 0x0000 (0x01C8 - 0x01C8)
class UTgBotFactoryComponent : public UPrimitiveComponent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1391 ];

		return pClassPointer;
	};

};

UClass* UTgBotFactoryComponent::pClassPointer = NULL;

// Class TgGame.TgDroppedItem
// 0x0024 (0x01F0 - 0x01CC)
class ATgDroppedItem : public AActor
{
public:
	float                                              m_fLifeSpan;                                      		// 0x01CC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bFadeOut : 1;                                   		// 0x01D0 (0x0004) [0x0000000000000000] [0x00000001] 
	struct FName                                       m_nmPickUpState;                                  		// 0x01D4 (0x0008) [0x0000000000000000]              
	int                                                r_nItemId;                                        		// 0x01DC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UMeshComponent*                              c_Mesh;                                           		// 0x01E0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< class UTgEffectGroup* >                    s_EffectGroupList;                                		// 0x01E4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1392 ];

		return pClassPointer;
	};

	void GiveTo ( class ATgPawn* P );
	void eventReplicatedEvent ( struct FName VarName );
	bool ApplyItemSetup ( );
	class UTgEffectGroup* GetEffectGroup ( int nType, int* nIndex );
};

UClass* ATgDroppedItem::pClassPointer = NULL;

// Class TgGame.TgHexItemInstance
// 0x0014 (0x0050 - 0x003C)
class UTgHexItemInstance : public UObject
{
public:
	unsigned char                                      s_HexItemState;                                   		// 0x003C (0x0001) [0x0000000000000000]              
	class AActor*                                      s_HexActor;                                       		// 0x0040 (0x0004) [0x0000000000000000]              
	class UTgInventoryObject_HexItem*                  s_HexInventoryItem;                               		// 0x0044 (0x0004) [0x0000000000000000]              
	float                                              s_fHealthPercent;                                 		// 0x0048 (0x0004) [0x0000000000000000]              
	class ATgHexItemFactory*                           s_Factory;                                        		// 0x004C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1393 ];

		return pClassPointer;
	};

	void SetHealthPercent ( float fPercent );
	void TransferHexItem ( class AActor* newActor );
	void SetHexActorState ( unsigned char hexItemState );
	float GetHealthPercent ( );
	unsigned char GetHexActorState ( );
};

UClass* UTgHexItemInstance::pClassPointer = NULL;

// Class TgGame.TgInventoryManager
// 0x0080 (0x0268 - 0x01E8)
class ATgInventoryManager : public AInventoryManager
{
public:
	int                                                r_ItemCount;                                      		// 0x01E8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nPreviousDeviceInstanceId;                      		// 0x01EC (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x01F0 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.m_InventoryMap
	unsigned char                                      UnknownData01[ 0x3C ];                            		// 0x022C (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgInventoryManager.s_ReplicateMap

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1394 ];

		return pClassPointer;
	};

	void eventServerSetCurrentWeapon ( class ATgDevice* NewWeapon, int nMode );
	void ClientSetCurrentWeapon ( class ATgDevice* NewWeapon, int nMode );
	bool SetCurrentWeapon ( class ATgDevice* DesiredWeapon, int DesiredMode, unsigned long bMessageFromNetwork, unsigned long bForceFastClear );
	void ChangedWeapon ( class ATgDevice* DesiredWeapon );
	void eventServerTestShowInventory ( );
	void eventDestroyed ( );
	void PostBeginPlay ( );
	void InventoryCleanup ( );
	void TestShowInventory ( );
	void ApplyAllEnhancementEffects ( unsigned long bRemove );
	void SetInventoryDirty ( );
	bool IsValid ( );
	class ATgDevice* GetDeviceByInstanceId ( int nDeviceInstanceId );
	void NonPersistRemoveDevice ( int nEquipPoint );
	class ATgDevice* NonPersistAddDevice ( int nDeviceId, int nEquipPoint );
};

UClass* ATgInventoryManager::pClassPointer = NULL;

// Class TgGame.TgInventoryObject
// 0x0074 (0x00B0 - 0x003C)
class UTgInventoryObject : public UObject
{
public:
	struct FInventoryData                              m_InventoryData;                                  		// 0x003C (0x0040) [0x0000000000000000]              
	TArray< int >                                      m_nStateEffectGroupIdArray;                       		// 0x007C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bHasDegraded : 1;                               		// 0x0088 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bPersistsInInventory : 1;                       		// 0x0088 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bAutoCreated : 1;                               		// 0x0088 (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                m_nRefData;                                       		// 0x008C (0x0004) [0x0000000000000000]              
	class ATgInventoryManager*                         m_InvManager;                                     		// 0x0090 (0x0004) [0x0000000000000000]              
	unsigned char                                      s_ReplicatedState;                                		// 0x0094 (0x0001) [0x0000000000000000]              
	struct FPointer                                    m_pAmItem;                                        		// 0x0098 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FPointer                                    m_pAmBlueprint;                                   		// 0x009C (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FPointer                                    m_pAmLootTableItem;                               		// 0x00A0 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	int                                                m_LootTableCurrency;                              		// 0x00A4 (0x0004) [0x0000000000000000]              
	int                                                c_nNbrAcquired;                                   		// 0x00A8 (0x0004) [0x0000000000000000]              
	float                                              c_fTimeAcquired;                                  		// 0x00AC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1395 ];

		return pClassPointer;
	};

	struct FInventoryData GetInventoryData ( );
	bool IsEquippableType ( );
	bool IsUsableType ( );
};

UClass* UTgInventoryObject::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_Device
// 0x000C (0x00BC - 0x00B0)
class UTgInventoryObject_Device : public UTgInventoryObject
{
public:
	class ATgDevice*                                   s_Device;                                         		// 0x00B0 (0x0004) [0x0000000000000000]              
	int                                                m_nDeviceInstanceId;                              		// 0x00B4 (0x0004) [0x0000000000000000]              
	int                                                c_nNumFindDeviceFails;                            		// 0x00B8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1396 ];

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_Device::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_HexItem
// 0x0010 (0x00C0 - 0x00B0)
class UTgInventoryObject_HexItem : public UTgInventoryObject
{
public:
	class ATgRepInfo_TaskForce*                        s_TaskForce;                                      		// 0x00B0 (0x0004) [0x0000000000000000]              
	TArray< class UTgHexItemInstance* >                s_ItemInstances;                                  		// 0x00B4 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1397 ];

		return pClassPointer;
	};

	class UTgHexItemInstance* FindInstance ( unsigned char eState );
	class UTgHexItemInstance* GetItemInstance ( int I );
	void SetHexActorState ( unsigned char hexItemState );
	void SetTaskForce ( class ATgRepInfo_TaskForce* tf );
};

UClass* UTgInventoryObject_HexItem::pClassPointer = NULL;

// Class TgGame.TgInventoryObject_VanityPet
// 0x0004 (0x00B4 - 0x00B0)
class UTgInventoryObject_VanityPet : public UTgInventoryObject
{
public:
	unsigned long                                      m_bActive : 1;                                    		// 0x00B0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1398 ];

		return pClassPointer;
	};

};

UClass* UTgInventoryObject_VanityPet::pClassPointer = NULL;

// Class TgGame.TgPickupFactory
// 0x001C (0x02F0 - 0x02D4)
class ATgPickupFactory : public APickupFactory
{
public:
	unsigned long                                      bRotatingPickup : 1;                              		// 0x02D4 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              YawRotationRate;                                  		// 0x02D8 (0x0004) [0x0000000000000000]              
	class AController*                                 TeamOwner[ 0x4 ];                                 		// 0x02DC (0x0010) [0x0000000000000000]              
	class UPrimitiveComponent*                         BaseMesh;                                         		// 0x02EC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1399 ];

		return pClassPointer;
	};

	bool StopsProjectile ( class AProjectile* P );
	void RespawnEffect ( );
	void UpdateHUD ( class ATgHUD* H );
	bool ShouldCamp ( class ATgAIController* B, float MaxWait );
};

UClass* ATgPickupFactory::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ActivateObjective
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_ActivateObjective : public USequenceAction
{
public:
	int                                                m_nTaskForceId;                                   		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1400 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ActivateObjective::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AlarmBots
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_AlarmBots : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1401 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AlarmBots::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ClientLoadDevices
// 0x0010 (0x00F8 - 0x00E8)
class UTgSeqAct_ClientLoadDevices : public USequenceAction
{
public:
	TArray< int >                                      m_DeviceIdList;                                   		// 0x00E8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bClearExistingLoads : 1;                        		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1402 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ClientLoadDevices::pClassPointer = NULL;

// Class TgGame.TgSeqAct_DefenseWaveSpawner
// 0x000C (0x00F4 - 0x00E8)
class UTgSeqAct_DefenseWaveSpawner : public USequenceAction
{
public:
	int                                                m_nRoundNumber;                                   		// 0x00E8 (0x0004) [0x0000000000000000]              
	float                                              m_fSpawnFrequency;                                		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              m_fNextSpawnTime;                                 		// 0x00F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1403 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_DefenseWaveSpawner::pClassPointer = NULL;

// Class TgGame.TgSeqAct_EndMission
// 0x000C (0x00F4 - 0x00E8)
class UTgSeqAct_EndMission : public USequenceAction
{
public:
	int                                                m_nNextMapGameId;                                 		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ACameraActor*                                m_SpectatorCamera;                                		// 0x00EC (0x0004) [0x0000000000000000]              
	int                                                m_nDelay;                                         		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1404 ];

		return pClassPointer;
	};

	int eventGetObjClassVersion ( );
};

UClass* UTgSeqAct_EndMission::pClassPointer = NULL;

// Class TgGame.TgSeqAct_EndObjectiveAssignment
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_EndObjectiveAssignment : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1405 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_EndObjectiveAssignment::pClassPointer = NULL;

// Class TgGame.TgSeqAct_EquipCharDevice
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_EquipCharDevice : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1406 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_EquipCharDevice::pClassPointer = NULL;

// Class TgGame.TgSeqAct_EquipCharDevices
// 0x0010 (0x00F8 - 0x00E8)
class UTgSeqAct_EquipCharDevices : public USequenceAction
{
public:
	TArray< int >                                      m_DeviceIdList;                                   		// 0x00E8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bRemoveOtherDevices : 1;                        		// 0x00F4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1407 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_EquipCharDevices::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetCustomCharacterAssemblyValues
// 0x0048 (0x0130 - 0x00E8)
class UTgSeqAct_GetCustomCharacterAssemblyValues : public USequenceAction
{
public:
	struct FCustomCharacterAssembly                    c_Assembly;                                       		// 0x00E8 (0x0044) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      c_bIgnoreSuit : 1;                                		// 0x012C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1408 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetCustomCharacterAssemblyValues::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetMaterialInst
// 0x0014 (0x00FC - 0x00E8)
class UTgSeqAct_GetMaterialInst : public USequenceAction
{
public:
	class UMaterialInstance*                           MatInst;                                          		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     MatInstName;                                      		// 0x00EC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                MaterialIndex;                                    		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1409 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetMaterialInst::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetPlayerCount
// 0x0018 (0x0100 - 0x00E8)
class UTgSeqAct_GetPlayerCount : public USequenceAction
{
public:
	int                                                m_nTaskForce;                                     		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPlayerCount;                                   		// 0x00EC (0x0004) [0x0000000000000000]              
	float                                              m_fAssaultCount;                                  		// 0x00F0 (0x0004) [0x0000000000000000]              
	float                                              m_fMedicCount;                                    		// 0x00F4 (0x0004) [0x0000000000000000]              
	float                                              m_fReconCount;                                    		// 0x00F8 (0x0004) [0x0000000000000000]              
	float                                              m_fRoboticsCount;                                 		// 0x00FC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1410 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetPlayerCount::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetSceneDriver
// 0x0008 (0x00F0 - 0x00E8)
class UTgSeqAct_GetSceneDriver : public USequenceAction
{
public:
	class UUIScene*                                    Scene;                                            		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UObject*                                     SceneDriver;                                      		// 0x00EC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1411 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetSceneDriver::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetTaskForceCount
// 0x000C (0x00F4 - 0x00E8)
class UTgSeqAct_GetTaskForceCount : public USequenceAction
{
public:
	int                                                taskforce;                                        		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nPlayerCount;                                   		// 0x00EC (0x0004) [0x0000000000000000]              
	int                                                m_nBotCount;                                      		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1412 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetTaskForceCount::pClassPointer = NULL;

// Class TgGame.TgSeqAct_HideHUDElement
// 0x0001 (0x00E9 - 0x00E8)
class UTgSeqAct_HideHUDElement : public USequenceAction
{
public:
	unsigned char                                      m_Element;                                        		// 0x00E8 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1413 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_HideHUDElement::pClassPointer = NULL;

// Class TgGame.TgSeqAct_MatchJoin
// 0x0014 (0x00FC - 0x00E8)
class UTgSeqAct_MatchJoin : public USequenceAction
{
public:
	int                                                m_nQueueId;                                       		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nMapGameId;                                     		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_sQueueName;                                     		// 0x00F0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1414 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_MatchJoin::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ModifyObjective
// 0x001C (0x0114 - 0x00F8)
class UTgSeqAct_ModifyObjective : public USeqAct_Latent
{
public:
	int                                                m_nTaskForceId;                                   		// 0x00F8 (0x0004) [0x0000000000000000]              
	int                                                m_nMsgId;                                         		// 0x00FC (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bDisplayProgressBar : 1;                        		// 0x0100 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bIncreasing : 1;                                		// 0x0100 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bTimerActive : 1;                               		// 0x0100 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_fDuration;                                      		// 0x0104 (0x0004) [0x0000000000000000]              
	float                                              m_fInitPercentage;                                		// 0x0108 (0x0004) [0x0000000000000000]              
	float                                              m_fLastUpdateTime;                                		// 0x010C (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingTime;                                 		// 0x0110 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1415 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ModifyObjective::pClassPointer = NULL;

// Class TgGame.TgSeqAct_NavIndicator
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_NavIndicator : public USequenceAction
{
public:
	class AActor*                                      m_NavTarget;                                      		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1416 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_NavIndicator::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ObjectiveMatinee
// 0x0000 (0x01B8 - 0x01B8)
class UTgSeqAct_ObjectiveMatinee : public USeqAct_Interp
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1417 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ObjectiveMatinee::pClassPointer = NULL;

// Class TgGame.TgSeqAct_PlayFullBodyAnim
// 0x0018 (0x0100 - 0x00E8)
class UTgSeqAct_PlayFullBodyAnim : public USequenceAction
{
public:
	struct FName                                       c_AnimName;                                       		// 0x00E8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fRate;                                          		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fBlendInTime;                                   		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fBlendOutTime;                                  		// 0x00F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      c_bLooping : 1;                                   		// 0x00FC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      c_bOverride : 1;                                  		// 0x00FC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1418 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_PlayFullBodyAnim::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ProgressTo
// 0x0004 (0x0110 - 0x010C)
class UTgSeqAct_ProgressTo : public USeqAct_Delay
{
public:
	class ATgPawn*                                     m_Instigator;                                     		// 0x010C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1419 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ProgressTo::pClassPointer = NULL;

// Class TgGame.TgSeqAct_QuestGetStatus
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_QuestGetStatus : public USequenceAction
{
public:
	int                                                QuestId;                                          		// 0x00E8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1420 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_QuestGetStatus::pClassPointer = NULL;

// Class TgGame.TgSeqAct_QuestIncrementReqCount
// 0x000C (0x00F4 - 0x00E8)
class UTgSeqAct_QuestIncrementReqCount : public USequenceAction
{
public:
	int                                                QuestId;                                          		// 0x00E8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                QuestRequirementId;                               		// 0x00EC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned long                                      bTeamwideCredit : 1;                              		// 0x00F0 (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1421 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_QuestIncrementReqCount::pClassPointer = NULL;

// Class TgGame.TgSeqAct_QuestRequirementGetStatus
// 0x0008 (0x00F0 - 0x00E8)
class UTgSeqAct_QuestRequirementGetStatus : public USequenceAction
{
public:
	int                                                QuestId;                                          		// 0x00E8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                QuestRequirementId;                               		// 0x00EC (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1422 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_QuestRequirementGetStatus::pClassPointer = NULL;

// Class TgGame.TgSeqAct_RequestMission
// 0x000C (0x00F4 - 0x00E8)
class UTgSeqAct_RequestMission : public USequenceAction
{
public:
	int                                                m_nMapGameId;                                     		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_eDifficultyLevel;                               		// 0x00EC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bGiveReward : 1;                                		// 0x00F0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1423 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_RequestMission::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetHexState
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_SetHexState : public USequenceAction
{
public:
	unsigned long                                      m_bChallengerWon : 1;                             		// 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1424 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetHexState::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetHomeInstance
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_SetHomeInstance : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1425 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetHomeInstance::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetMissionTime
// 0x000C (0x00F4 - 0x00E8)
class UTgSeqAct_SetMissionTime : public USequenceAction
{
public:
	float                                              m_fMissionTimeSecs;                               		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fIncrementSecs;                                 		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fMissionTimeRemaining;                          		// 0x00F0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1426 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetMissionTime::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetPlayerMesh
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_SetPlayerMesh : public USequenceAction
{
public:
	int                                                m_nMeshAsmId;                                     		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1427 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetPlayerMesh::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetUIClock
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_SetUIClock : public USequenceAction
{
public:
	unsigned long                                      ShowAlarmTexture : 1;                             		// 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      UseProgressBar : 1;                               		// 0x00E8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      IsCountingDown : 1;                               		// 0x00E8 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1428 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetUIClock::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetUITextBox
// 0x0009 (0x00F1 - 0x00E8)
class UTgSeqAct_SetUITextBox : public USequenceAction
{
public:
	int                                                TextBox_MessageID;                                		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      TextBox_TargetSecondary : 1;                      		// 0x00EC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      TextBox_UseDuration : 1;                          		// 0x00EC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      TextBox_AllowEscape : 1;                          		// 0x00EC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned char                                      TextBox_MessageType;                              		// 0x00F0 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1429 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetUITextBox::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ShowHUDElement
// 0x0001 (0x00E9 - 0x00E8)
class UTgSeqAct_ShowHUDElement : public USequenceAction
{
public:
	unsigned char                                      m_Element;                                        		// 0x00E8 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1430 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ShowHUDElement::pClassPointer = NULL;

// Class TgGame.TgSeqAct_StartNextObjective
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_StartNextObjective : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1431 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_StartNextObjective::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TemporaryAddDevice
// 0x0008 (0x00F0 - 0x00E8)
class UTgSeqAct_TemporaryAddDevice : public USequenceAction
{
public:
	int                                                m_nDeviceId;                                      		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nEquipPoint;                                    		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1432 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TemporaryAddDevice::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TemporaryRemoveDevice
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_TemporaryRemoveDevice : public USequenceAction
{
public:
	int                                                m_nEquipPoint;                                    		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1433 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TemporaryRemoveDevice::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TrainingAwards
// 0x0010 (0x00F8 - 0x00E8)
class UTgSeqAct_TrainingAwards : public USequenceAction
{
public:
	float                                              m_fGoldTime;                                      		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fSilverTime;                                    		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBronzeTime;                                    		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPassTime;                                      		// 0x00F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1434 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TrainingAwards::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TriggerBots
// 0x000C (0x00F4 - 0x00E8)
class UTgSeqAct_TriggerBots : public USequenceAction
{
public:
	unsigned long                                      bUseDestination : 1;                              		// 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class AActor*                                      TargetActor;                                      		// 0x00EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class AActor*                                      destActor;                                        		// 0x00F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1435 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TriggerBots::pClassPointer = NULL;

// Class TgGame.TgSeqCond_And
// 0x0000 (0x00D0 - 0x00D0)
class UTgSeqCond_And : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1436 ];

		return pClassPointer;
	};

};

UClass* UTgSeqCond_And::pClassPointer = NULL;

// Class TgGame.TgSeqCond_CompareGender
// 0x0000 (0x00D0 - 0x00D0)
class UTgSeqCond_CompareGender : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1437 ];

		return pClassPointer;
	};

};

UClass* UTgSeqCond_CompareGender::pClassPointer = NULL;

// Class TgGame.TgSeqCond_HasCondition
// 0x0001 (0x00D1 - 0x00D0)
class UTgSeqCond_HasCondition : public USequenceCondition
{
public:
	unsigned char                                      ConditionList;                                    		// 0x00D0 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1438 ];

		return pClassPointer;
	};

};

UClass* UTgSeqCond_HasCondition::pClassPointer = NULL;

// Class TgGame.TgSeqCond_IsAssigned
// 0x0000 (0x00D0 - 0x00D0)
class UTgSeqCond_IsAssigned : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1439 ];

		return pClassPointer;
	};

};

UClass* UTgSeqCond_IsAssigned::pClassPointer = NULL;

// Class TgGame.TgSeqCond_IsHuman
// 0x0000 (0x00D0 - 0x00D0)
class UTgSeqCond_IsHuman : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1440 ];

		return pClassPointer;
	};

};

UClass* UTgSeqCond_IsHuman::pClassPointer = NULL;

// Class TgGame.TgSeqCond_IsSecuring
// 0x0000 (0x00D0 - 0x00D0)
class UTgSeqCond_IsSecuring : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1441 ];

		return pClassPointer;
	};

};

UClass* UTgSeqCond_IsSecuring::pClassPointer = NULL;

// Class TgGame.TgSeqCond_Or
// 0x0000 (0x00D0 - 0x00D0)
class UTgSeqCond_Or : public USequenceCondition
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1442 ];

		return pClassPointer;
	};

};

UClass* UTgSeqCond_Or::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ClientGameOver
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_ClientGameOver : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1443 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_ClientGameOver::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_DeployableFired
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_DeployableFired : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1444 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_DeployableFired::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_LevelFadedIn
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_LevelFadedIn : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1445 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_LevelFadedIn::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_MissionTimer
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_MissionTimer : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1446 ];

		return pClassPointer;
	};

	void UpdateChallengerWonValue ( unsigned long bValue );
};

UClass* UTgSeqEvent_MissionTimer::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_MissionTimeRemaining
// 0x0004 (0x0110 - 0x010C)
class UTgSeqEvent_MissionTimeRemaining : public USequenceEvent
{
public:
	float                                              SecsRemaining;                                    		// 0x010C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1447 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_MissionTimeRemaining::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_Named
// 0x0001 (0x010D - 0x010C)
class UTgSeqEvent_Named : public USequenceEvent
{
public:
	unsigned char                                      NamedEvent;                                       		// 0x010C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1448 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_Named::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_NeighborObjectiveTaken
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_NeighborObjectiveTaken : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1449 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_NeighborObjectiveTaken::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ObjectiveAssignmentChanged
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_ObjectiveAssignmentChanged : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1450 ];

		return pClassPointer;
	};

	int eventGetObjClassVersion ( );
};

UClass* UTgSeqEvent_ObjectiveAssignmentChanged::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ObjectiveCaptured
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_ObjectiveCaptured : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1451 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_ObjectiveCaptured::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ObjectiveMatineeCommander
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_ObjectiveMatineeCommander : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1452 ];

		return pClassPointer;
	};

	void SetPosition ( float Position );
	void SetPlayRate ( float PlayRate );
};

UClass* UTgSeqEvent_ObjectiveMatineeCommander::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_ObjectiveStatusChanged
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_ObjectiveStatusChanged : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1453 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_ObjectiveStatusChanged::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_PlayerLeveledUp
// 0x0004 (0x0110 - 0x010C)
class UTgSeqEvent_PlayerLeveledUp : public USequenceEvent
{
public:
	int                                                PlayerLevel;                                      		// 0x010C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1454 ];

		return pClassPointer;
	};

	int eventGetObjClassVersion ( );
};

UClass* UTgSeqEvent_PlayerLeveledUp::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_QuestDataInitialized
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_QuestDataInitialized : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1455 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_QuestDataInitialized::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_QuestRequirementUpdated
// 0x0008 (0x0114 - 0x010C)
class UTgSeqEvent_QuestRequirementUpdated : public USequenceEvent
{
public:
	int                                                QuestId;                                          		// 0x010C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	int                                                QuestRequirementId;                               		// 0x0110 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1456 ];

		return pClassPointer;
	};

	int eventGetObjClassVersion ( );
};

UClass* UTgSeqEvent_QuestRequirementUpdated::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_QuestUpdated
// 0x0004 (0x0110 - 0x010C)
class UTgSeqEvent_QuestUpdated : public USequenceEvent
{
public:
	int                                                QuestId;                                          		// 0x010C (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1457 ];

		return pClassPointer;
	};

	int eventGetObjClassVersion ( );
};

UClass* UTgSeqEvent_QuestUpdated::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_RaidPhaseTransition
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_RaidPhaseTransition : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1458 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_RaidPhaseTransition::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_RaidSideObjectiveTaken
// 0x0001 (0x010D - 0x010C)
class UTgSeqEvent_RaidSideObjectiveTaken : public USequenceEvent
{
public:
	unsigned char                                      ObjectiveType;                                    		// 0x010C (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1459 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_RaidSideObjectiveTaken::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_TaskForceInactive
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_TaskForceInactive : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1460 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_TaskForceInactive::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_TeamInactive
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_TeamInactive : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1461 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_TeamInactive::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_TicketCountUpdated
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_TicketCountUpdated : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1462 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_TicketCountUpdated::pClassPointer = NULL;

// Class TgGame.TgSeqEvent_Used
// 0x0000 (0x010C - 0x010C)
class UTgSeqEvent_Used : public USequenceEvent
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1463 ];

		return pClassPointer;
	};

};

UClass* UTgSeqEvent_Used::pClassPointer = NULL;

// Class TgGame.TgSeqOp_MathCalc
// 0x0004 (0x00D4 - 0x00D0)
class UTgSeqOp_MathCalc : public USequenceCondition
{
public:
	float                                              m_fResult;                                        		// 0x00D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1464 ];

		return pClassPointer;
	};

};

UClass* UTgSeqOp_MathCalc::pClassPointer = NULL;

// Class TgGame.TgSeqVar_HomeMapGameId
// 0x0000 (0x0098 - 0x0098)
class UTgSeqVar_HomeMapGameId : public USeqVar_Int
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1465 ];

		return pClassPointer;
	};

};

UClass* UTgSeqVar_HomeMapGameId::pClassPointer = NULL;

// Class TgGame.TgSeqVar_MapGameId
// 0x0000 (0x0098 - 0x0098)
class UTgSeqVar_MapGameId : public USeqVar_Int
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1466 ];

		return pClassPointer;
	};

};

UClass* UTgSeqVar_MapGameId::pClassPointer = NULL;

// Class TgGame.TgSeqVar_Player
// 0x002C (0x00E4 - 0x00B8)
class UTgSeqVar_Player : public USeqVar_Player
{
public:
	TArray< class UObject* >                           HumanPlayers;                                     		// 0x00B8 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UObject* >                           BotPlayers;                                       		// 0x00C4 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< class UObject* >                           PetPlayers;                                       		// 0x00D0 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      bAllBots : 1;                                     		// 0x00DC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      bAllHumans : 1;                                   		// 0x00DC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bAllHumansAndPets : 1;                            		// 0x00DC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	int                                                nTaskForceNumber;                                 		// 0x00E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1467 ];

		return pClassPointer;
	};

};

UClass* UTgSeqVar_Player::pClassPointer = NULL;

// Class TgGame.TgSeqVar_PriorMapGameId
// 0x0000 (0x0098 - 0x0098)
class UTgSeqVar_PriorMapGameId : public USeqVar_Int
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1468 ];

		return pClassPointer;
	};

};

UClass* UTgSeqVar_PriorMapGameId::pClassPointer = NULL;

// Class TgGame.TgSeqVar_RouteNumber
// 0x0000 (0x0098 - 0x0098)
class UTgSeqVar_RouteNumber : public USeqVar_Int
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1469 ];

		return pClassPointer;
	};

};

UClass* UTgSeqVar_RouteNumber::pClassPointer = NULL;

// Class TgGame.TgTrigger_Instance
// 0x0014 (0x01EC - 0x01D8)
class ATgTrigger_Instance : public ATrigger
{
public:
	int                                                m_nMapId;                                         		// 0x01D8 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	unsigned long                                      m_nPreload : 1;                                   		// 0x01DC (0x0004) [0x0000000004000001] [0x00000001] ( CPF_Edit | CPF_EditInline )
	unsigned long                                      m_nTaskForce : 1;                                 		// 0x01DC (0x0004) [0x0000000004000001] [0x00000002] ( CPF_Edit | CPF_EditInline )
	struct FString                                     m_SpawnPointName;                                 		// 0x01E0 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1470 ];

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void HandleTouch ( class AActor* Other, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgTrigger_Instance::pClassPointer = NULL;

// Class TgGame.TgTrigger_Use
// 0x0028 (0x0200 - 0x01D8)
class ATgTrigger_Use : public ATrigger
{
public:
	struct FString                                     m_sDisplayText;                                   		// 0x01D8 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	struct FString                                     m_sInactiveText;                                  		// 0x01E4 (0x000C) [0x0000000004400001]              ( CPF_Edit | CPF_NeedCtorLink | CPF_EditInline )
	int                                                m_nInteractDistance;                              		// 0x01F0 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	unsigned long                                      m_bAimToInteract : 1;                             		// 0x01F4 (0x0004) [0x0000000004000001] [0x00000001] ( CPF_Edit | CPF_EditInline )
	int                                                m_nDisplayMsgId;                                  		// 0x01F8 (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )
	int                                                m_nInactiveMsgId;                                 		// 0x01FC (0x0004) [0x0000000004000001]              ( CPF_Edit | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1471 ];

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	int GetMsgIdToDisplay ( );
	bool IsUsedEnabled ( );
	void UsedByPawn ( class ATgPawn* User );
};

UClass* ATgTrigger_Use::pClassPointer = NULL;

// Class TgGame.TgUIAction_CheckLevelUnlocks
// 0x0004 (0x00EC - 0x00E8)
class UTgUIAction_CheckLevelUnlocks : public USequenceAction
{
public:
	unsigned long                                      bIsTutorial : 1;                                  		// 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1472 ];

		return pClassPointer;
	};

};

UClass* UTgUIAction_CheckLevelUnlocks::pClassPointer = NULL;

// Class TgGame.TgUIAction_CloseScene
// 0x0000 (0x00F1 - 0x00F1)
class UTgUIAction_CloseScene : public UUIAction_CloseScene
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1473 ];

		return pClassPointer;
	};

};

UClass* UTgUIAction_CloseScene::pClassPointer = NULL;

// Class TgGame.TgUIAction_DisplayIntroText
// 0x0008 (0x0104 - 0x00FC)
class UTgUIAction_DisplayIntroText : public UUIAction_OpenScene
{
public:
	float                                              FadeTime;                                         		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              TotalTime;                                        		// 0x0100 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1474 ];

		return pClassPointer;
	};

};

UClass* UTgUIAction_DisplayIntroText::pClassPointer = NULL;

// Class TgGame.TgUIAction_OpenScene
// 0x0000 (0x00FC - 0x00FC)
class UTgUIAction_OpenScene : public UUIAction_OpenScene
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1475 ];

		return pClassPointer;
	};

};

UClass* UTgUIAction_OpenScene::pClassPointer = NULL;

// Class TgGame.TgUIAction_OpenSceneByID
// 0x0004 (0x0100 - 0x00FC)
class UTgUIAction_OpenSceneByID : public UUIAction_OpenScene
{
public:
	int                                                SceneID;                                          		// 0x00FC (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1476 ];

		return pClassPointer;
	};

};

UClass* UTgUIAction_OpenSceneByID::pClassPointer = NULL;

// Class TgGame.TgUIAction_TriggerTutorial
// 0x0001 (0x00E9 - 0x00E8)
class UTgUIAction_TriggerTutorial : public USequenceAction
{
public:
	unsigned char                                      TutorialType;                                     		// 0x00E8 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1477 ];

		return pClassPointer;
	};

};

UClass* UTgUIAction_TriggerTutorial::pClassPointer = NULL;

// Class TgGame.TgTeamBlocker
// 0x000C (0x01EC - 0x01E0)
class ATgTeamBlocker : public ATgMeshAssembly
{
public:
	int                                                m_nTeam;                                          		// 0x01E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_eCoalition;                                     		// 0x01E4 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bBlockFlagCarrier : 1;                          		// 0x01E8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bBlockFriendlyFire : 1;                         		// 0x01E8 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1478 ];

		return pClassPointer;
	};

};

UClass* ATgTeamBlocker::pClassPointer = NULL;

// Class TgGame.TgDoorMarker
// 0x0018 (0x0204 - 0x01EC)
class ATgDoorMarker : public ATgTeamBlocker
{
public:
	unsigned char                                      r_eStatus;                                        		// 0x01EC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eInitStatus;                                    		// 0x01ED (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x01F0 (0x0004) [0x0000000000000000]              
	float                                              m_fProximity;                                     		// 0x01F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nTeamThatControlsDoor;                          		// 0x01F8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nMeshAssemblyId;                                		// 0x01FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMeshComponent*                      m_DoorSMC;                                        		// 0x0200 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1479 ];

		return pClassPointer;
	};

	void SetDoorStatus ( unsigned char eStatus );
	void CalculateDoorStatus ( );
	bool ShouldDoorBeClosed ( );
	bool ShouldDoorBeOpened ( );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ClientOnStatusChange ( );
	void PostBeginPlay ( );
	void eventReplicatedEvent ( struct FName VarName );
	void LoadMesh ( );
};

UClass* ATgDoorMarker::pClassPointer = NULL;

// Class TgGame.TgMiniMapActor
// 0x0018 (0x01E4 - 0x01CC)
class ATgMiniMapActor : public AActor
{
public:
	class UTexture2D*                                  TextureMiniMap;                                   		// 0x01CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ZoomBase;                                         		// 0x01D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ResolutionX;                                      		// 0x01D4 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              ResolutionY;                                      		// 0x01D8 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              CamLocationX;                                     		// 0x01DC (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              CamLocationY;                                     		// 0x01E0 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1480 ];

		return pClassPointer;
	};

};

UClass* ATgMiniMapActor::pClassPointer = NULL;

// Class TgGame.TgNavigationPoint
// 0x0004 (0x02BC - 0x02B8)
class ATgNavigationPoint : public ANavigationPoint
{
public:
	int                                                m_nMapObjectId;                                   		// 0x02B8 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1481 ];

		return pClassPointer;
	};

};

UClass* ATgNavigationPoint::pClassPointer = NULL;

// Class TgGame.TgActionPoint
// 0x0008 (0x02C4 - 0x02BC)
class ATgActionPoint : public ATgNavigationPoint
{
public:
	unsigned char                                      ActionType;                                       		// 0x02BC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      nObjectiveNum;                                    		// 0x02BD (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      nTaskForce;                                       		// 0x02BE (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      bUseRotation : 1;                                 		// 0x02C0 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1482 ];

		return pClassPointer;
	};

};

UClass* ATgActionPoint::pClassPointer = NULL;

// Class TgGame.TgAlarmPoint
// 0x0000 (0x02BC - 0x02BC)
class ATgAlarmPoint : public ATgNavigationPoint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1483 ];

		return pClassPointer;
	};

};

UClass* ATgAlarmPoint::pClassPointer = NULL;

// Class TgGame.TgCoverPoint
// 0x002C (0x02E8 - 0x02BC)
class ATgCoverPoint : public ATgNavigationPoint
{
public:
	unsigned long                                      m_bLeanLeft : 1;                                  		// 0x02BC (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bLeanRight : 1;                                 		// 0x02BC (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bAllowPopup : 1;                                		// 0x02BC (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bAllowMantle : 1;                               		// 0x02BC (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	struct FVector                                     m_vLeanLeft;                                      		// 0x02C0 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vLeanRight;                                     		// 0x02CC (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vPopUp;                                         		// 0x02D8 (0x000C) [0x0000000000000000]              
	class APawn*                                       m_pClaimedBy;                                     		// 0x02E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1484 ];

		return pClassPointer;
	};

	void PostBeginPlay ( );
	void Claim ( class APawn* pClaimedBy );
	class APawn* GetClaimedBy ( );
};

UClass* ATgCoverPoint::pClassPointer = NULL;

// Class TgGame.TgNavigationPointSpawnable
// 0x0000 (0x02BC - 0x02BC)
class ATgNavigationPointSpawnable : public ATgNavigationPoint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1485 ];

		return pClassPointer;
	};

};

UClass* ATgNavigationPointSpawnable::pClassPointer = NULL;

// Class TgGame.TgPointOfInterest
// 0x0024 (0x02E0 - 0x02BC)
class ATgPointOfInterest : public ATgNavigationPoint
{
public:
	int                                                m_nNameMsgId;                                     		// 0x02BC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FString                                     m_sDebugName;                                     		// 0x02C0 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< int >                                      m_nAssociatedQuestsIds;                           		// 0x02CC (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	float                                              m_QuestRadiusUU;                                  		// 0x02D8 (0x0004) [0x0000000000000003]              ( CPF_Edit | CPF_Const )
	unsigned long                                      m_bShowWhenQuestComplete : 1;                     		// 0x02DC (0x0004) [0x0000000000000003] [0x00000001] ( CPF_Edit | CPF_Const )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1486 ];

		return pClassPointer;
	};

};

UClass* ATgPointOfInterest::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor
// 0x0034 (0x0224 - 0x01F0)
class ATgSkeletalMeshActor : public ASkeletalMeshActor
{
public:
	struct FMeshAssets                                 c_MeshAssets;                                     		// 0x01F0 (0x0030) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      c_bLoadMeshAssetts : 1;                           		// 0x0220 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1487 ];

		return pClassPointer;
	};

	void DoKismetAttachment ( class AActor* Attachment, class USeqAct_AttachToActor* Action );
	void OnParentAnimComponent ( class UTgSeqAct_ParentAnimComponent* Action );
	void LoadClientOnlyMeshAssets ( );
	class UMeshComponent* CreateMeshComponent ( int MeshAsmId, class UMeshComponent* DestComponent, unsigned long bPartialFixup );
	class UTgStaticMeshComponent* CreateStaticMeshComponent ( int MeshAsmId, class UTgStaticMeshComponent* DestComponent );
	class UTgSkeletalMeshComponent* CreateSkeletalMeshComponent ( int MeshAsmId, class UTgSkeletalMeshComponent* DestComponent, unsigned long bPartialFixup );
	bool AttachToSocket ( class AActor* Attachment, struct FName BoneName );
};

UClass* ATgSkeletalMeshActor::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActorSpawnable
// 0x0000 (0x0224 - 0x0224)
class ATgSkeletalMeshActorSpawnable : public ATgSkeletalMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1488 ];

		return pClassPointer;
	};

};

UClass* ATgSkeletalMeshActorSpawnable::pClassPointer = NULL;

// Class TgGame.TgNavRouteIndicator
// 0x002C (0x0250 - 0x0224)
class ATgNavRouteIndicator : public ATgSkeletalMeshActorSpawnable
{
public:
	TArray< struct FVector >                           WayPoints;                                        		// 0x0224 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                Position;                                         		// 0x0230 (0x0004) [0x0000000000000000]              
	float                                              m_fPositionStartTime;                             		// 0x0234 (0x0004) [0x0000000000000000]              
	float                                              m_fPositionMaxSeekTime;                           		// 0x0238 (0x0004) [0x0000000000000000]              
	float                                              m_fSpinUpTime;                                    		// 0x023C (0x0004) [0x0000000000000000]              
	float                                              m_fSpinDownTime;                                  		// 0x0240 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_SpinUpFx;                                       		// 0x0244 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_PathingFx;                                      		// 0x0248 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_SpinDownFx;                                     		// 0x024C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1489 ];

		return pClassPointer;
	};

	void StartNextPath ( );
	void StartSeeking ( );
	unsigned char SetRouteTo ( class AActor* destActor );
	void Destroyed ( );
	bool AdvanceWayPoint ( );
	struct FVector GetCurrentWayPoint ( );
	unsigned char SetRoute ( struct FVector vDest );
	void DeactivatePathingFx ( );
	void DeactivateFx ( );
	void ActivatePathingFx ( );
	void ActivateSpinDownFx ( );
	void ActivateSpinUpFx ( );
};

UClass* ATgNavRouteIndicator::pClassPointer = NULL;

// Class TgGame.TgSkydiveTarget
// 0x0008 (0x01D4 - 0x01CC)
class ATgSkydiveTarget : public AActor
{
public:
	class UTgDrawSkydiveRadiusComponent*               m_PreviewSkydiveRadius;                           		// 0x01CC (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_LandRadius;                                     		// 0x01D0 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1490 ];

		return pClassPointer;
	};

};

UClass* ATgSkydiveTarget::pClassPointer = NULL;

// Class TgGame.TgStartPoint
// 0x002C (0x02EC - 0x02C0)
class ATgStartPoint : public APlayerStart
{
public:
	int                                                m_nMapObjectId;                                   		// 0x02C0 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_nStartGroup;                                    		// 0x02C4 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_nReturnMapType;                                 		// 0x02C8 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_nReturnMapGameId;                               		// 0x02CC (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              m_fStartRating;                                   		// 0x02D0 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              m_fCurrentRating;                                 		// 0x02D4 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              m_fResetRating;                                   		// 0x02D8 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	float                                              m_fDecreaseRate;                                  		// 0x02DC (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                AvailabilityQuestGroupId;                         		// 0x02E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FPointer                                    m_pAvlQuestGroup;                                 		// 0x02E4 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	class ATgStartpointPortalNetwork*                  TgPortalNetwork;                                  		// 0x02E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1491 ];

		return pClassPointer;
	};

	int GetStartGroupNumber ( );
	void AdjustRating ( );
	float GetRating ( class AController* Player );
	void PreBeginPlay ( );
	void LoadObjectConfig ( );
};

UClass* ATgStartPoint::pClassPointer = NULL;

// Class TgGame.TgTeamPlayerStart
// 0x001C (0x0308 - 0x02EC)
class ATgTeamPlayerStart : public ATgStartPoint
{
public:
	unsigned char                                      m_nTaskForce;                                     		// 0x02EC (0x0001) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned char                                      m_eCoalition;                                     		// 0x02ED (0x0001) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_nPriority;                                      		// 0x02F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nPrevPriority;                                    		// 0x02F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nMinLevel;                                      		// 0x02F8 (0x0004) [0x0000000000020000]              ( CPF_EditConst )
	TArray< class UTexture2D* >                        m_Sprites;                                        		// 0x02FC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1492 ];

		return pClassPointer;
	};

	float GetRating ( class AController* Player );
	void LoadObjectConfig ( );
};

UClass* ATgTeamPlayerStart::pClassPointer = NULL;

// Class TgGame.TgStartpointPortalNetwork
// 0x000C (0x01D8 - 0x01CC)
class ATgStartpointPortalNetwork : public AActor
{
public:
	TArray< class ATgStartPoint* >                     m_DestinationPoints;                              		// 0x01CC (0x000C) [0x0000000000500001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1493 ];

		return pClassPointer;
	};

};

UClass* ATgStartpointPortalNetwork::pClassPointer = NULL;

// Class TgGame.TgTeleporter
// 0x000E (0x02EE - 0x02E0)
class ATgTeleporter : public ATeleporter
{
public:
	int                                                m_nMapObjectId;                                   		// 0x02E0 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_nMapId;                                         		// 0x02E4 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_nPreload : 1;                                   		// 0x02E8 (0x0004) [0x0000000000020001] [0x00000001] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bSetTaskForce : 1;                              		// 0x02E8 (0x0004) [0x0000000000020001] [0x00000002] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bBalanceTaskForce : 1;                          		// 0x02E8 (0x0004) [0x0000000000020001] [0x00000004] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bIgnoreNonMembers : 1;                          		// 0x02E8 (0x0004) [0x0000000000020001] [0x00000008] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bUsePlayerStart : 1;                            		// 0x02E8 (0x0004) [0x0000000000020001] [0x00000010] ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bRequestMission : 1;                            		// 0x02E8 (0x0004) [0x0000000000020001] [0x00000020] ( CPF_Edit | CPF_EditConst )
	unsigned char                                      m_nStartGroup;                                    		// 0x02EC (0x0001) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned char                                      m_nTaskForce;                                     		// 0x02ED (0x0001) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1494 ];

		return pClassPointer;
	};

	bool eventUsePlayerStart ( class AActor* Other );
	void PostTouch ( class AActor* Other );
	void PostBeginPlay ( );
	void PreBeginPlay ( );
	void LoadObjectConfig ( );
	bool HandlePostTouch ( class AActor* Other );
};

UClass* ATgTeleporter::pClassPointer = NULL;

// Class TgGame.TgObjectiveAttachActor
// 0x002D (0x025D - 0x0230)
class ATgObjectiveAttachActor : public ATgDynamicSMActor
{
public:
	class UTgSkeletalMeshComponent*                    m_ObjectiveMesh;                                  		// 0x0230 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMaterialInstanceConstant*                   c_OuterObjectiveMIC;                              		// 0x0234 (0x0004) [0x0000000000000000]              
	struct FLinearColor                                c_CurrentOuterObjectiveColor;                     		// 0x0238 (0x0010) [0x0000000000000000]              
	struct FLinearColor                                c_TargetOuterObjectiveColor;                      		// 0x0248 (0x0010) [0x0000000000000000]              
	float                                              c_fCapturePct;                                    		// 0x0258 (0x0004) [0x0000000000000000]              
	unsigned char                                      c_CurrentObjectiveStatus;                         		// 0x025C (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1495 ];

		return pClassPointer;
	};

	void ClientOnStatusChange ( unsigned char Status, unsigned long bIsLocalPawnAttacker );
	bool eventEncroachingOn ( class AActor* Other );
	void eventRanInto ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void DrawHealth ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void ProcessEffect ( class UTgEffectGroup* Effect, unsigned long bRemove, class AActor* aInstigator, struct FImpactInfo Impact );
	void eventTakeDamage ( int Damage, class AController* EventInstigator, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
};

UClass* ATgObjectiveAttachActor::pClassPointer = NULL;

// Class TgGame.TgMissionObjective
// 0x0108 (0x02E8 - 0x01E0)
class ATgMissionObjective : public ATgMeshAssembly
{
public:
	int                                                m_nMapObjectId;                                   		// 0x01E0 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned long                                      bHasNoLocation : 1;                               		// 0x01E4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      r_bUsePendingState : 1;                           		// 0x01E4 (0x0004) [0x0000000000000021] [0x00000002] ( CPF_Edit | CPF_Net )
	unsigned long                                      s_bChangeCoalitionWhenCaptured : 1;               		// 0x01E4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bCaptureOnlyOnce : 1;                           		// 0x01E4 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      r_bHasBeenCapturedOnce : 1;                       		// 0x01E4 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      s_bEndOvertimeOnDefenderProgress : 1;             		// 0x01E4 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      bEnabled : 1;                                     		// 0x01E4 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      r_bIsLocked : 1;                                  		// 0x01E4 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      r_bIsActive : 1;                                  		// 0x01E4 (0x0004) [0x0000000000000020] [0x00000100] ( CPF_Net )
	unsigned long                                      r_bIsPending : 1;                                 		// 0x01E4 (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	unsigned long                                      m_bPauseOnCapture : 1;                            		// 0x01E4 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bLocalPawnIsAttacker : 1;                       		// 0x01E4 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bBlockAdvance : 1;                              		// 0x01E4 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bIsBaseObjective : 1;                           		// 0x01E4 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      c_bIsLocalPlayerAttacker : 1;                     		// 0x01E4 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      c_bLocalPlayerAttackerCached : 1;                 		// 0x01E4 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bInMatineeUpdate : 1;                           		// 0x01E4 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_bStartObjective : 1;                            		// 0x01E4 (0x0004) [0x0000000000000001] [0x00020000] ( CPF_Edit )
	unsigned long                                      s_bRandomPicked : 1;                              		// 0x01E4 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_bTeleportBots : 1;                              		// 0x01E4 (0x0004) [0x0000000000000000] [0x00080000] 
	int                                                nPriority;                                        		// 0x01E8 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	int                                                nMessageId;                                       		// 0x01EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nDefaultOwnerTaskForce;                           		// 0x01F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nObjectiveId;                                     		// 0x01F4 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	unsigned char                                      HexBonusDirection;                                		// 0x01F8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      r_OpenWorldPlayerDefaultRole;                     		// 0x01F9 (0x0001) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	unsigned char                                      r_eDefaultCoalition;                              		// 0x01FA (0x0001) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	unsigned char                                      r_eStatus;                                        		// 0x01FB (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eOwningCoalition;                               		// 0x01FC (0x0001) [0x0000000000000020]              ( CPF_Net )
	int                                                s_OpenWorldBotTaskForce;                          		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_fProximityRadius;                               		// 0x0204 (0x0004) [0x0000000000000000]              
	float                                              m_fProximityHeight;                               		// 0x0208 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeToCapture;                                 		// 0x020C (0x0004) [0x0000000000000000]              
	float                                              m_fTimeToHold;                                    		// 0x0210 (0x0004) [0x0000000000000000]              
	int                                                m_nPointsPerSecond;                               		// 0x0214 (0x0004) [0x0000000000000000]              
	int                                                m_nTypeId;                                        		// 0x0218 (0x0004) [0x0000000000000000]              
	int                                                m_nDescMsgId;                                     		// 0x021C (0x0004) [0x0000000000000000]              
	int                                                m_nIconId;                                        		// 0x0220 (0x0004) [0x0000000000000000]              
	int                                                m_nMinAgents;                                     		// 0x0224 (0x0004) [0x0000000000000000]              
	int                                                m_nCooldownSeconds;                               		// 0x0228 (0x0004) [0x0000000000000000]              
	int                                                m_nPoints;                                        		// 0x022C (0x0004) [0x0000000000000000]              
	int                                                m_nCredits;                                       		// 0x0230 (0x0004) [0x0000000000000000]              
	int                                                m_nRewardXP;                                      		// 0x0234 (0x0004) [0x0000000000000000]              
	int                                                m_nLootTableId;                                   		// 0x0238 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_fCurrCaptureTime;                               		// 0x023C (0x0004) [0x0000000000000000]              
	int                                                m_nCurrOwnerTaskforce;                            		// 0x0240 (0x0004) [0x0000000000000000]              
	int                                                r_nOwnerTaskForce;                                		// 0x0244 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgObjectiveAssignment*                      r_ObjectiveAssignment;                            		// 0x0248 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fCurrCaptureTime;                               		// 0x024C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nCaptureTimeExtSecs;                            		// 0x0250 (0x0004) [0x0000000000000000]              
	int                                                m_nCaptureTimeResetSecs;                          		// 0x0254 (0x0004) [0x0000000000000000]              
	float                                              s_fAttackerCapturedAt;                            		// 0x0258 (0x0004) [0x0000000000000000]              
	float                                              r_fLastCompletedTime;                             		// 0x025C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fPercentage;                                    		// 0x0260 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_TagArrowCaptureMIC;                             		// 0x0264 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_TagArrowDefendMIC;                              		// 0x0268 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_TagIconGlyphMIC;                                		// 0x026C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_TagArrowCaptureMICParent;                       		// 0x0270 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_TagArrowDefendMICParent;                        		// 0x0274 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_TagGlyphLastParent;                             		// 0x0278 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_TagGlyphAttack;                                 		// 0x027C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_TagGlyphDefend;                                 		// 0x0280 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_TagGlyphGoto;                                   		// 0x0284 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_TagGlyphGetin;                                  		// 0x0288 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgSpecialFx*                                c_fxActivated;                                    		// 0x028C (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_fxContested;                                    		// 0x0290 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_fxPending;                                      		// 0x0294 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     c_LocalPlayerPawn;                                		// 0x0298 (0x0004) [0x0000000000000000]              
	class UTgSpriteComponent*                          c_SpriteComponent;                                		// 0x029C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              s_fPreviousPlayRate;                              		// 0x02A0 (0x0004) [0x0000000000000000]              
	class USeqAct_Interp*                              s_CachedMatineeNode;                              		// 0x02A4 (0x0004) [0x0000000000000000]              
	float                                              m_fStartTime;                                     		// 0x02A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fStopTime;                                      		// 0x02AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class ANavigationPoint* >                  AttackerAssaultNav;                               		// 0x02B0 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	TArray< class ANavigationPoint* >                  DefenderAssaultNav;                               		// 0x02BC (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	TArray< class ATgBotFactory* >                     MyFactories;                                      		// 0x02C8 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	TArray< int >                                      NextPriority;                                     		// 0x02D4 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	int                                                s_nPreviousPriority;                              		// 0x02E0 (0x0004) [0x0000000000000000]              
	int                                                s_nCurrentSpawnOrder;                             		// 0x02E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1496 ];

		return pClassPointer;
	};

	void eventUpdateObjectiveBasedMICs ( float PlayRate );
	void eventTick ( float DeltaTime );
	void eventSetMatineePlayRate ( float PlayRate );
	void eventSetMatineePosition ( float Position );
	void eventTriggerNodeCommander ( int nWhichInputToActivate );
	void eventAssignmentChanged ( int nWhichInputToActivate );
	void eventSelectObjective ( );
	void eventLockObjective ( );
	void eventUnlockObjective ( unsigned long bActivateObjective );
	bool eventShouldBlockNextObjective ( );
	void OnObjectiveStatusChange ( );
	void OnEndObjectiveAssignment ( class UTgSeqAct_EndObjectiveAssignment* Action );
	void OnActivateObjective ( class UTgSeqAct_ActivateObjective* Action );
	bool eventUpdateObjectiveStatus ( unsigned char eStatus );
	void eventObjectiveOverTimeNotify ( );
	class AActor* eventGetLocationActor ( );
	struct FVector eventGetDisplayLocation ( );
	unsigned char eventGetDefaultStatus ( );
	void eventResetObjective ( );
	void PostBeginPlay ( );
	void PreBeginPlay ( );
	void eventDrawTaggedElements ( class APlayerController* thePlayerController, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	bool eventIsLocalPlayerAttacker ( unsigned long bForceEvaluate );
	bool eventIsCapturePaused ( );
	bool eventIsCaptureInProgress ( );
	bool eventIsContested ( );
	bool eventIsFriendlyWithLocalPawn ( );
	void ClientCalcCapturePerc ( );
	void ClientOnLocalPawnGroupChange ( );
	class ATgPawn* FindLocalPlayerPawn ( );
	bool InitLocalPawnForActiveState ( );
	void eventReplicatedEvent ( struct FName VarName );
	struct FObjectiveMICInfo FillOutObjectiveMICInfo ( );
	void OnSetUITextBox ( class UTgSeqAct_SetUITextBox* Action );
	void AwardObjectiveLoot ( );
	void UpdateMatineeNodeStatus ( unsigned char eStatus );
	float AttackerTimeTakenToCapture ( );
	void OnActiveStateChanged ( );
	void SetTagParameters ( class ATgPlayerController* tgpc, class UMaterialInstanceConstant* tagMIC, unsigned long bNoChangeParent );
	void DrawObjectiveTag ( class APlayerController* thePlayerController, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir, struct FVector vLocation );
	void DrawOffscreenObjectivePointer ( class UCanvas* Canvas, struct FVector ScreenLoc );
	bool IsDefenderTaskForceNumber ( int nTaskForce );
	bool IsDefenderTaskForce ( class ATgRepInfo_TaskForce* tfri );
	bool IsAttackerTaskForceNumber ( int nTaskForce );
	bool IsAttackerTaskForce ( class ATgRepInfo_TaskForce* tfri );
	bool IsValidTaskForceNumber ( int nTaskForce );
	bool IsValidTaskForce ( class ATgRepInfo_TaskForce* tfri );
	bool IsValidForLocalPlayer ( );
	void UpdateSpawnOrder ( int nCurrent );
	void TeleportBots ( );
	void SendServerObjectiveCaptured ( unsigned long bAttackerCaptured );
	void RegisterSelf ( );
	void UpdateFxVisibility ( );
	void RecalculateFx ( );
	void LoadMesh ( );
	void LoadObjectConfig ( );
	void AddToList ( );
	void SetDoorsActive ( unsigned long bActive );
	void SetSpawnersActive ( unsigned long bActive );
	void SetObjectiveActive ( unsigned long bActive );
	void SetObjectivePending ( unsigned long bPending );
};

UClass* ATgMissionObjective::pClassPointer = NULL;

// Class TgGame.TgMissionObjective_Bot
// 0x002C (0x0314 - 0x02E8)
class ATgMissionObjective_Bot : public ATgMissionObjective
{
public:
	class ATgPawn*                                     r_ObjectiveBot;                                   		// 0x02E8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Player*                           r_ObjectiveBotInfo;                               		// 0x02EC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nBotId;                                         		// 0x02F0 (0x0004) [0x0000000000000000]              
	int                                                s_nSpawnTableId;                                  		// 0x02F4 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bAutoSpawn : 1;                                 		// 0x02F8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bPatrolLoop : 1;                                  		// 0x02F8 (0x0004) [0x0000000000020001] [0x00000002] ( CPF_Edit | CPF_EditConst )
	float                                              fBalance;                                         		// 0x02FC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class ANavigationPoint* >                  PatrolPath;                                       		// 0x0300 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class ANavigationPoint*                            SafetyLocation;                                   		// 0x030C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                nGlobalAlarmId;                                   		// 0x0310 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1497 ];

		return pClassPointer;
	};

	void OnHackBot ( class UTgSeqAct_HackBot* inAction );
	void OnAlarmBots ( class UTgSeqAct_AlarmBots* Action );
	void OnJoinTeam ( class UTgSeqAct_JoinTeam* Action );
	void OnTriggerBots ( class UTgSeqAct_TriggerBots* Action );
	void OnGetBot ( class UTgSeqAct_GetBot* inAction );
	void eventOnDespawnBots ( class UTgSeqAct_DespawnBots* inAction );
	void eventOnKillBots ( class UTgSeqAct_KillBots* inAction );
	bool eventUpdateObjectiveStatus ( unsigned char eStatus );
	void ServerCalcStatus ( float DeltaTime );
	void ClientCalcCapturePerc ( );
	void Tick ( float DeltaTime );
	void eventDrawTaggedElements ( class APlayerController* thePlayerController, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	bool eventIsFriendlyWithLocalPawn ( );
	void eventResetObjective ( );
	class AActor* eventGetLocationActor ( );
	struct FVector eventGetDisplayLocation ( );
	void PostBeginPlay ( );
	void SetTagParameters ( class ATgPlayerController* tgpc, class UMaterialInstanceConstant* tagMIC, unsigned long bNoChangeParent );
	void RequestLoadResources ( );
	void SpawnObjectiveBot ( );
	void SetObjectiveActive ( unsigned long bActive );
	void LoadObjectConfig ( );
};

UClass* ATgMissionObjective_Bot::pClassPointer = NULL;

// Class TgGame.TgBaseObjective_CTFBot
// 0x000C (0x0320 - 0x0314)
class ATgBaseObjective_CTFBot : public ATgMissionObjective_Bot
{
public:
	float                                              m_fFlagRespawnDelay;                              		// 0x0314 (0x0004) [0x0000000000000000]              
	float                                              m_fScoringRadius;                                 		// 0x0318 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bSpawnUnalignedBot : 1;                         		// 0x031C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bCaptureOnDeath : 1;                            		// 0x031C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1498 ];

		return pClassPointer;
	};

	void ServerCalcStatus ( float DeltaTime );
	void eventDrawTaggedElements ( class APlayerController* thePlayerController, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void eventOnFlagConsumed ( class ATgPawn* consumer );
	void eventOnFlagUncrewed ( class ATgPawn* Target );
	void eventOnFlagPickedUp ( class ATgPawn* Target );
	void eventOnTimerRemoveImmunity ( );
	bool eventCaptureFlag ( class ATgPawn* capturingbot );
	void eventAddFlagToObjectiveBot ( );
	void eventRequestFlagSpawn ( );
	unsigned char eventGetDefaultStatus ( );
	void eventResetObjective ( );
	void SetTagParameters ( class ATgPlayerController* tgpc, class UMaterialInstanceConstant* tagMIC, unsigned long bNoChangeParent );
	void SendFlagConsumedMessage ( );
	void SendFlagSpawnedMessage ( );
	void SendFlagCapturedMessage ( int nFriendlyTaskForce );
	void SendFlagPickedUpMessage ( int nFriendlyTaskForce );
	void SpawnObjectiveBot ( );
	void SetObjectiveActive ( unsigned long bActive );
	void RemoveFlagFromPlayField ( );
};

UClass* ATgBaseObjective_CTFBot::pClassPointer = NULL;

// Class TgGame.TgMissionObjective_Kismet
// 0x0000 (0x02E8 - 0x02E8)
class ATgMissionObjective_Kismet : public ATgMissionObjective
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1499 ];

		return pClassPointer;
	};

	bool eventUpdateObjectiveStatus ( unsigned char eStatus );
	void OnTriggerEventObjective ( class UTgSeqAct_TriggerEventObjective* Action );
};

UClass* ATgMissionObjective_Kismet::pClassPointer = NULL;

// Class TgGame.TgMissionObjective_Proximity
// 0x0020 (0x0308 - 0x02E8)
class ATgMissionObjective_Proximity : public ATgMissionObjective
{
public:
	class ATgCollisionProxy*                           s_CollisionProxy;                                 		// 0x02E8 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bAllowAIBotInteraction : 1;                     		// 0x02EC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bAllowRemoteControlBotInteraction : 1;          		// 0x02EC (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fDefCaptureRate;                                		// 0x02F0 (0x0004) [0x0000000000000000]              
	float                                              m_fCaptureAccelRate;                              		// 0x02F4 (0x0004) [0x0000000000000000]              
	float                                              m_fCaptureAccelRateCap;                           		// 0x02F8 (0x0004) [0x0000000000000000]              
	float                                              r_fCaptureRate;                                   		// 0x02FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fOvertimeAccelRate;                             		// 0x0300 (0x0004) [0x0000000000000000]              
	class AActor*                                      LocationActor;                                    		// 0x0304 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1500 ];

		return pClassPointer;
	};

	bool eventUpdateObjectiveStatus ( unsigned char eStatus );
	float CalculateAdjDeltaTime ( float fDeltaTime, float fAdjustedRate );
	void CalculateNearByPlayers ( float fDeltaTime );
	class AActor* eventGetLocationActor ( );
	void InvalidateHoldTimer ( );
	void CheckHoldTime ( );
	void OnOwnerTaskForceChange ( int nCurrOwnerTaskForce );
	void GetNearbyPlayerPresence ( int* nNumAttackers, int* nNumDefenders, int* nFirstAttackerTaskForce, int* nFirstDefenderTaskForce );
	bool ShouldIgnoreOwnerEvent ( class AActor* Other );
	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void ClientCalcCapturePerc ( );
	void ClientTickProgress ( float fDeltaTime );
	void ClientResetFx ( );
	void ClientOnStatusChange ( );
	void ClientPlayInitialContestedFx ( );
	void eventReplicatedEvent ( struct FName VarName );
	void Tick ( float DeltaTime );
	void PostBeginPlay ( );
	void ScoreObjectiveProgress ( float fDeltaTime );
	void LoadObjectConfig ( );
};

UClass* ATgMissionObjective_Proximity::pClassPointer = NULL;

// Class TgGame.TgMissionObjective_Escort
// 0x0004 (0x030C - 0x0308)
class ATgMissionObjective_Escort : public ATgMissionObjective_Proximity
{
public:
	class AActor*                                      r_AttachedActor;                                  		// 0x0308 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1501 ];

		return pClassPointer;
	};

	void ClientCalcCapturePerc ( );
	void ClientOnStatusChange ( );
	void OnOwnerTaskForceChange ( int nCurrOwnerTaskForce );
	void CalculateNearByPlayers ( float fDeltaTime );
	class AActor* eventGetLocationActor ( );
	void eventReplicatedEvent ( struct FName VarName );
	void PostBeginPlay ( );
};

UClass* ATgMissionObjective_Escort::pClassPointer = NULL;

// Class TgGame.TgObjectiveAssignment
// 0x0018 (0x01E4 - 0x01CC)
class ATgObjectiveAssignment : public AReplicationInfo
{
public:
	class ATgMissionObjective*                         r_AssignedObjective;                              		// 0x01CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_TaskForce*                        r_Attackers;                                      		// 0x01D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_TaskForce*                        r_Defenders;                                      		// 0x01D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_TaskForce*                        r_Bots;                                           		// 0x01D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eState;                                         		// 0x01DC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_ePreviousState;                                 		// 0x01DD (0x0001) [0x0000000000000000]              
	unsigned long                                      c_bWasValidForLocalPlayer : 1;                    		// 0x01E0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1502 ];

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void OnClientStateUpdated ( );
	float GetTimeRemaining ( );
	void eventUpdateClientTimer ( float fSeconds );
	void SetAssignmentTimer ( float fSeconds );
	void AssignmentTimer ( );
	void ObjectiveEndAssignment ( class UTgSeqAct_EndObjectiveAssignment* Action );
	void ObjectiveTaken ( class ATgMissionObjective* Objective );
	void ObjectiveBegun ( class ATgMissionObjective* Objective );
	bool IsFinished ( );
	bool IsActive ( );
	bool IsPending ( );
	bool IsDefender ( class ATgRepInfo_TaskForce* tf );
	bool IsAttacker ( class ATgRepInfo_TaskForce* tf );
	bool IsValidForTaskforceNumber ( int nTaskNum );
	bool IsValidForTaskforce ( class ATgRepInfo_TaskForce* tf );
	bool IsValidForLocalPlayer ( );
};

UClass* ATgObjectiveAssignment::pClassPointer = NULL;

// Class TgGame.TgAIController
// 0x03D8 (0x0744 - 0x036C)
class ATgAIController : public AAIController
{
public:
	class AActor*                                      m_pMovementTarget;                                		// 0x036C (0x0004) [0x0000000000000000]              
	class AActor*                                      m_pNextMovementPath;                              		// 0x0370 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vMovementLocation;                              		// 0x0374 (0x000C) [0x0000000000000000]              
	class ATgPawn*                                     m_pFriendToHelp;                                  		// 0x0380 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetAcquiredTime;                            		// 0x0384 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetLastSeenTime;                            		// 0x0388 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetLastClearLOSTime;                        		// 0x038C (0x0004) [0x0000000000000000]              
	float                                              m_fChaseTime;                                     		// 0x0390 (0x0004) [0x0000000000000000]              
	float                                              m_fChaseRange;                                    		// 0x0394 (0x0004) [0x0000000000000000]              
	float                                              m_fLastUnderFire;                                 		// 0x0398 (0x0004) [0x0000000000000000]              
	float                                              m_fLastUnderAOEFire;                              		// 0x039C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bHasGrenadeThreat : 1;                          		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bInterrupt : 1;                                 		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bAnimationInterrupt : 1;                        		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bFired : 1;                                     		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bHibernateInvulFlag : 1;                        		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bDelayAction : 1;                               		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bHeadShot : 1;                                  		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bHitWall : 1;                                   		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bBump : 1;                                      		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bShuffle : 1;                                   		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bEnableLog : 1;                                 		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bActionlessPause : 1;                           		// 0x03A0 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bReevaluateTests : 1;                           		// 0x03A0 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      m_bFirstSighting : 1;                             		// 0x03A0 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bAlarmBot : 1;                                  		// 0x03A0 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      m_bPatrolLoop : 1;                                		// 0x03A0 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bPathForward : 1;                               		// 0x03A0 (0x0004) [0x0000000000000000] [0x00010000] 
	class ATgPawn*                                     m_pLastAttacker;                                  		// 0x03A4 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vLastTargetLocation;                            		// 0x03A8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vLastTargetLocation2;                           		// 0x03B4 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vLagTargetLocation;                             		// 0x03C0 (0x000C) [0x0000000000000000]              
	float                                              m_fMinAggroRadius;                                		// 0x03CC (0x0004) [0x0000000000000000]              
	float                                              m_fHelpRange;                                     		// 0x03D0 (0x0004) [0x0000000000000000]              
	float                                              m_fStealthSensorRange;                            		// 0x03D4 (0x0004) [0x0000000000000000]              
	float                                              m_fStealthAggroRange;                             		// 0x03D8 (0x0004) [0x0000000000000000]              
	int                                                m_nCommandStance;                                 		// 0x03DC (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_pCommandTarget;                                 		// 0x03E0 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vCommandLocation;                               		// 0x03E4 (0x000C) [0x0000000000000000]              
	int                                                m_nMoveDestinationCode;                           		// 0x03F0 (0x0004) [0x0000000000000000]              
	int                                                m_nMovementCode;                                  		// 0x03F4 (0x0004) [0x0000000000000000]              
	int                                                m_nActionCode;                                    		// 0x03F8 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetCode;                                    		// 0x03FC (0x0004) [0x0000000000000000]              
	int                                                m_nPaceCode;                                      		// 0x0400 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_eEquipmentSlot;                                 		// 0x0404 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eSecondaryEquipmentSlot;                        		// 0x0405 (0x0001) [0x0000000000000000]              
	int                                                m_nDeviceMode;                                    		// 0x0408 (0x0004) [0x0000000000000000]              
	int                                                m_nSecondaryDeviceMode;                           		// 0x040C (0x0004) [0x0000000000000000]              
	int                                                m_nLastActionCode;                                		// 0x0410 (0x0004) [0x0000000000000000]              
	class ATgBotFactory*                               m_pFactory;                                       		// 0x0414 (0x0004) [0x0000000000000000]              
	int                                                m_nFactorySpawnGroup;                             		// 0x0418 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_pLastHelper;                                    		// 0x041C (0x0004) [0x0000000000000000]              
	float                                              m_fLastHelpedTime;                                		// 0x0420 (0x0004) [0x0000000000000000]              
	float                                              m_fLastMoveTime;                                  		// 0x0424 (0x0004) [0x0000000000000000]              
	float                                              m_fLastRadioAlarmTime;                            		// 0x0428 (0x0004) [0x0000000000000000]              
	float                                              m_fLastSpawnPetTime;                              		// 0x042C (0x0004) [0x0000000000000000]              
	float                                              m_fLastCallForHelpTime;                           		// 0x0430 (0x0004) [0x0000000000000000]              
	float                                              m_fLastICalledForHelpTime;                        		// 0x0434 (0x0004) [0x0000000000000000]              
	float                                              m_fLastSoundTime;                                 		// 0x0438 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_pLastSoundActor;                                		// 0x043C (0x0004) [0x0000000000000000]              
	float                                              m_fLastInterruptTime;                             		// 0x0440 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vLastLocation;                                  		// 0x0444 (0x000C) [0x0000000000000000]              
	class ATgCoverPoint*                               m_pCover;                                         		// 0x0450 (0x0004) [0x0000000000000000]              
	class ATgCoverPoint*                               m_pNextCover;                                     		// 0x0454 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_pTriggerTarget;                                 		// 0x0458 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_pTriggerDestination;                            		// 0x045C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vTriggerLocation;                               		// 0x0460 (0x000C) [0x0000000000000000]              
	class ATgPawn*                                     m_pOwner;                                         		// 0x046C (0x0004) [0x0000000000000000]              
	float                                              m_fOwnerDeadTime;                                 		// 0x0470 (0x0004) [0x0000000000000000]              
	int                                                m_nAnimationId;                                   		// 0x0474 (0x0004) [0x0000000000000000]              
	float                                              m_fAnimationSeconds;                              		// 0x0478 (0x0004) [0x0000000000000000]              
	int                                                m_nPostureOverride;                               		// 0x047C (0x0004) [0x0000000000000000]              
	float                                              m_fIdleTime;                                      		// 0x0480 (0x0004) [0x0000000000000000]              
	float                                              m_fLastFireTime;                                  		// 0x0484 (0x0004) [0x0000000000000000]              
	int                                                m_nHibernateIdleSec;                              		// 0x0488 (0x0004) [0x0000000000000000]              
	float                                              m_fHibernateDelayRate;                            		// 0x048C (0x0004) [0x0000000000000000]              
	int                                                m_nIdleLoops;                                     		// 0x0490 (0x0004) [0x0000000000000000]              
	float                                              m_fLastSawEnemy;                                  		// 0x0494 (0x0004) [0x0000000000000000]              
	float                                              m_fLastSawTaunter;                                		// 0x0498 (0x0004) [0x0000000000000000]              
	float                                              m_fLastSawDeadFriend;                             		// 0x049C (0x0004) [0x0000000000000000]              
	class ATgAlarmPoint*                               m_pNextAlarm;                                     		// 0x04A0 (0x0004) [0x0000000000000000]              
	float                                              m_fProximityRange;                                		// 0x04A4 (0x0004) [0x0000000000000000]              
	float                                              m_fPauseDurationSecs;                             		// 0x04A8 (0x0004) [0x0000000000000000]              
	class ATgActionPoint*                              m_pLastActionPoint;                               		// 0x04AC (0x0004) [0x0000000000000000]              
	class ATgActionPoint*                              m_pUsedActionPoint;                               		// 0x04B0 (0x0004) [0x0000000000000000]              
	float                                              m_fLastActionTime;                                		// 0x04B4 (0x0004) [0x0000000000000000]              
	int                                                m_fFixedFOV;                                      		// 0x04B8 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_rFixedDirection;                                		// 0x04BC (0x000C) [0x0000000000000000]              
	int                                                m_nLookAtCode;                                    		// 0x04C8 (0x0004) [0x0000000000000000]              
	int                                                m_nInteractionId;                                 		// 0x04CC (0x0004) [0x0000000000000000]              
	int                                                m_nDefaultPosture;                                		// 0x04D0 (0x0004) [0x0000000000000000]              
	float                                              m_fSleepSecs;                                     		// 0x04D4 (0x0004) [0x0000000000000000]              
	int                                                m_nTargetPhysicalType;                            		// 0x04D8 (0x0004) [0x0000000000000000]              
	class ATgActionPoint*                              m_pEmptyActionPoint;                              		// 0x04DC (0x0004) [0x0000000000000000]              
	float                                              m_fClearCacheTime;                                		// 0x04E0 (0x0004) [0x0000000000000000]              
	int                                                m_nGlobalAlarmId;                                 		// 0x04E4 (0x0004) [0x0000000000000000]              
	int                                                m_nPriority;                                      		// 0x04E8 (0x0004) [0x0000000000000000]              
	float                                              m_fLastStartledTime;                              		// 0x04EC (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vIndirectFire;                                  		// 0x04F0 (0x000C) [0x0000000000000000]              
	float                                              m_fLastTargetUpdateTime;                          		// 0x04FC (0x0004) [0x0000000000000000]              
	float                                              m_fDirection;                                     		// 0x0500 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetDiedTime;                                		// 0x0504 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vDriveByDestination;                            		// 0x0508 (0x000C) [0x0000000000000000]              
	float                                              m_fDriveByTime;                                   		// 0x0514 (0x0004) [0x0000000000000000]              
	class ALadderVolume*                               m_Ladder;                                         		// 0x0518 (0x0004) [0x0000000000000000]              
	float                                              m_fLastSoundCueTime;                              		// 0x051C (0x0004) [0x0000000000000000]              
	float                                              m_fLastTargetHitTime;                             		// 0x0520 (0x0004) [0x0000000000000000]              
	float                                              m_fLastEnemyHitTime;                              		// 0x0524 (0x0004) [0x0000000000000000]              
	float                                              m_fLastTargetReachableTime;                       		// 0x0528 (0x0004) [0x0000000000000000]              
	int                                                m_nPhaseDamageTaken;                              		// 0x052C (0x0004) [0x0000000000000000]              
	int                                                m_nSquadRole;                                     		// 0x0530 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vUnreachableLocation;                           		// 0x0534 (0x000C) [0x0000000000000000]              
	class AActor*                                      m_pUnreachableNearestPath;                        		// 0x0540 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vFormationOffset;                               		// 0x0544 (0x000C) [0x0000000000000000]              
	float                                              m_fLastRegenTime;                                 		// 0x0550 (0x0004) [0x0000000000000000]              
	float                                              m_fLastEnterCombatTime;                           		// 0x0554 (0x0004) [0x0000000000000000]              
	float                                              m_fLastLeftCombatTime;                            		// 0x0558 (0x0004) [0x0000000000000000]              
	int                                                m_fLastGenericEvent;                              		// 0x055C (0x0004) [0x0000000000000000]              
	float                                              m_fLastGenericEventTime;                          		// 0x0560 (0x0004) [0x0000000000000000]              
	int                                                m_nFindPathCallCount;                             		// 0x0564 (0x0004) [0x0000000000000000]              
	float                                              m_fPathCallResetTime;                             		// 0x0568 (0x0004) [0x0000000000000000]              
	TArray< struct FThreatStruct >                     m_ThreatList;                                     		// 0x056C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	float                                              m_fSlotFireTime[ 0x19 ];                          		// 0x0578 (0x0064) [0x0000000000000000]              
	TArray< class ANavigationPoint* >                  m_PatrolPath;                                     		// 0x05DC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ANavigationPoint*                            m_NextPatrol;                                     		// 0x05E8 (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            m_LastPatrol;                                     		// 0x05EC (0x0004) [0x0000000000000000]              
	class ANavigationPoint*                            m_pSafetyLocation;                                		// 0x05F0 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vSpawnLocation;                                 		// 0x05F4 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rSpawnDirection;                                		// 0x0600 (0x000C) [0x0000000000000000]              
	float                                              m_fLastPatrolStop;                                		// 0x060C (0x0004) [0x0000000000000000]              
	TArray< class ANavigationPoint* >                  m_ObjectiveNav;                                   		// 0x0610 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ANavigationPoint* >                  m_ObjectiveNavEnemy;                              		// 0x061C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nPathIndex;                                     		// 0x0628 (0x0004) [0x0000000000000000]              
	struct FString                                     m_sForceAction;                                   		// 0x062C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_sAction;                                        		// 0x0638 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_DebugScriptStats[ 0x28 ];                       		// 0x0644 (0x00A0) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     s_lastLookDirection;                              		// 0x06E4 (0x000C) [0x0000000000000000]              
	float                                              s_leakyVelocityAvg;                               		// 0x06F0 (0x0004) [0x0000000000000000]              
	int                                                s_nOrigTaskForce;                                 		// 0x06F4 (0x0004) [0x0000000000000000]              
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x06F8 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgAIController.m_SeePawnCache
	struct FPointer                                    s_ResultCache;                                    		// 0x0734 (0x0004) [0x0000000000000000]              
	struct FPointer                                    m_pBaseBehavior;                                  		// 0x0738 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FPointer                                    m_pBot;                                           		// 0x073C (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FPointer                                    m_pAction;                                        		// 0x0740 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1503 ];

		return pClassPointer;
	};

	void SetPawnDebug ( );
	struct FName eventGetStateNameEx ( );
	void eventServerReleasePet ( );
	void eventControlPet ( );
	void EndSuspend ( );
	void eventSuspend ( float SuspendLength, unsigned long bPauseAI );
	void ReviveTimer ( );
	void eventRevive ( );
	void eventDoPause ( float PauseLength );
	void SetActionlessPause ( unsigned long bOn );
	void eventPauseAI ( unsigned long bStart, float fPauseDuration, unsigned long bForceNewPauseDuration );
	void Stun ( unsigned long bStunController, unsigned char eType );
	struct FRotator GetAdjustedAimFor ( class AWeapon* W, struct FVector StartFireLoc );
	void PawnDied ( class APawn* P );
	void eventLookForSquad ( class ATgPawn* BotOwner );
	void CallForHelp ( );
	bool UseDevice ( unsigned char eEquipmentSlot, int nMode, unsigned long bSecondary, unsigned long bEquipOnly );
	void DoBlock ( unsigned long bOn, unsigned char eEquipmentSlot );
	void eventCauseConsoleEvent ( struct FName EventName );
	class AActor* GetFriendsTarget ( );
	class ATgPawn* GetFriendsAttacker ( );
	class ATgPawn* TargetClosestPlayer ( );
	class ATgPawn* TargetRandomPlayer ( unsigned long bIgnoreLos );
	void eventLoseTarget ( );
	void SetFormationLocation ( );
	void SetMovementLocation ( struct FVector TargetLocation );
	void SetMovementLocationFromActor ( class AActor* TargetActor );
	void SetMovementTarget ( class AActor* MovementTarget );
	class ANavigationPoint* GetNextPatrolPoint ( );
	bool CylinderContainsPoint ( struct FVector vLoc, int nRadius, int nHeight, struct FVector vPoint );
	void eventSetTarget ( int nTargetCode );
	void SetMovement ( int nDestinationCode );
	void eventSetPace ( int nPaceCode );
	void eventSetPosture ( int nPosture, unsigned long bForce, float fRateScale, unsigned long bIgnoreTransition );
	void ExecuteAction ( );
	void DespawnAlarmBots ( );
	void eventDespawn ( );
	void StopDevices ( );
	void eventUseDevices ( );
	float eventGetTargetAngle ( );
	void SetFocus ( int nLookAtCode );
	void CheckSelfDestruct ( );
	void eventSuicide ( );
	void CheckContinuousFire ( );
	bool UsingDevice ( );
	void eventSetWhatToDoNext ( int nMovementCode, int nMoveDestination );
	void WhatToDoNext ( );
	bool CheckDestinationRange ( );
	bool CheckLocationRange ( );
	void Regenerate ( );
	void MovementUpdate ( );
	struct FVector GetSpreadLocation ( );
	struct FVector GetBackstepLocation ( unsigned long bFarBackup );
	struct FVector GetRandomDestination ( float Dist );
	struct FVector GetCircleEnemyLocation ( );
	bool IsStuck ( );
	class AActor* GetObjectivePath ( );
	class AActor* GetObjectiveNav ( unsigned long bEnemy );
	bool StopHibernating ( );
	float eventExecActionTest ( int nActionTest );
	void NotifyDamagedTarget ( class ATgPawn* TargetPawn );
	void NotifyWeaponFired ( class AWeapon* W, unsigned char FireMode );
	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void OnTriggerBots ( class UTgSeqAct_TriggerBots* Action );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void eventHearNoise ( float Loudness, class AActor* NoiseMaker, struct FName NoiseType );
	void eventSeePlayer ( class APawn* SeenPlayer );
	void eventFalling ( );
	bool eventNotifyHitWall ( struct FVector HitNormal, class AActor* Wall );
	bool eventNotifyBump ( class AActor* Other, struct FVector HitNormal );
	void TargetHighestThreat ( );
	void OnPhaseChange ( );
	void OnEnterCombat ( );
	void OnExitCombat ( );
	void InitPlayerReplicationInfo ( );
	void Restart ( unsigned long bVehicleTransition );
	void Possess ( class APawn* aPawn, unsigned long bVehicleTransition, unsigned long bIgnoreTouchEvent );
	float GetBossRoomAlarmBotCount ( );
	float GetBossRoomHumanEnemyCount ( );
	float TargetHealthRatio ( );
	float FriendToEnemyRatio ( );
	float NumFriendsInRange ( int nRange );
	float NumHumanFriends ( );
	bool EnemyRecentlyUnstealthed ( );
	float WeakestFriendHealth ( int nPhysicalType );
	bool TargetIsProfileType ( int nProfileType );
	bool IsBehindTarget ( );
	bool IsTargetInMeleeeAttack ( );
	bool IsTargetMeleeEquipped ( );
	bool IsTargetBlocking ( );
	bool IsTargetStealthed ( );
	bool IsTargetStunned ( );
	bool TargetIsReachable ( );
	class ATgPawn* FindWeakestTarget ( unsigned long bEnemy, int nPhysicalType );
	class ATgPawn* FindClosestTaunter ( );
	class ATgPawn* FindClosestTarget ( unsigned long bEnemy, int nPhysicalType, int nProfileType, unsigned long bIgnoreLos );
	class ATgDeployable* NearestDeployable ( unsigned long bEnemy, unsigned long bFirst );
	bool IsDeployableDead ( class ATgDeployable* Deployable );
	bool IsPawnDead ( class ATgPawn* DeadPawn );
	void CheckForDeadTarget ( );
	float GetTargetProperty ( int nPropertyId );
	bool InvalidDestination ( struct FVector vDest );
	bool IsCliff ( struct FVector vDest );
	bool AtNavPoint ( class ANavigationPoint* Point );
	bool AtLocation ( struct FVector vLocation );
	bool AtCover ( );
	bool AtActor ( class AActor* pActor );
	bool AtActionPoint ( int Action );
	bool AtCoverForTarget ( );
	bool AtCommandDestination ( );
	float DistanceFromCommandDestination ( );
	void DestroyCommandBeacon ( );
	bool IsValidCoverForTarget ( class ATgCoverPoint* Cover );
	float DistanceFromQuickestCover ( );
	class ATgCoverPoint* GetQuickestCoverForTarget ( unsigned long bUseCache );
	class ATgCoverPoint* GetCloserCoverForTarget ( unsigned long bUseCache );
	bool IsValidCoverForGoto ( class ATgCoverPoint* Cover );
	class ATgCoverPoint* GetCloserCoverForGoto ( unsigned long bUseCache );
	class ATgCoverPoint* GetClosestCover ( );
	bool IsSquadFollower ( );
	bool IsSquadLeader ( );
	float TimeSinceTargetInLOS ( );
	bool InDriveBy ( );
	bool IsDeviceReady ( unsigned char eEquipmentSlot );
	float GetCurrentObjectivePercent ( );
	float TimeElapsed ( float fEventTime );
	bool CheckLastLocation ( );
	class AActor* CheckLastTarget ( );
	bool CheckLastAttacker ( );
	float TimeSinceHearHelpCall ( );
	float TimeSinceHearSound ( );
	bool ThreatendedByGrenade ( );
	bool RecentAOEDamage ( );
	bool RecentDamage ( );
	bool IsRecent ( float fTime );
	bool HasHelp ( );
	bool HeardSound ( );
	bool HelpRequested ( );
	bool CanBeRepaired ( );
	bool FriendHasAttacker ( );
	bool FriendHasTarget ( );
	bool IsIdle ( );
	bool IsHibernating ( );
	bool IsStealthed ( );
	bool HasDriveByDestination ( );
	bool HighestThreatInLOS ( );
	bool LastAttackerInLOS ( );
	bool TargetInLOS ( );
	bool TargetInIndirectFire ( );
	bool TargetInEncounterVolume ( );
	bool CheckIndirectFire ( struct FVector Loc, float fadj );
	float NumEnemyInRange ( float Range );
	float NumEnemySighted ( );
	bool AtValidPetSpawnPoint ( );
	bool HasValidNearbyPetSpawnPoint ( );
	int GetNumberActiveSpawnedPets ( );
	int MinionsInHelpRange ( );
	bool OwnerHasLastAttacked ( );
	bool OwnerHasLastAttacker ( );
	class AVolumePathNode* GetClosestVolumePathNode ( class AActor* ATarget, unsigned long bTestValidSpawnPetPoint );
	float DistanceFromNearestEmptyActionPoint ( int eType );
	class ATgActionPoint* GetNearestEmptyActionPoint ( int eType );
	class AActor* GetClosestObjectiveActor ( unsigned long bEnemy );
	class ATgAlarmPoint* GetNearestAlarm ( );
	float GetNearestAlarmDistance ( );
	float DistanceFromNearest ( unsigned long bEnemy, int nPhysicalType, int nProfileType, unsigned long bIgnoreLos );
	float GetMaxMeleeDistance ( );
	float GetMaxRangedDistance ( );
	bool InDeviceRange ( class AActor* aSource, class AActor* ATarget, unsigned char eEquipmentSlot, int nDeviceMode );
	bool HighestThreatInDeviceRange ( unsigned char eEquipmentSlot );
	bool AttackerInDeviceRange ( unsigned char eEquipmentSlot );
	bool TargetInDeviceRange ( unsigned char eEquipmentSlot, int nDeviceMode );
	bool TargetInRange ( float Range );
	float DistanceFromCurrentObjective ( );
	float DistanceFromOwner ( );
	float DistanceFromTarget ( );
	float DistanceFromLastAttacker ( );
	float DistanceFromSound ( );
	float DistanceFromTrigger ( );
	float DistanceFromHelpRequest ( );
	float DistanceFrom ( class AActor* Target );
	void AddThreat ( class ATgPawn* attacker, float fAmount );
	void UpdateTargetReachable ( );
	void InvalidateTargetReachable ( );
	void TriggerBots ( class UTgSeqAct_TriggerBots* Action );
	void UpdateTargetLocation ( unsigned long bInLOS );
	void SetTargetActor ( class AActor* Target );
	class ATgMissionObjective* GetCurrentObjective ( );
	class AActor* GetCurrentObjectiveActor ( );
	class ATgPawn* GetHighestThreat ( );
	class ATgDeployable* GetTargetDeployable ( );
	class ATgPawn* GetTargetPawn ( );
	class AActor* GetTargetActor ( );
	void CalculateHealth ( );
	void EndClimbLadder ( );
	bool IsInvisible ( class ATgPawn* Other );
	class ANavigationPoint* GetRandomNav ( float fMaxDistance, class AActor* Target );
	bool IsValidTargetEx ( class APawn* CheckTarget, unsigned long bEnemy );
	bool IsEnemy ( class AActor* pOther );
	bool InPatrol ( );
	bool HasCondition ( class ATgPawn* pPawn, int nCondition );
	void SetTaskForceNumber ( int nTaskForce );
	void SetBotTeam ( int nTeamIndex );
	class ANavigationPoint* FindClosestNav ( class AActor* Goal );
	bool LineCheckRecurse ( struct FVector vLocation, class AActor* pTarget, struct FVector vTarget, class AActor* pSource, int nDepth );
	bool LineCheckEx ( struct FVector vLocation, class AActor* pTarget, struct FVector vTarget );
	bool LineCheck ( struct FVector vLocation, class AActor* pTarget );
	bool LineCheckMovement ( class AActor* pTarget );
	bool ChooseNextAction ( );
	void SpawnNextPet ( );
	void SpawnPets ( );
	void RadioAlarm ( );
	bool CheckInterrupt ( );
	void Debugger ( );
};

UClass* ATgAIController::pClassPointer = NULL;

// Class TgGame.TgPawn
// 0x1260 (0x162C - 0x03CC)
class ATgPawn : public APawn
{
public:
	unsigned long                                      m_bComponentDebug : 1;                            		// 0x03CC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bAmMoving : 1;                                  		// 0x03CC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bClearTurnInPlace : 1;                          		// 0x03CC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bNeverClearTurnInPlace : 1;                     		// 0x03CC (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bAffectedByVortices : 1;                        		// 0x03CC (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      s_LoadMeshServerSide : 1;                         		// 0x03CC (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      c_bHideMeshWhenCameraIsInsideMyCollision : 1;     		// 0x03CC (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      c_bMeshHiddenDueToFirstPersonCamera : 1;          		// 0x03CC (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      c_bMeshHiddenDueToEditorCommand : 1;              		// 0x03CC (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      c_bDeviceHiddenDueToZoomVisual : 1;               		// 0x03CC (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      c_bDeviceHiddenDueToAnimNotify : 1;               		// 0x03CC (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bDeviceHiddenDueToSkydive : 1;                  		// 0x03CC (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      c_bDeviceHiddenDueToFullBodyAnim : 1;             		// 0x03CC (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      c_bMeshHiddenDueToDeath : 1;                      		// 0x03CC (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      m_bSimpleDeathPhysAnim : 1;                       		// 0x03CC (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      r_bInGlobalOffhandCooldown : 1;                   		// 0x03CC (0x0004) [0x0000000000000020] [0x00008000] ( CPF_Net )
	unsigned long                                      bInGlobalOffhandCooldownClient : 1;               		// 0x03CC (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      s_bForceDeviceRep : 1;                            		// 0x03CC (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      r_bDisableAllDevices : 1;                         		// 0x03CC (0x0004) [0x0000000000000020] [0x00040000] ( CPF_Net )
	unsigned long                                      r_bEnableEquip : 1;                               		// 0x03CC (0x0004) [0x0000000000000020] [0x00080000] ( CPF_Net )
	unsigned long                                      r_bEnableSkills : 1;                              		// 0x03CC (0x0004) [0x0000000000000020] [0x00100000] ( CPF_Net )
	unsigned long                                      r_bEnableCrafting : 1;                            		// 0x03CC (0x0004) [0x0000000000000020] [0x00200000] ( CPF_Net )
	unsigned long                                      c_bVendorDevOpened : 1;                           		// 0x03CC (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      c_bCraftDevOpened : 1;                            		// 0x03CC (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      bShouldCrouchMelee : 1;                           		// 0x03CC (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      bShouldJumpMelee : 1;                             		// 0x03CC (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      bShouldSprintMelee : 1;                           		// 0x03CC (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      bShouldBlockBreakerMelee : 1;                     		// 0x03CC (0x0004) [0x0000000000000000] [0x08000000] 
	unsigned long                                      bShouldCrouchBlock : 1;                           		// 0x03CC (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      bShouldJumpBlock : 1;                             		// 0x03CC (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      bShouldSprintBlock : 1;                           		// 0x03CC (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      c_bTestMeleeTrails : 1;                           		// 0x03CC (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      bCanLeavePathNetwork : 1;                         		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bCanBeBackStabbed : 1;                          		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bInSoundInsulationVolume : 1;                   		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bBlockCoolingDown : 1;                          		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bBlockSubmittedToServer : 1;                    		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      s_bPendingBlock : 1;                              		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      r_bIsStealthed : 1;                               		// 0x03D0 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      m_bScannerOn : 1;                                 		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      c_bLocationUpdatedLastTick : 1;                   		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bNeedsToBlendOutFadeEffect : 1;                 		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      c_bHiddenDueToStealth : 1;                        		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bHideMeshAfterDeath : 1;                        		// 0x03D0 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      m_bBrakeAbruptly : 1;                             		// 0x03D0 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      r_bIsBot : 1;                                     		// 0x03D0 (0x0004) [0x0000000000000020] [0x00002000] ( CPF_Net )
	unsigned long                                      s_bInvisibleToPets : 1;                           		// 0x03D0 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      s_bCanSeePets : 1;                                		// 0x03D0 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      r_bIsAnimInStrafeMode : 1;                        		// 0x03D0 (0x0004) [0x0000000000000020] [0x00010000] ( CPF_Net )
	unsigned long                                      r_bIsHacked : 1;                                  		// 0x03D0 (0x0004) [0x0000000000000020] [0x00020000] ( CPF_Net )
	unsigned long                                      r_bIsHacking : 1;                                 		// 0x03D0 (0x0004) [0x0000000000000020] [0x00040000] ( CPF_Net )
	unsigned long                                      r_bIsCrewing : 1;                                 		// 0x03D0 (0x0004) [0x0000000000000020] [0x00080000] ( CPF_Net )
	unsigned long                                      r_bIsCrafting : 1;                                		// 0x03D0 (0x0004) [0x0000000000000020] [0x00100000] ( CPF_Net )
	unsigned long                                      r_bIsDecoy : 1;                                   		// 0x03D0 (0x0004) [0x0000000000000020] [0x00200000] ( CPF_Net )
	unsigned long                                      m_bNotifyIfTargeted : 1;                          		// 0x03D0 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      c_bTargetingLocalPawn : 1;                        		// 0x03D0 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_ReachedTargetSoKillRootMotion : 1;              		// 0x03D0 (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      s_bCanApplyEffects : 1;                           		// 0x03D0 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      m_bInitialized : 1;                               		// 0x03D0 (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      c_bInSensorDefaultMode : 1;                       		// 0x03D0 (0x0004) [0x0000000000000000] [0x08000000] 
	unsigned long                                      c_bSensorLastSeeListUpdated : 1;                  		// 0x03D0 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      r_bAimingMode : 1;                                		// 0x03D0 (0x0004) [0x0000000000000020] [0x20000000] ( CPF_Net )
	unsigned long                                      c_bShowCloseUp : 1;                               		// 0x03D0 (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      r_bUsingBinoculars : 1;                           		// 0x03D0 (0x0004) [0x0000000000000020] [0x80000000] ( CPF_Net )
	unsigned long                                      r_bIsInSnipeScope : 1;                            		// 0x03D4 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      c_bShowingBinoculars : 1;                         		// 0x03D4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      r_bIsGrappleDismounting : 1;                      		// 0x03D4 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      c_bIsAutoGrappling : 1;                           		// 0x03D4 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bUseInterrupted : 1;                            		// 0x03D4 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bDisableAction : 1;                             		// 0x03D4 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      r_bTagEnemy : 1;                                  		// 0x03D4 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      c_bIgnoreInterruption : 1;                        		// 0x03D4 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bCheatUseNoEnergy : 1;                          		// 0x03D4 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bCheatNoRecharge : 1;                           		// 0x03D4 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bIsInvisibleToAI : 1;                           		// 0x03D4 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      m_bInBoneSpringMode : 1;                          		// 0x03D4 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      c_bPhysicallyCollides : 1;                        		// 0x03D4 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      r_bInCombatFlag : 1;                              		// 0x03D4 (0x0004) [0x0000000000000020] [0x00002000] ( CPF_Net )
	unsigned long                                      c_bClampPlayerInput : 1;                          		// 0x03D4 (0x0004) [0x0000000000000001] [0x00004000] ( CPF_Edit )
	unsigned long                                      r_bIsAFK : 1;                                     		// 0x03D4 (0x0004) [0x0000000000000020] [0x00008000] ( CPF_Net )
	unsigned long                                      r_bCallingForHelp : 1;                            		// 0x03D4 (0x0004) [0x0000000000000020] [0x00010000] ( CPF_Net )
	unsigned long                                      m_bAnimInfluencedByDamageType : 1;                		// 0x03D4 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_bPelvisHasRestedOnDeath : 1;                    		// 0x03D4 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      c_bHandIKEnabledFromAnimSet : 1;                  		// 0x03D4 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      c_bCanDoTurnInPlaceAnim : 1;                      		// 0x03D4 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      c_bIsPlayingTurnAnim : 1;                         		// 0x03D4 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      m_bUseAimOffsetsFromAnimation : 1;                		// 0x03D4 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_bIsPlayingTurnTransition : 1;                   		// 0x03D4 (0x0004) [0x0000000000000002] [0x00800000] ( CPF_Const )
	unsigned long                                      m_bIgnoreTransitionAnims : 1;                     		// 0x03D4 (0x0004) [0x0000000000000002] [0x01000000] ( CPF_Const )
	unsigned long                                      m_bCanChooseNewTransition : 1;                    		// 0x03D4 (0x0004) [0x0000000000000002] [0x02000000] ( CPF_Const )
	unsigned long                                      c_bShouldPlayLandingRun : 1;                      		// 0x03D4 (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      r_bPostureIgnoreTransition : 1;                   		// 0x03D4 (0x0004) [0x0000000000000020] [0x08000000] ( CPF_Net )
	unsigned long                                      m_bCanBePoked : 1;                                		// 0x03D4 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      m_bBlendingBack : 1;                              		// 0x03D4 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      r_bShouldKnockDownAnimFaceDown : 1;               		// 0x03D4 (0x0004) [0x0000000000000020] [0x40000000] ( CPF_Net )
	unsigned long                                      m_bCanBeKockedBack : 1;                           		// 0x03D4 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      m_bCanBePushedBack : 1;                           		// 0x03D8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bCausesPushblock : 1;                           		// 0x03D8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bPushblockAffectsFriendlies : 1;                		// 0x03D8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bPushblockAffectsEnemies : 1;                   		// 0x03D8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bReceivesPushblock : 1;                         		// 0x03D8 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bDisableShiftingReticule : 1;                   		// 0x03D8 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      r_bIsHangingDismounting : 1;                      		// 0x03D8 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      r_bJumpedFromHanging : 1;                         		// 0x03D8 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      m_bCanHang : 1;                                   		// 0x03D8 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bHangingCapable : 1;                            		// 0x03D8 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      r_bIsHanging : 1;                                 		// 0x03D8 (0x0004) [0x0000000000000020] [0x00000400] ( CPF_Net )
	unsigned long                                      m_bUseSmoothNetReceiveRotation : 1;               		// 0x03D8 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      r_bIsHenchman : 1;                                		// 0x03D8 (0x0004) [0x0000000000000020] [0x00001000] ( CPF_Net )
	unsigned long                                      m_bOverrideTargetComponentHeight : 1;             		// 0x03D8 (0x0004) [0x0000000000000001] [0x00002000] ( CPF_Edit )
	unsigned long                                      c_bStatRendered : 1;                              		// 0x03D8 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      c_bUpdateSkelMeshWhenNotRendered : 1;             		// 0x03D8 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      r_bResistTagging : 1;                             		// 0x03D8 (0x0004) [0x0000000000000020] [0x00010000] ( CPF_Net )
	unsigned long                                      c_bEnemyMatLoaded : 1;                            		// 0x03D8 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_bIsWallJumping : 1;                             		// 0x03D8 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      r_bIsSkydiving : 1;                               		// 0x03D8 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      r_bHasSkydiveLaunched : 1;                        		// 0x03D8 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      r_bIsRappelling : 1;                              		// 0x03D8 (0x0004) [0x0000000000000020] [0x00200000] ( CPF_Net )
	unsigned long                                      m_bFirstPersonIsSetUp : 1;                        		// 0x03D8 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      m_bEnableLandingDebuff : 1;                       		// 0x03D8 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      m_bIsLandingDebuffed : 1;                         		// 0x03D8 (0x0004) [0x0000000000000000] [0x01000000] 
	unsigned long                                      m_bIsJumping : 1;                                 		// 0x03D8 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      s_bApplyHealthCap : 1;                            		// 0x03D8 (0x0004) [0x0000000000000000] [0x04000000] 
	unsigned long                                      m_bForceZeroVelocityWhileTurning : 1;             		// 0x03D8 (0x0004) [0x0000000000000000] [0x08000000] 
	unsigned long                                      r_bAllowAddMoralePoints : 1;                      		// 0x03D8 (0x0004) [0x0000000000000020] [0x10000000] ( CPF_Net )
	unsigned long                                      s_bIsCrewable : 1;                                		// 0x03D8 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      m_bAffectedBySoftZ : 1;                           		// 0x03D8 (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      m_bCachedAutoLock : 1;                            		// 0x03D8 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      m_bDestroyOnOwnerDeathFlag : 1;                   		// 0x03DC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bNeedPlaySpawnFx : 1;                           		// 0x03DC (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      c_bSpawnFxPlayed : 1;                             		// 0x03DC (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      r_bInitialIsEnemy : 1;                            		// 0x03DC (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      c_bScannerReset : 1;                              		// 0x03DC (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bNeedsAssetLoad : 1;                            		// 0x03DC (0x0004) [0x0000000000000000] [0x00000020] 
	int                                                r_nBodyMeshAsmId;                                 		// 0x03E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FPointer                                    m_BodyMeshAssembly;                               		// 0x03E4 (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                r_nPawnId;                                        		// 0x03E8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fLastUpdateTime;                                		// 0x03EC (0x0004) [0x0000000000000000]              
	class ATgEffectManager*                            r_EffectManager;                                  		// 0x03F0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTgProperty* >                       s_Properties;                                     		// 0x03F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x0400 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgPawn.s_PropertyIndx
	int                                                r_nHealthMaximum;                                 		// 0x043C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_fWeightBonus;                                   		// 0x0440 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FTgCameraValues                             c_MeleeCameraValues;                              		// 0x0444 (0x005C) [0x0000000000000001]              ( CPF_Edit )
	struct FTgCameraValues                             c_RangeCameraValues;                              		// 0x04A0 (0x005C) [0x0000000000000001]              ( CPF_Edit )
	struct FTgCameraValues                             c_RangeTightCameraValues;                         		// 0x04FC (0x005C) [0x0000000000000001]              ( CPF_Edit )
	struct FTgCameraValues                             c_FirstPersonCameraValues;                        		// 0x0558 (0x005C) [0x0000000000000001]              ( CPF_Edit )
	struct FTgCameraValues                             c_DeathCameraValues;                              		// 0x05B4 (0x005C) [0x0000000000000001]              ( CPF_Edit )
	struct FTgCameraValues                             c_GrenadeCameraValues;                            		// 0x0610 (0x005C) [0x0000000000000001]              ( CPF_Edit )
	struct FTgCameraValues                             c_HackingCameraValues;                            		// 0x066C (0x005C) [0x0000000000000001]              ( CPF_Edit )
	class UTgSkelCon_Stabilizer*                       m_StabilizerSkelControl;                          		// 0x06C8 (0x0004) [0x0000000000000000]              
	int                                                r_nProfileId;                                     		// 0x06CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nAllianceId;                                    		// 0x06D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_nSpawnTime;                                     		// 0x06D4 (0x0004) [0x0000000000000000]              
	int                                                r_nPhysicalType;                                  		// 0x06D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nProfileTypeValueId;                            		// 0x06DC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nBotRankValueId;                                		// 0x06E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPreyProfileType;                               		// 0x06E4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_LastSimulatedPhysics;                           		// 0x06E8 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eDeathReason;                                   		// 0x06E9 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eDesiredInHand;                                 		// 0x06EA (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_eEquippedInHand;                                		// 0x06EB (0x0001) [0x0000000000000000]              
	unsigned char                                      m_byFlashNextUpValue;                             		// 0x06EC (0x0001) [0x0000000000000000]              
	unsigned char                                      r_bMadeSound;                                     		// 0x06ED (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      c_eZoomState;                                     		// 0x06EE (0x0001) [0x0000000000000000]              
	unsigned char                                      r_bAimType;                                       		// 0x06EF (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_ePosture;                                       		// 0x06F0 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      m_CurrentState;                                   		// 0x06F1 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_byPushbackCompletedCounter;                     		// 0x06F2 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_UIClockState;                                   		// 0x06F3 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_UITextBox1Packet;                               		// 0x06F4 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_UITextBox2Packet;                               		// 0x06F5 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      s_UITextBox1Incr;                                 		// 0x06F6 (0x0001) [0x0000000000000000]              
	unsigned char                                      s_UITextBox2Incr;                                 		// 0x06F7 (0x0001) [0x0000000000000000]              
	unsigned char                                      r_eCurrentStunType;                               		// 0x06F8 (0x0001) [0x0000000000000020]              ( CPF_Net )
	class ATgCollisionProxy_Vortex*                    m_CurrentVortex;                                  		// 0x06FC (0x0004) [0x0000000000000000]              
	struct FEquipDeviceInfo                            r_EquipDeviceInfo[ 0x19 ];                        		// 0x0700 (0x012C) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_EquippedDevices[ 0x19 ];                        		// 0x082C (0x0064) [0x0000000000000000]              
	class UTgDeviceForm*                               c_EquipForm[ 0x19 ];                              		// 0x0890 (0x0064) [0x0000000000000000]              
	int                                                r_eEquippedInHandMode;                            		// 0x08F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       c_nmInHandSocket;                                 		// 0x08F8 (0x0008) [0x0000000000000000]              
	class ATgDevice*                                   c_PIEInHandDevice;                                		// 0x0900 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_RestDevice;                                     		// 0x0904 (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_CurrentInHandDevice;                            		// 0x0908 (0x0004) [0x0000000000000000]              
	class UTgDeviceFire*                               m_CurrentInHandDevFire;                           		// 0x090C (0x0004) [0x0000000000000000]              
	class ATgDevice*                                   m_CachedFiringOffhand;                            		// 0x0910 (0x0004) [0x0000000000000000]              
	float                                              m_fLastFiringOffhandTimeStamp;                    		// 0x0914 (0x0004) [0x0000000000000000]              
	int                                                c_nVendorLootTableId;                             		// 0x0918 (0x0004) [0x0000000000000000]              
	int                                                c_nMissionListTableId;                            		// 0x091C (0x0004) [0x0000000000000000]              
	struct FString                                     c_nMissionListName;                               		// 0x0920 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgSkeletalMeshActorNPCVendor*               c_CurrentNPCVendor;                               		// 0x092C (0x0004) [0x0000000000000000]              
	int                                                r_nFlashQueIndex;                                 		// 0x0930 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nFlashPriorEvent[ 0x20 ];                       		// 0x0934 (0x0080) [0x0000000000000000]              
	int                                                r_nFlashEvent[ 0x20 ];                            		// 0x09B4 (0x0080) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vFlashLocation[ 0x20 ];                         		// 0x0A34 (0x0180) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_vFlashRayDir[ 0x20 ];                           		// 0x0BB4 (0x0180) [0x0000000000000020]              ( CPF_Net )
	float                                              r_vFlashRefireTime[ 0x20 ];                       		// 0x0D34 (0x0080) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nFlashFireInfo[ 0x20 ];                         		// 0x0DB4 (0x0080) [0x0000000000000020]              ( CPF_Net )
	int                                                r_vFlashSituationalAttack[ 0x20 ];                		// 0x0E34 (0x0080) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fBlockCoolDownTime;                             		// 0x0EB4 (0x0004) [0x0000000000000000]              
	float                                              s_fTauntAmount;                                   		// 0x0EB8 (0x0004) [0x0000000000000000]              
	float                                              m_lastSoundTime;                                  		// 0x0EBC (0x0004) [0x0000000000000000]              
	int                                                r_nSoundGroupId;                                  		// 0x0EC0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSoundGroup*                               c_aSoundGroup;                                    		// 0x0EC4 (0x0004) [0x0000000000000000]              
	float                                              m_fLastPainSound;                                 		// 0x0EC8 (0x0004) [0x0000000000000000]              
	int                                                r_nBotSoundCueId;                                 		// 0x0ECC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UAudioComponent*                             c_BotAudioComponent;                              		// 0x0ED0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ULightEnvironmentComponent*                  LightEnvironment;                                 		// 0x0ED4 (0x0004) [0x000000000408000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	TArray< struct FTgOffhandAnimationOffset >         OffhandAnimationOffsets;                          		// 0x0ED8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nStealthTypeCode;                               		// 0x0EE4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fStealthTransitionTime;                         		// 0x0EE8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nApplyStealth;                                  		// 0x0EEC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nHealthDecreasedThisTick;                       		// 0x0EF0 (0x0004) [0x0000000000000000]              
	float                                              r_fMakeVisibleIncreased;                          		// 0x0EF4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fMakeVisibleFadeRate;                           		// 0x0EF8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fMakeVisibleCurrent;                            		// 0x0EFC (0x0004) [0x0000000000000000]              
	int                                                r_nStealthDisabled;                               		// 0x0F00 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       c_nmFadeParam;                                    		// 0x0F04 (0x0008) [0x0000000000000000]              
	struct FName                                       m_nmMakeVisibleParam;                             		// 0x0F0C (0x0008) [0x0000000000000000]              
	float                                              s_fLastUnstealthedTime;                           		// 0x0F14 (0x0004) [0x0000000000000000]              
	int                                                c_nStealthedEnemyMICResId;                        		// 0x0F18 (0x0004) [0x0000000000000000]              
	int                                                c_nStealthedFriendMICResId;                       		// 0x0F1C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_StealthedEnemyMIC;                              		// 0x0F20 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_StealthedFriendMIC;                             		// 0x0F24 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          c_SavedMICForStealth;                             		// 0x0F28 (0x0004) [0x0000000000000000]              
	float                                              m_fFadeTransitionTimeRemaining;                   		// 0x0F2C (0x0004) [0x0000000000000000]              
	float                                              m_fFadeTransitionOutTime;                         		// 0x0F30 (0x0004) [0x0000000000000000]              
	float                                              c_fFadeEffectLength;                              		// 0x0F34 (0x0004) [0x0000000000000000]              
	float                                              c_fTimeLastSeenByLocalPlayer;                     		// 0x0F38 (0x0004) [0x0000000000000000]              
	float                                              c_fTimeLastUnseenByLocalPlayer;                   		// 0x0F3C (0x0004) [0x0000000000000000]              
	float                                              c_fTimeLastTargetByLocalPlayer;                   		// 0x0F40 (0x0004) [0x0000000000000000]              
	float                                              c_fTimeLastUntargetByLocalPlayer;                 		// 0x0F44 (0x0004) [0x0000000000000000]              
	TArray< struct FAppliedMICFx >                     m_AppliedMICFx;                                   		// 0x0F48 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMeshComponent*                              c_DestroyedMesh;                                  		// 0x0F54 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSpecialFx*                                c_TeleporterEnterFX;                              		// 0x0F58 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TeleporterExitFX;                               		// 0x0F5C (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_PawnFadeOutFx;                                  		// 0x0F60 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_VipFx;                                          		// 0x0F64 (0x0004) [0x0000000000000000]              
	int                                                c_VipFxId;                                        		// 0x0F68 (0x0004) [0x0000000000000000]              
	float                                              m_fLifeAfterDeathSecs;                            		// 0x0F6C (0x0004) [0x0000000000000000]              
	float                                              m_fHideMeshAfterDeathSecs;                        		// 0x0F70 (0x0004) [0x0000000000000000]              
	float                                              c_fZoomedStartFOV;                                		// 0x0F74 (0x0004) [0x0000000000000000]              
	float                                              c_fZoomedEndFOV;                                  		// 0x0F78 (0x0004) [0x0000000000000000]              
	float                                              c_fZoomedFOV;                                     		// 0x0F7C (0x0004) [0x0000000000000000]              
	float                                              c_fZoomedRate;                                    		// 0x0F80 (0x0004) [0x0000000000000000]              
	float                                              r_FlightAcceleration;                             		// 0x0F84 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fFrictionMultiplier;                            		// 0x0F88 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_aDebugTarget;                                   		// 0x0F8C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_aDebugDestination;                              		// 0x0F90 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_aDebugNextNav;                                  		// 0x0F94 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDebugHearingRange;                             		// 0x0F98 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDebugSightRange;                               		// 0x0F9C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDebugAggroRange;                               		// 0x0FA0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDebugFOV;                                      		// 0x0FA4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FString                                     r_sDebugAction;                                   		// 0x0FA8 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FString                                     r_sDebugName;                                     		// 0x0FB4 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FString                                     r_sFactory;                                       		// 0x0FC0 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	class UDrawConeComponent*                          c_DrawConeComponent;                              		// 0x0FCC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                c_MWLog;                                          		// 0x0FD0 (0x0004) [0x0000000000000000]              
	float                                              c_MyGunFOV;                                       		// 0x0FD4 (0x0004) [0x0000000000000000]              
	int                                                r_nStealthSensorRange;                            		// 0x0FD8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nStealthAggroRange;                             		// 0x0FDC (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     s_vOneWayMovement;                                		// 0x0FE0 (0x000C) [0x0000000000000000]              
	struct FVector                                     r_vDown;                                          		// 0x0FEC (0x000C) [0x0000000000000020]              ( CPF_Net )
	TArray< struct FDamageDisplay >                    c_DamageDisplayList;                              		// 0x0FF8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_fBackpedalPct;                                  		// 0x1004 (0x0004) [0x0000000000000000]              
	float                                              m_fBlockingPct;                                   		// 0x1008 (0x0004) [0x0000000000000000]              
	TArray< struct FBuffInfo >                         m_EffectBuffInfo;                                 		// 0x100C (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	class AController*                                 s_RobotController;                                		// 0x1018 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_ControlPawn;                                    		// 0x101C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     s_HackedBot;                                      		// 0x1020 (0x0004) [0x0000000000000000]              
	float                                              r_fMaxControlRange;                               		// 0x1024 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nNumberTimesCrewed;                             		// 0x1028 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgHexItemInstance*                          s_HexItem;                                        		// 0x102C (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_CraftingSFX;                                    		// 0x1030 (0x0004) [0x0000000000000000]              
	float                                              r_fDeployRate;                                    		// 0x1034 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FTgPlayAnimation                            r_PlayAnimation;                                  		// 0x1038 (0x000C) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     r_Target;                                         		// 0x1044 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class AActor*                                      r_TargetActor;                                    		// 0x1048 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nTargeted;                                      		// 0x104C (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_Pet;                                            		// 0x1050 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn_Turret*                              s_Turret;                                         		// 0x1054 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_Decoy;                                          		// 0x1058 (0x0004) [0x0000000000000000]              
	class ATgDeploy_Beacon*                            m_Beacon;                                         		// 0x105C (0x0004) [0x0000000000000000]              
	class AActor*                                      s_LastAttacker;                                   		// 0x1060 (0x0004) [0x0000000000000000]              
	class AActor*                                      s_LastAttacked;                                   		// 0x1064 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_CurrentMeleeTarget;                             		// 0x1068 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     r_Owner;                                          		// 0x106C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nSpawnerDeviceInstId;                           		// 0x1070 (0x0004) [0x0000000000000000]              
	int                                                s_nSpawnerDeviceModeId;                           		// 0x1074 (0x0004) [0x0000000000000000]              
	int                                                r_nReplicateDying;                                		// 0x1078 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nResetCharacter;                                		// 0x107C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nLootTableId;                                   		// 0x1080 (0x0004) [0x0000000000000000]              
	int                                                r_nReplicateHit;                                  		// 0x1084 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fStandingHeight;                                		// 0x1088 (0x0004) [0x0000000000000000]              
	float                                              m_fStandingRadius;                                		// 0x108C (0x0004) [0x0000000000000000]              
	float                                              m_fTargetCylinderHeight;                          		// 0x1090 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetCylinderRadius;                          		// 0x1094 (0x0004) [0x0000000000000000]              
	class UTgWeakSpotCylinderComponent*                m_WeakSpot;                                       		// 0x1098 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              r_fCurrentPowerPool;                              		// 0x109C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fMaxPowerPool;                                  		// 0x10A0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fPowerPoolRechargeRate;                         		// 0x10A4 (0x0004) [0x0000000000000000]              
	int                                                m_fConstJumpPowerPoolCost;                        		// 0x10A8 (0x0004) [0x0000000000000000]              
	int                                                m_fConstDodgePowerPoolCost;                       		// 0x10AC (0x0004) [0x0000000000000000]              
	float                                              m_CurrentAccuracy;                                		// 0x10B0 (0x0004) [0x0000000000000000]              
	struct FSensor_See_Actor_List                      c_ScannerLastSeeActorsList[ 0x2 ];                		// 0x10B4 (0x0018) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScanner_Settings                           r_ScannerSettings[ 0x2 ];                         		// 0x10CC (0x0098) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nVisibleToLocalPlayer[ 0x2 ];                   		// 0x1164 (0x0008) [0x0000000000000000]              
	float                                              c_fAimingModeTime;                                		// 0x116C (0x0004) [0x0000000000000000]              
	class ATgProj_Grapple*                             m_Grapple;                                        		// 0x1170 (0x0004) [0x0000000000000000]              
	float                                              m_GrappleDismountZ;                               		// 0x1174 (0x0004) [0x0000000000000000]              
	float                                              m_GrappleDismountIntensity;                       		// 0x1178 (0x0004) [0x0000000000000000]              
	float                                              r_fGravityZModifier;                              		// 0x117C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fFallingDamageModifier;                         		// 0x1180 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_CurrentUseActor;                                		// 0x1184 (0x0004) [0x0000000000000000]              
	class ATgOmegaVolume*                              r_CurrentOmegaVolume;                             		// 0x1188 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgOmegaVolume*                              r_CurrentSubzoneVol;                              		// 0x118C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgOmegaVolume*                              r_CurrentSubzoneBilboardVol;                      		// 0x1190 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDevice*                                   m_ActiveDevice;                                   		// 0x1194 (0x0004) [0x0000000000000000]              
	float                                              m_fBaseTranslationOffset;                         		// 0x1198 (0x0004) [0x0000000000000000]              
	float                                              m_fCrouchTranslationOffset;                       		// 0x119C (0x0004) [0x0000000000000000]              
	int                                                c_DebugParticleMask;                              		// 0x11A0 (0x0004) [0x0000000000000000]              
	int                                                m_fAutoLockAngle;                                 		// 0x11A4 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_LockIconMatInstance;                            		// 0x11A8 (0x0004) [0x0000000000000000]              
	float                                              c_fClampTurn;                                     		// 0x11AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fClampLookup;                                   		// 0x11B0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fPhaseChangeTime;                               		// 0x11B4 (0x0004) [0x0000000000000000]              
	float                                              m_fPhaseChangedTimeStamp;                         		// 0x11B8 (0x0004) [0x0000000000000000]              
	float                                              m_PhaseChangeRemainingTime;                       		// 0x11BC (0x0004) [0x0000000000000000]              
	int                                                r_nPhase;                                         		// 0x11C0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_PreviousPhase;                                  		// 0x11C4 (0x0004) [0x0000000000000000]              
	int                                                r_nGenericAIEventIndex;                           		// 0x11C8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgAnimBlendByRangeUseType*                  c_RangeAnimNodeBlendList;                         		// 0x11CC (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimBlendByDeviceType* >          c_DeviceTypeAnimNodeBlendLists;                   		// 0x11D0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgAnimBlendByMelee*                         c_BlendByMelee;                                   		// 0x11DC (0x0004) [0x0000000000000000]              
	class UAnimNodeBlend*                              m_BlendByLowerBodyMeleeAttack;                    		// 0x11E0 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendByOffhand*                   m_OffhandBlendNode;                               		// 0x11E4 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_MeleeRetrieveNode;                              		// 0x11E8 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_MeleePutAwayNode;                               		// 0x11EC (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_FireFromRightAnimSeq;                           		// 0x11F0 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_FireFromLeftAnimSeq;                            		// 0x11F4 (0x0004) [0x0000000000000000]              
	int                                                r_eEmoteUpdate;                                   		// 0x11F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_eEmoteLength;                                   		// 0x11FC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_eEmoteRepnotify;                                		// 0x1200 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fLastThoughtTime;                               		// 0x1204 (0x0004) [0x0000000000000000]              
	float                                              m_fRestedOnDeathDelay;                            		// 0x1208 (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingRestedOnDeathDelayTime;               		// 0x120C (0x0004) [0x0000000000000000]              
	class UAnimNodeBlend*                              m_UpperBodyAnimBlendNode;                         		// 0x1210 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_UpperBodyAnimNodeSequence;                      		// 0x1214 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeSlot*                             m_FullBodyAnimNode;                               		// 0x1218 (0x0004) [0x0000000000000000]              
	class UAnimNodeBlend*                              m_WalkBlendNode;                                  		// 0x121C (0x0004) [0x0000000000000000]              
	struct FName                                       m_WalkBlendNodeName;                              		// 0x1220 (0x0008) [0x0000000000000000]              
	class UAnimNodePlayCustomAnim*                     m_ShotFromAirCustomNode;                          		// 0x1228 (0x0004) [0x0000000000000000]              
	struct FVector2D                                   m_NewAimOffsetPct;                                		// 0x122C (0x0008) [0x0000000000000000]              
	struct FVector                                     m_InitialBlockingDirection;                       		// 0x1234 (0x000C) [0x0000000000000000]              
	int                                                m_nLastYaw;                                       		// 0x1240 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                m_nLastPitch;                                     		// 0x1244 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                m_nYawOffset;                                     		// 0x1248 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                m_nPitchOffset;                                   		// 0x124C (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	int                                                m_nCurrentTransitionIndex;                        		// 0x1250 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fChooseNewTransitionPercent;                    		// 0x1254 (0x0004) [0x0000000000000002]              ( CPF_Const )
	int                                                r_nYawOffset;                                     		// 0x1258 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPitchOffset;                                   		// 0x125C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_bRemainingTransitionTime;                       		// 0x1260 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fMeshScale;                                     		// 0x1264 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTgSocketOffsetInfo*                         m_TgSocketOffsetInfo;                             		// 0x1268 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendByLanding*                   m_LandingBlendNode;                               		// 0x126C (0x0004) [0x0000000000000000]              
	float                                              m_fHardLandThreshold;                             		// 0x1270 (0x0004) [0x0000000000000000]              
	float                                              m_fHardLandPauseTime;                             		// 0x1274 (0x0004) [0x0000000000000000]              
	float                                              c_fLastLandImpactVelocity;                        		// 0x1278 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_SkelControl_LockRootMovement;                   		// 0x127C (0x0004) [0x0000000000000000]              
	float                                              r_fPostureRateScale;                              		// 0x1280 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< struct Fm_PostureAIPauseTime >             m_bPostureAIPauseTimes;                           		// 0x1284 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             LowerBoneNames;                                   		// 0x1290 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             AimModeBoneNames;                                 		// 0x129C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             LinearBoneSpringNames;                            		// 0x12A8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             AngularBoneSpringNames;                           		// 0x12B4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FName                                       PelvisBoneName;                                   		// 0x12C0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       HeadBoneName;                                     		// 0x12C8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       PokeBoneName;                                     		// 0x12D0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_PokePauseTime;                                  		// 0x12D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_PokeBlendTime;                                  		// 0x12DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_BlendBackStartTime;                             		// 0x12E0 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendByKnockdown*                 m_KnockdownBlendNode;                             		// 0x12E4 (0x0004) [0x0000000000000000]              
	int                                                r_iKnockDownFlash;                                		// 0x12E8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fKnockDownTimeRemaining;                        		// 0x12EC (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fKnockbackMultiplier;                           		// 0x12F0 (0x0004) [0x0000000000000000]              
	float                                              r_DistanceToPushback;                             		// 0x12F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              f_RemainingDistanceToPushback;                    		// 0x12F8 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_PushbackDirection;                              		// 0x12FC (0x000C) [0x0000000000000020]              ( CPF_Net )
	float                                              m_PushbackSpeed;                                  		// 0x1308 (0x0004) [0x0000000000000000]              
	float                                              m_fPushbackMultiplier;                            		// 0x130C (0x0004) [0x0000000000000000]              
	class ATgBotFactorySpawnable*                      s_PetBotFactory;                                  		// 0x1310 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< class ATgNavigationPointSpawnable* >       s_PetLocationList;                                		// 0x1314 (0x000C) [0x0000000000402000]              ( CPF_Transient | CPF_NeedCtorLink )
	float                                              m_fTimeBetweenPetSpawns;                          		// 0x1320 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_DeployPetsSocketNames;                          		// 0x1324 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              m_ValidPetSpawnPointDistance;                     		// 0x1330 (0x0004) [0x0000000000000000]              
	float                                              r_UIClockTime;                                    		// 0x1334 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_UIClockFlagSwitch;                              		// 0x1338 (0x0004) [0x0000000000000000]              
	float                                              r_UITextBox1Time;                                 		// 0x133C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_UITextBox1MessageID;                            		// 0x1340 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_UITextBox2Time;                                 		// 0x1344 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_UITextBox2MessageID;                            		// 0x1348 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fRBPushStrengthMultiplier;                      		// 0x134C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector2D                                   m_fRBPushStrengthRange;                           		// 0x1350 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              s_fEvadeAll;                                      		// 0x1358 (0x0004) [0x0000000000000000]              
	int                                                r_nSilentMode;                                    		// 0x135C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fLastSensorCheckTime;                           		// 0x1360 (0x0004) [0x0000000000000000]              
	int                                                s_nSensorAlertList[ 0x5 ];                        		// 0x1364 (0x0014) [0x0000000000000000]              
	int                                                r_nSensorAlertLevel;                              		// 0x1378 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     m_vHangingGrabVelocity;                           		// 0x137C (0x000C) [0x0000000000000000]              
	class UTgAnimNodeBlendByHanging*                   m_HangingAnimNode;                                		// 0x1388 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_HangingPlacement*                 m_HangingOffsetSkelControl;                       		// 0x138C (0x0004) [0x0000000000000000]              
	struct FRotator                                    r_HangingRotation;                                		// 0x1390 (0x000C) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fHangingPropelPauseTime;                        		// 0x139C (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_PreviousNetReceiveRotation;                     		// 0x13A0 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_TargetNetReceiveRotation;                       		// 0x13AC (0x000C) [0x0000000000000000]              
	float                                              m_RotationInterpRate;                             		// 0x13B8 (0x0004) [0x0000000000000000]              
	int                                                m_nNetRotationCount;                              		// 0x13BC (0x0004) [0x0000000000000000]              
	float                                              m_fLadderDismountVelocity;                        		// 0x13C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fRemainingTimeTillPawnCanGrabALadder;           		// 0x13C4 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeTillPawnCanGrabALadder;                    		// 0x13C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UCylinderComponent*                          m_TargetComponent;                                		// 0x13CC (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              m_TargetCollisionTraceDistance;                   		// 0x13D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fOverriddenTargetComponentHeight;               		// 0x13D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FPointer                                    m_pStatsTracker;                                  		// 0x13D8 (0x0004) [0x0000000000001000]              ( CPF_Native )
	int                                                c_nPlayerTagResId;                                		// 0x13DC (0x0004) [0x0000000000000000]              
	int                                                c_nBotTagResId;                                   		// 0x13E0 (0x0004) [0x0000000000000000]              
	int                                                c_nActivePlayerTagResId;                          		// 0x13E4 (0x0004) [0x0000000000000000]              
	int                                                c_nAssaultIconResId;                              		// 0x13E8 (0x0004) [0x0000000000000000]              
	int                                                c_nMedicIconResId;                                		// 0x13EC (0x0004) [0x0000000000000000]              
	int                                                c_nRoboticsIconResId;                             		// 0x13F0 (0x0004) [0x0000000000000000]              
	int                                                c_nReconIconResId;                                		// 0x13F4 (0x0004) [0x0000000000000000]              
	int                                                c_nCallForHelpIconResId;                          		// 0x13F8 (0x0004) [0x0000000000000000]              
	int                                                c_nHighScoreIconResId;                            		// 0x13FC (0x0004) [0x0000000000000000]              
	int                                                c_nLongLifeIconResId;                             		// 0x1400 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_PlayerTagMIC;                                   		// 0x1404 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_BotTagMIC;                                      		// 0x1408 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_ActivePlayerTagMIC;                             		// 0x140C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_AssaultIconMIC;                                 		// 0x1410 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MedicIconMIC;                                   		// 0x1414 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_RoboticsIconMIC;                                		// 0x1418 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_ReconIconMIC;                                   		// 0x141C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_CallForHelpIconMIC;                             		// 0x1420 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_HighScoreIconMIC;                               		// 0x1424 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_LongLifeIconMIC;                                		// 0x1428 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MaterialHealthBarMIC;                           		// 0x142C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MaterialHealthBarParent;                        		// 0x1430 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MaterialHealthBarTargetParent;                  		// 0x1434 (0x0004) [0x0000000000000000]              
	int                                                s_nDbPostRefCount;                                		// 0x1438 (0x0004) [0x0000000000000000]              
	struct FVector                                     r_SkydiveLandingLocation;                         		// 0x143C (0x000C) [0x0000000000000000]              
	struct FVector                                     r_SkydiveLaunchVelocity;                          		// 0x1448 (0x000C) [0x0000000000000000]              
	float                                              m_SkydiveCurrentTerminalVelocity;                 		// 0x1454 (0x0004) [0x0000000000000000]              
	float                                              m_SkydiveTerminalVelocity;                        		// 0x1458 (0x0004) [0x0000000000000000]              
	float                                              m_SkydiveGroundSpeed;                             		// 0x145C (0x0004) [0x0000000000000000]              
	struct FVector                                     r_SkydiveAirDirection;                            		// 0x1460 (0x000C) [0x0000000000000000]              
	class ATgSkydiveTarget*                            r_SkydiveTarget;                                  		// 0x146C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_SkydiveLaunchForce;                             		// 0x1470 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_SkydiveLaunchDecayRate;                         		// 0x1474 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_SkydiveLaunchUpForce;                           		// 0x1478 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_SkydiveAirspeed;                                		// 0x147C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FRappelInfo                                 m_RappelInfo;                                     		// 0x1480 (0x0014) [0x0000000000000000]              
	float                                              r_fRappelGravityModifier;                         		// 0x1494 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     m_LastDamager;                                    		// 0x1498 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_SecondToLastDamager;                            		// 0x149C (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_LastHealer;                                     		// 0x14A0 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_LastBuffer;                                     		// 0x14A4 (0x0004) [0x0000000000000000]              
	class ATgPawn*                                     m_LastDebuffer;                                   		// 0x14A8 (0x0004) [0x0000000000000000]              
	int                                                m_LastDamagerTimeStamp;                           		// 0x14AC (0x0004) [0x0000000000000000]              
	int                                                m_SecondToLastDamagerTimeStamp;                   		// 0x14B0 (0x0004) [0x0000000000000000]              
	int                                                m_LastHealerTimeStamp;                            		// 0x14B4 (0x0004) [0x0000000000000000]              
	int                                                m_LastBufferTimeStamp;                            		// 0x14B8 (0x0004) [0x0000000000000000]              
	int                                                m_LastDebufferTimeStamp;                          		// 0x14BC (0x0004) [0x0000000000000000]              
	float                                              s_fLastObjectiveTime;                             		// 0x14C0 (0x0004) [0x0000000000000000]              
	float                                              s_fLastDefendedObjectiveTime;                     		// 0x14C4 (0x0004) [0x0000000000000000]              
	float                                              s_fAccuracyOverride;                              		// 0x14C8 (0x0004) [0x0000000000000000]              
	float                                              s_fDamageAdjustment;                              		// 0x14CC (0x0004) [0x0000000000000000]              
	float                                              s_fHealthAdjustment;                              		// 0x14D0 (0x0004) [0x0000000000000000]              
	int                                                m_nNumberOfLandsBeforeDebuffing;                  		// 0x14D4 (0x0004) [0x0000000000000000]              
	int                                                m_nLandDebuffCounter;                             		// 0x14D8 (0x0004) [0x0000000000000000]              
	float                                              m_fLandDebuffAmount;                              		// 0x14DC (0x0004) [0x0000000000000000]              
	float                                              m_fLandDebuffCounterResetTime;                    		// 0x14E0 (0x0004) [0x0000000000000000]              
	float                                              m_fForceZeroVelocityWhileTurningThreshold;        		// 0x14E4 (0x0004) [0x0000000000000000]              
	struct FDeathZoomInfo                              m_DeathZoomInfo;                                  		// 0x14E8 (0x001C) [0x0000000000000000]              
	class UTgSpecialFx*                                c_DetectedByScanbotSFX;                           		// 0x1504 (0x0004) [0x0000000000000000]              
	float                                              r_fRequiredMoralePoints;                          		// 0x1508 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fCurrentServerMoralePoints;                     		// 0x150C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fCurrentMoralePoints;                           		// 0x1510 (0x0004) [0x0000000000000000]              
	TArray< class ATgDeployable* >                     s_SelfDeployableList;                             		// 0x1514 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nMoraleDeviceSlot;                              		// 0x1520 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nRestDeviceSlot;                                		// 0x1524 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fMoraleRechargeRate;                            		// 0x1528 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UMaterialInstanceConstant*                   c_MatTextMIC;                                     		// 0x152C (0x0004) [0x0000000000000000]              
	class UFont*                                       c_MatTextFont;                                    		// 0x1530 (0x0004) [0x0000000000000000]              
	int                                                c_nMatTextMICResId;                               		// 0x1534 (0x0004) [0x0000000000000000]              
	int                                                c_nMatTextFontResId;                              		// 0x1538 (0x0004) [0x0000000000000000]              
	float                                              c_fMatFontScale;                                  		// 0x153C (0x0004) [0x0000000000000000]              
	int                                                r_nXp;                                            		// 0x1540 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nCurrency;                                      		// 0x1544 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fSkillRating;                                   		// 0x1548 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nToken;                                         		// 0x154C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nHZPoints;                                      		// 0x1550 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nWeeklyToken;                                   		// 0x1554 (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy*                           s_UseProxy;                                       		// 0x1558 (0x0004) [0x0000000000000000]              
	int                                                r_nShieldHealthMax;                               		// 0x155C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nShieldHealthRemaining;                         		// 0x1560 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                c_nDefaultDisintegrateFxId;                       		// 0x1564 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_DisintegrateFx;                                 		// 0x1568 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_SensorAlertSoundFx;                             		// 0x156C (0x0004) [0x0000000000000000]              
	class ATgPlayerController*                         c_LocalPC;                                        		// 0x1570 (0x0004) [0x0000000000000000]              
	struct FTgCameraValues                             m_CachedCameraValue;                              		// 0x1574 (0x005C) [0x0000000000000000]              
	float                                              m_fLastCameraValueTimeStamp;                      		// 0x15D0 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_CachedBaseAimRotation;                          		// 0x15D4 (0x000C) [0x0000000000000000]              
	float                                              m_fLastBaseAimRotationTimeStamp;                  		// 0x15E0 (0x0004) [0x0000000000000000]              
	float                                              m_fPushBlockPressure;                             		// 0x15E4 (0x0004) [0x0000000000000000]              
	float                                              m_fSlowVelSizeSquard;                             		// 0x15E8 (0x0004) [0x0000000000000000]              
	float                                              m_fPushBlockVelMultiplier;                        		// 0x15EC (0x0004) [0x0000000000000000]              
	int                                                c_nTickCheckingState;                             		// 0x15F0 (0x0004) [0x0000000000000000]              
	class UTgManifestGroup*                            c_AssetManifestGroup;                             		// 0x15F4 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	class UTgSpecialFx*                                c_LevelUpFX;                                      		// 0x15F8 (0x0004) [0x0000000000000000]              
	int                                                c_nLevelUpFxId;                                   		// 0x15FC (0x0004) [0x0000000000000000]              
	struct FDouble                                     m_LastCalcVelocityTickTime;                       		// 0x1600 (0x0008) [0x0000000000000000]              
	class UTexture2D*                                  c_BracketULTexture;                               		// 0x1608 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  c_BracketURTexture;                               		// 0x160C (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  c_BracketLLTexture;                               		// 0x1610 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  c_BracketLRTexture;                               		// 0x1614 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  c_BracketULTexture_Selected;                      		// 0x1618 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  c_BracketURTexture_Selected;                      		// 0x161C (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  c_BracketLLTexture_Selected;                      		// 0x1620 (0x0004) [0x0000000000000002]              ( CPF_Const )
	class UTexture2D*                                  c_BracketLRTexture_Selected;                      		// 0x1624 (0x0004) [0x0000000000000002]              ( CPF_Const )
	struct FPointer                                    m_pAmBot;                                         		// 0x1628 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1504 ];

		return pClassPointer;
	};

	void OutputScannerSettings ( );
	void eventOnGenericAIEventChanged ( );
	void ServerChangePhase ( int NewPhase );
	void ChangePhase ( int NewPhase );
	void Perf2 ( unsigned long bEnabled );
	void Perf1 ( unsigned long bEnabled );
	void ServerSetPushBlockParam ( float fPushBlockPressure, float fSlowVelSizeSquard, float fVelModifier );
	void SetPushBlockParam ( float fPushBlockPressure, float fSlowVelSizeSquard, float fVelModifier );
	void SetPushBlockParamHelper ( float fPushBlockPressure, float fSlowVelSizeSquard, float fVelModifier );
	void SetDeviceTypeAnim ( int NewActiveChild, float BlendTime );
	void RemoveAlarmBotDetectionFX ( );
	void OnDetectedByAnAlarmBot ( );
	void OnPhaseTransitionComplete ( );
	void eventOnPhaseChange ( );
	void eventOnPhaseEnded ( int nPhaseThatEnded );
	void eventBaseChange ( );
	void eventClientClosedVendorScene ( );
	bool CanPickupDroppedItem ( );
	void SetRestDevice ( class ATgDevice* newDev );
	bool PickUpBot ( class ATgPawn* pReceiver );
	bool CanBePickedUp ( );
	bool PickupNearestBot ( );
	bool eventIsCrewed ( );
	void ClientOnCrewingBot ( );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	bool CanBeCrewedBy ( class ATgPawn* P );
	void SetDevice ( int DeviceID );
	int eventGetPlayerId ( );
	void ResetMoralePoints ( );
	void Shoulderpads ( unsigned long bOn );
	int eventGetGenderTypeCode ( );
	bool eventIsMedic ( );
	void ResetClientUIAndSensorsOnWeaponChange ( );
	bool eventAimModeAllowed ( );
	struct FTgCameraValues eventGetCameraValues ( );
	bool IsValidMeleeTarget ( class ATgPawn* ProspectiveMeleeTarget );
	void EndSkydiving ( );
	void StartSkydiving ( class ATgSkydivingVolume* V );
	void eventSaveDeathInfoForZoomCam ( class ATgPawn* KillerOwner, class ATgPawn* Killer, int DeviceID, unsigned long bPetKill );
	void eventClientSendBuff ( struct FBuffInfo theBuffInfo );
	void InitKnockdown ( );
	void Stun ( unsigned long bStunController, unsigned char eType );
	void HangingPropelDismountTimer ( );
	void eventLetGoOfHangingLedge ( float SecondsBeforePawnCanHangAgain );
	bool eventIsPet ( );
	void eventTriggerBeaconEntrance ( );
	void ClearTeleportDelayTimer ( );
	void SetTeleportDelayTimer ( float Delay );
	void eventGotoBeacon ( class ATgDeploy_Beacon* beacon );
	void eventTeleport ( struct FVector vDest, struct FRotator rDest, unsigned long bPlayFx );
	bool TeleportTraceCheck ( struct FVector vTestLoc, struct FVector vDestLoc );
	bool PickupNearestDeployable ( );
	void DebugEmitterMask ( int MaskValue );
	void KillPets ( );
	class ATgPawn* GetCurrentOwnerPawn ( );
	bool WasPlayerControlled ( );
	bool WasPlayerSpawned ( );
	void SetSensorAlertLevel ( int nNewLevel );
	void SetAllowAddMoralePoints ( unsigned long bAllowAdd );
	void Tick ( float DeltaSeconds );
	void DoubleCheckSimulatedProxy ( );
	void TickFriendlyPush ( );
	void ConsumePowerPool ( float Amount );
	bool eventShouldRechargePowerPool ( );
	void FPT ( float X, float Y, float Z );
	void LogAnimSetUpdates ( );
	void ShowMeleeSlice ( );
	void gunFOV ( float MyGunFOV );
	void ServerSetTestGlobalVar ( int aVar );
	void SetTestGlobalVar ( int aVar );
	void MWLog ( int logNumber );
	bool IsInBackStabPosition ( class ATgPawn* Target );
	void DisplayMessage ( struct FString sMessage );
	void UpdateMadeSound ( );
	void eventUnTouch ( class AActor* Other );
	void eventOmegaVolumePropertiesChanged ( );
	void eventModifyPawnPropertiesVolumeChanged ( );
	bool RiseFromYourGrave ( );
	void TurnOffBoneSprings ( );
	void eventOnRigidBodySpringOverextension ( class URB_BodyInstance* BodyInstance );
	void SetBoneSprings ( unsigned long bEnabled );
	bool IsAngularBoneSpringName ( struct FName InName );
	bool IsLinearBoneSpringName ( struct FName InName );
	void SetBonesFixed ( unsigned long bSetAllBonesFixed );
	bool IsAimModeName ( struct FName InName );
	bool IsLowerBodyName ( struct FName InName );
	void SetBodiesFixed ( unsigned long InFixed );
	void EnableMotors ( unsigned long InEnabled );
	void SetPhysAnimState ( unsigned char NewState );
	bool PrePokeActor ( struct FVector PokeDir );
	void BoneImpulse ( struct FVector Impulse, struct FVector Loc, struct FName BoneName );
	void eventPoke ( unsigned char byHitType, unsigned char byHitMagnitude, struct FVector HitLocation, struct FVector RayDirection );
	bool IsLocalPlayerInFirstPerson ( );
	class ATgPawn* FindLocalPlayerPawn ( );
	void BlendPawnAnimtreeToMatchInHandDevice ( );
	void BlendToAnimTreeDeviceType ( float fDeviceType, float BlendTime );
	void SetVar ( int varId );
	void ServerSetVar ( int varId );
	void ServerSetGrappleDismount ( float Z, float Intensity );
	void SetGrappleDismount ( float Z, float Intensity );
	void ServerSetProp ( struct FString sCommand );
	void SetProp ( struct FString sCmd, struct FString sValue );
	void OnTeleport ( class USeqAct_Teleport* Action );
	void ClientOnMatchJoin ( class UTgSeqAct_MatchJoin* Action );
	void OnMatchJoin ( class UTgSeqAct_MatchJoin* Action );
	void GrappleDismountTimer ( );
	void EnableHangingCapable ( );
	bool DoJump ( unsigned long bUpdating );
	void ServerCancelJump ( );
	void LoseAccuracyOnJump ( );
	void eventStartCrouch ( float HeightAdjust );
	void eventEndCrouch ( float HeightAdjust );
	struct FRotator GetBaseAimRotation ( class AWeapon* W, unsigned long bIgnoreAutoLock );
	void eventGetBaseAimRotationNative ( class AWeapon* W, unsigned long bIgnoreAutoLock, struct FRotator* Rot );
	struct FVector eventGetWeaponStartTraceLocation ( class ATgDevice* Dev );
	void SetOffhand ( struct FName AnimType, float X, float Y, float Z );
	void SetOffhandAnimationTypeReleaseOffsets ( );
	void AddOffset ( struct FName AnimationType, float X, float Y, float Z );
	struct FVector GetOffhandAnimationTypeReleaseOffset ( struct FName AnimType );
	void HideMessageBoard ( );
	void DisplayMessageBoard ( struct FString sMsg );
	void HideWeaponSwitchProgressBar ( );
	void DisplayWeaponSwitchProgressBar ( float Duration );
	void ClientHideProgressBar ( unsigned long bWorldInteractionBar );
	void ClientDisplayProgressBar ( int Duration, unsigned long bWorldInteractionBar );
	void eventHideProgressBar ( unsigned long bWorldInteractionBar );
	void eventDisplayProgressBar ( int nDuration, unsigned long bIgnoreKismetInterruption, unsigned long bWorldInteractionBar );
	void eventCheckUseDuration ( float* fDuration );
	void ClientSetTriggerMessage ( class ATgTrigger_Use* newTrigger, int msgId );
	void SetTriggerToUse ( class ATgTrigger_Use* Trigger, unsigned long bEnable );
	void InterruptRestDevice ( );
	bool eventIsUseInterrupted ( );
	void InterruptUse ( );
	bool ShouldAllowUse ( struct FString* sMessage );
	bool ShouldInterrupt ( unsigned long bMovementAllowed, unsigned long bRestDeviceAllowed );
	void CheckInterrupt ( );
	void eventEnableFootControls ( int foot, unsigned long bDisable );
	void eventPlayHitReaction ( struct FVector Direction );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	bool IsPreyOfHunter ( class ATgPawn* HunterPawn );
	bool StealthedPlayerResistDeploySensorMinimap ( );
	void ApplyScannerSettingsToPawn ( unsigned long bReset );
	int GetScannerSettingIndexFromEffectGroupId ( int EffectGroupId );
	void ClearScannerSettingByIndex ( int nIndex );
	void ApplyScannerSettings ( );
	void ResetStunnedBehavior ( class ATgPlayerController* PC, class ATgAIController* aic );
	void ClientSetStun ( );
	void eventUnhacked ( unsigned long bPetDeathCam );
	bool eventIsHacked ( );
	void eventHackedBy ( class ATgPawn* ControlPawn );
	void SwapRepInfoForHacking ( unsigned long bHacking );
	void ClientResetMovement ( );
	void StopFullBodyAnimation ( float BlendOutTime );
	void PlayOffhandAnimation ( struct FName OffhandAnimName );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void eventOnAnimPlay ( class UAnimNodeSequence* SeqNode );
	void gibbedBy ( class AActor* Other );
	void DetachConeComponent ( class UDrawConeComponent* ConeComponent );
	class UDrawConeComponent* AttachConeComponent ( class UDrawConeComponent* ConeComponent, float fRadius, float fAngle );
	void eventOnPawnInitialized ( );
	void OnWaitingForPawnDone ( );
	void WaitForInventoryThenDoPostPawnSetup ( );
	void CheckTargetActor ( );
	bool IsTargetWithInAutoLockCone ( class ATgPawn* Target );
	void SetTargetAutoLock ( );
	void eventOnDeviceBuffChange ( );
	bool IsTargetAutoLock ( );
	void eventPropertySet ( int nPropertyId, float fPreviousValue, float fNewValue );
	void eventAttachDevice ( );
	void eventDetachDevice ( );
	void TurnOff ( );
	void eventOutsideWorldBounds ( );
	void eventFellOutOfWorld ( class UClass* dmgType );
	void FlushDebug ( );
	bool IsFirstPerson ( );
	void PlayHit ( float Damage, class AController* InstigatedBy, struct FVector HitLocation, class UClass* dmgType, struct FVector Momentum, struct FTraceHitInfo HitInfo );
	void ProcessEffect ( class UTgEffectGroup* EffectGrp, unsigned long bRemove, class AActor* aInstigator, struct FImpactInfo Impact );
	void PlayLanded ( float ImpactVel );
	void eventPlayLandedAnim ( float ImpactVel );
	void ResetLandDebuffCounter ( );
	void DisableLandingDebuffTimer ( );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	bool eventIsDying ( );
	void ApplyPawnShadows ( unsigned long bOn );
	float eventGetCurrentControlRangePercent ( );
	float eventGetMoraleBoostPercent ( );
	float eventGetPowerPoolPercent ( );
	bool InCombat ( );
	void eventCombat ( unsigned long bInCombat );
	void InCombatTimer ( );
	void ExitCombat ( );
	void EnterCombat ( class AActor* aInstigator, class AActor* ATarget, float fLength );
	void ToggleInHandDevicePS ( unsigned long bOn );
	float GetSensorRange ( );
	void CleanUpMakeVisibleParam ( unsigned long bResetMeshParam );
	void eventApplyStealth ( );
	bool eventCanPawnBeStealthed ( );
	void ApplyStealthClient ( );
	void CheckMoraleDeviceReady ( );
	void CheckBeingTargeted ( );
	void eventReplicatedEvent ( struct FName VarName );
	void PlayDyingTimer ( );
	void SetPlayDyingTimer ( );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void PlayDyingSound ( );
	bool CalcCamera ( float fDeltaTime, struct FVector* out_CamLoc, struct FRotator* out_CamRot, float* out_FOV );
	void OnUpdateHealthVar ( );
	void eventPostRenderFor ( class APlayerController* thePlayerController, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void eventPostRenderDead ( class APlayerController* thePlayerController, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void UpdatePitchRange ( );
	void ManageBlockingClientSide ( );
	void ServerUpdateBlocking ( unsigned long bOn );
	void ManageBlockingServerSide ( );
	bool CanBlock ( );
	class ATgDevice* CacheFiringOffhand ( );
	class ATgDevice* GetFiringOffhandWeapon ( );
	void ServerUpdateAimingMode ( unsigned long bOn );
	void ServerUpdateSnipeScopeMode ( unsigned long bOn );
	void OnAimingModeChange ( );
	void ExitAimingMode ( );
	bool EnterAimingMode ( );
	void ManageZoomingClientSide ( float DeltaSeconds );
	bool CanUseBinoculars ( );
	void ServerSetBinoculars ( unsigned long bOn );
	void ClientZoomIn ( float fFOVModifier, unsigned long bBinoculars );
	void ClientZoomOut ( float fFOVModifier );
	void eventTickZoom ( float DeltaTime );
	float AdjustFOVAngle ( float FOVAngle );
	void DrawZoomedOverlay ( class UCanvas* Canvas );
	unsigned char eventGetZoomOverlayToDraw ( );
	bool InSensorDefaultMode ( );
	bool eventSetActiveWeapon ( class AWeapon* NewWeapon, int nMode, unsigned long bForceFastClear );
	void SetPawnState ( struct FName NewState );
	void ShowVipFx ( unsigned long bShow );
	void RemoveDeathEffects ( );
	void PlayRespawn ( );
	void TimerDestroy ( );
	void PlayDeathFadeEffect ( );
	void PlayDeathFadeEffectDelay ( );
	void CleanupParamsForDying ( );
	void StopAllAnimations ( );
	void RemoveAllEffects ( TArray< int > ExludeCategoryCodes );
	void SetAnyBreakablePhysicsConstraints ( unsigned long bEnabled );
	void PlayDyingEffects ( );
	void PlayDyingPhysicsAndAnimation ( class UClass* TgDmgType, struct FVector HitLoc );
	void Die ( );
	void HideMeshAfterDeathTimer ( );
	void RemoveEffectsTimer ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void RemoveIfLocalTarget ( );
	bool ShouldBeHeard ( );
	void MakeRadarMapNoise ( );
	void eventPlayFootStepSound ( int FootDown, unsigned char FootStepType );
	struct FString GetDebugName ( );
	void ToggleWalkAnim ( );
	void PlayEmote ( );
	void CallBotsForHelp ( );
	void HelpClearTimer ( );
	void CallForHelp ( );
	void SetEmote ( int emote, int Length );
	void eventPostureTransitionEnded ( unsigned char PostureThatEnded );
	void eventSetPosture ( int ePosture, float fRateScale, unsigned long bIgnoreTransition );
	void FaceRotation ( struct FRotator NewRotation, float DeltaTime );
	void eventClimbLadder ( class ALadderVolume* L );
	void eventEndViewTarget ( class APlayerController* PC );
	void eventBecomeViewTarget ( class APlayerController* PC );
	float eventGetPlayerHealthForRender ( );
	struct FString eventGetPlayerTagForRender ( );
	struct FString eventGetPlayerNameForRender ( );
	struct FColor GetTargetBoxColor ( class ATgPawn* LocalPlayerPawn );
	void eventOnGroupChange ( );
	void CheckObjectiveOnGroupChange ( );
	void NotifyTeamChanged ( );
	int GetColumnBasedOnIndex ( int nIndex );
	int GetRowBasedOnIndex ( int nIndex );
	int GetY2CoordBasedOnIndex ( int nIndex );
	int GetX2CoordBasedOnIndex ( int nIndex );
	int GetY1CoordBasedOnIndex ( int nIndex );
	int GetX1CoordBasedOnIndex ( int nIndex );
	class ATgPawn* GetLocalPlayerPawn ( );
	bool LoadPlayerIcons ( );
	bool SeenByLocalPlayer ( class ATgPawn* LocalPlayerPawn );
	void eventDrawMultiLineText ( class UCanvas* Canvas, struct FString Text, int X, int Y, int LineHeight );
	class ATgPlayerController* GetLocalPlayerController ( );
	void AddDamageInfo ( class ATgPawn* SourcePawn, struct FString DamageString, unsigned char Type );
	void ModifyHealthProp ( int nDamage );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void eventDrawAIDebug ( class UCanvas* Canvas, struct FVector ScreenLoc );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void eventSendNotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void PlayTakeHit ( struct FVector HitLoc, int Damage, class UClass* dmgType );
	void StopPlayFiring ( );
	void ClearFlashLocation ( class AWeapon* Who );
	void ClearFlashCount ( class AWeapon* Who );
	void IncrementFlashCount ( class AWeapon* Who, unsigned char FireModeNum );
	bool CanApplyEffects ( );
	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormBuildup ( int nEquipSlot );
	void eventForceRefreshUICooldowns ( );
	void eventUpdateUIDeviceCooldowns ( );
	void eventRestartAllDevices ( );
	void ClientStopFiringAllDevices ( unsigned long bClearEquipEffectFlag, unsigned long bResetCooldowns );
	void eventStopFiringAllDevices ( unsigned long bClearEquipEffectFlag, unsigned long bResetCooldowns );
	class ATgDevice* IsAnyDeviceFiring ( );
	void StopAction ( class ATgDevice* Dev, int nMode );
	bool StartAction ( class ATgDevice* Dev, int nMode );
	void eventSetDisableAction ( unsigned long bDisable );
	void eventAnimSwapDevice ( );
	void UIH ( );
	void eventUpdateInHand ( unsigned long bForceFastClear );
	void EquipPendingDeviceTimer ( unsigned long SkipPlayAnim );
	void ShowAnimSets ( );
	void eventPutInHandDeviceAwayFast ( class UTgDeviceForm* form );
	bool CanChangeInHandDeviceOrMode ( class ATgDevice* instigatorDev );
	void eventResetUIDeviceTimers ( int nDeviceInstanceId );
	void eventKillAllOwnedPets ( );
	void eventDestroyed ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void TakeFallingDamage ( );
	void OnJoinTeam ( class UTgSeqAct_JoinTeam* Action );
	void eventDespawn ( );
	void eventSuicide ( );
	void SetDeathZoomInfo ( class ATgPawn* theKiller, class ATgRepInfo_Player* theKillerPRI, int nHealthPct, int nDeviceId, class ATgRepInfo_Player* OwnerPRI );
	void PreRender ( class UCanvas* Canvas );
	void ResetStealthEffect ( );
	bool eventIsCustomCharacter ( );
	int eventGetBodyMeshId ( );
	void MissionTimeUpdate ( );
	bool eventPostPawnSetup ( );
	void CrushedBy ( class APawn* OtherPawn );
	void InitPhysAnim ( );
	void SetupPIEMesh ( unsigned char PIEPawnType, int MeshId );
	void PostBeginPlay ( );
	void SetLocalPlayer ( );
	void eventPreBeginPlay ( );
	void AllManifestsLoaded ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void ShowCompDebug ( );
	void OnAddAnimSets ( class UTgSeqAct_AddAnimSets* Action );
	void OnKillpawns ( class UTgSeqAct_Killpawns* Action );
	void OnQuestRequirementGetStatus ( class UTgSeqAct_QuestRequirementGetStatus* Action );
	void OnQuestGetStatus ( class UTgSeqAct_QuestGetStatus* Action );
	void OnQuestIncrementReqCount ( class UTgSeqAct_QuestIncrementReqCount* Action );
	void OnSetHomeInstance ( class UTgSeqAct_SetHomeInstance* Action );
	void OnLaunchHomeInstance ( class UTgSeqAct_LaunchHomeInstance* Action );
	void eventFalling ( );
	void eventOnPhysChange ( unsigned char NewPhysState );
	void eventCollisionChanged ( );
	void OnMarkSpawnReturn ( class UTgSeqAct_MarkSpawnReturn* Action );
	void OnSetTaskforce ( class UTgSeqAct_SetTaskforce* Action );
	void OnGetTaskForceNumber ( class UTgSeqAct_GetTaskForceNumber* Action );
	void OnSetUITextBox ( class UTgSeqAct_SetUITextBox* Action );
	void OnUpdateUITextBoxState ( int which );
	void OnUpdateUIClockState ( );
	void OnSetUIClock ( class UTgSeqAct_SetUIClock* Action );
	void OnGetCharClass ( class UTgSeqAct_GetCharClass* Action );
	void OnSetPlayerLevel ( class UTgSeqAct_SetPlayerLevel* Action );
	void OnSetPlayerMesh ( class UTgSeqAct_SetPlayerMesh* Action );
	void OnRequestMission ( class UTgSeqAct_RequestMission* Action );
	void OnEquipCharDevices ( class UTgSeqAct_EquipCharDevices* Action );
	void OnEquipCharDevice ( class UTgSeqAct_EquipCharDevice* Action );
	void OnGetTeamIndex ( class UTgSeqAct_GetTeamIndex* Action );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void eventServerSetIsCrafting ( unsigned long bIsCrafting );
	void ServerTestPushBack ( float Distance );
	void TestPushBack ( float Distance );
	void UpdateControllerVisBasedProperties ( );
	void UpdatePRIAssetRefs ( );
	void ServerOnSetPlayerLevel ( int nLevelId );
	void ServerOnSetPlayerMesh ( int MeshAsmId );
	void ServerOnRequestMission ( class UTgSeqAct_RequestMission* Action );
	void ServerOnEquipCharDevices ( class UTgSeqAct_EquipCharDevices* Action );
	void ServerOnEquipCharDevice ( class UTgSeqAct_EquipCharDevice* Action );
	float NativeGetCollisionRadius ( );
	float NativeGetCollisionHeight ( );
	void OnPostureChange ( );
	void OnProjectileExploded ( );
	void OnAnimNodeChildChanged ( class UAnimNode* Node, int OldChild, int NewChild );
	void RemoveSpawnFadeOutFx ( );
	void SetDeploySensorDetectedStealthLightup ( );
	void LocalProcessScanner ( );
	void OnLevelUp ( );
	void PlayBotSound ( int nSoundCueId );
	bool IsPlayerTagged ( class ATgPlayerController* PC );
	bool ShouldSeeActor ( class AActor* A, int nScannerSettingIndex );
	void ClearEquippedDevice ( );
	bool NativeReplicatedEvent ( struct FName VarName );
	void DoRappelEffects ( );
	void InitSpawnPets ( int SpawnTableID );
	void OnPetSpawned ( class ATgPawn* Pet );
	struct FVector GetTargetCenter ( );
	int GetScannerFOV ( );
	int GetScannerRange ( );
	bool ScannerSeeStealthedTarget ( int nIndex, class ATgPawn* P );
	bool ScannerSeeStealthedPlayer ( class ATgPawn* P );
	bool ScannerSeeBeacon ( int nIndex );
	bool ScannerSeeDeployable ( int nIndex );
	bool ScannerDisplayTargetWithBracket ( class ATgPawn* P, int nIndex );
	bool ScannerDisplayTargetWithLowHealth ( class ATgPawn* P, int nIndex );
	bool ScannerDisplayTargetTagged ( class ATgPawn* P, int nIndex );
	bool ScannerDisplayTargetInGame ( class ATgPawn* P, int nIndex );
	bool ScannerDisplayTargetInMinimap ( class ATgPawn* P, int nIndex );
	bool IsStealthedPlayerDisplayInGameBySensor ( class ATgPawn* LocalPlayerPawn );
	bool SensorDisplayMeWithBracket ( );
	bool SensorDisplayMeWithLowHealth ( );
	bool SensorDisplayMeTagged ( class ATgPawn* LocalPlayerPawn );
	bool SensorDisplayMeInGame ( );
	bool SensorDisplayMeInMinimap ( );
	bool ShouldDisplayWithBracket ( class ATgPawn* LocalPlayerPawn );
	bool ShouldDisplayWithLowHealth ( class ATgPawn* LocalPlayerPawn );
	bool ShouldDisplayInMinimap ( class ATgPawn* LocalPlayerPawn );
	bool StealthedPlayerResistVisualScanner ( );
	bool ValidBotOnlyCheck ( class ATgPawn* P, int nIndex );
	bool IsScannerOn ( );
	bool CheckIndexedFlag ( int nFlag, int nIndex );
	void CheckUiVolumeTriggers ( );
	void DisplayDamageInfo ( class UCanvas* Canvas, struct FVector ScreenLocation );
	void PlayCustomAnimation ( int nAnimResId, unsigned long bFullBody, float fTime );
	struct FLinearColor GetHUDColor ( class ATgPawn* PlayerPawn );
	void SetJetpackTrailId ( int nId );
	void SetDyeItemId ( int nId, unsigned char eSlot );
	int GetDyeItemId ( unsigned char eSlot );
	int GetJetpackTrailId ( );
	void GetCurrentUsedResourceList ( TArray< struct FString > List );
	bool IsNonCombat ( );
	void MatchJoin ( class UTgSeqAct_MatchJoin* Action );
	bool IsCrewable ( );
	bool CanMove ( );
	struct FVector2D GetAim ( );
	struct FVector GetWeaponStartTraceLocationFromSocketOffsetInfo ( class ATgDevice* Dev );
	void CalculateYawPitchOffset ( float DeltaSeconds, float TurnTime );
	void TriggerSubzoneBilboardChange ( );
	void TriggerSubzoneChange ( );
	void TriggerOmegaAlert ( );
	void PlayUpperBodyAnim ( struct FName AnimName, float Rate, float BlendInTime, unsigned long bLooping );
	float PlayFullBodyLoopingAnimWithTransition ( struct FName TransitionAnimName, struct FName LoopingAnimName, float Rate, float BlendInTime, float BlendOutTime );
	void PlayFullBodyAnim ( struct FName AnimName, float Rate, float BlendInTime, float BlendOutTime, unsigned long bLooping, unsigned long bOverride, unsigned long bDisablePlayerControls, unsigned long bBlendOutIfVelocityIsGreaterThanZero, unsigned long bHideInHandDevice );
	bool IsFriendlyWithLocalPawn ( );
	void GetCurrentDeviceAccuracyInfo ( float* fAccuracy, float* fAmountCurrentlyOffOfTargetAccuray );
	void SetDisintegrateData ( );
	void ForceUpdateEquippedDevices ( );
	void RegainMoraleBoost ( float fDelta );
	void RegainPowerPool ( float fDelta );
	struct FVector GetSeekingTargetLocation ( );
	bool CheckWeakSpotPassThrough ( struct FVector HitLocation, struct FVector HitNormal, unsigned long bAllowZImpactOutsideOfCylidnerHeightRange );
	void SetScannerDetectedStealthLightup ( );
	bool IsVisibilityFadeDone ( );
	bool IsFadeInEffectDone ( );
	bool NeedFadeInEffect ( );
	bool NeedPlayDeathFadeEffect ( );
	float GetHealthPercent ( );
	void UpdateTitle ( );
	void MakeInvulnerable ( float fLength );
	void SetMeshScalarValue ( struct FName ScalarParam, float ScalarValue );
	void ForceResetTaskForce ( class ATgPawn* PawnInstigator, unsigned long bResetTaskforce );
	bool MoveCloseTo ( struct FVector vDesiredLocation );
	void HideCrewMessage ( );
	void DisplayCrewMessage ( );
	void UnCrewed ( unsigned long bKillControlPawn );
	void CrewBot ( class ATgPawn* bot );
	void SetHexItem ( class UTgHexItemInstance* newHexItem );
	void KillDeployables ( unsigned long bAll );
	int DrawMatString ( class UCanvas* CanvasToUse, float StartX, float StartY, float XScale, float YScale, struct FString NameString, class UFont* NameFont, class UMaterialInstanceConstant* FontMIC );
	bool IsCarryingPickupFlag ( );
	bool IsCarryingBeacon ( );
	class ATgDevice_Morale* GetMoraleDevice ( );
	void AddMoralePoints ( float fPoints, int nDeviceModeID );
	void DrawLineToOwner ( );
	bool ShouldApplyJetpackTrail ( );
	void ApplyJetpackTrail ( unsigned long bReset );
	bool ShouldApplyDye ( );
	void ApplyDye ( unsigned long bResetDyeMIC );
	void SwapAttachedDeviceMaterials ( class UMaterialInstanceConstant* NewMaterial, unsigned long bIgnoreParams );
	void SwapSkinMaterials ( TArray< struct FFx_Material > MaterialList, unsigned long bIgnoreParams, unsigned long bIsFriendly );
	void SetSkin ( class UTgSpecialFx* NewSpecialFx, unsigned long bIgnoreParams, unsigned long bForceSetSkin );
	bool IsHenchman ( );
	bool IsStealthActive ( );
	bool IsStealthed ( );
	class ATgDevice* GetDeviceByInstanceId ( int nDeviceInstanceId );
	struct FString GetDeviceNameByID ( int DeviceID );
	void ManageFirstPerson ( );
	bool OnPawnDied ( );
	void ApplyAnyPushback ( float DeltaTime );
	bool Pushback ( struct FVector Distance );
	void PlaySpawnFadeOutFx ( );
	void PlayTeleportFx ( int nTeleportState, struct FVector vLoc );
	class UTgImpactFx* GetImpactFxGroup ( int ImpactGroupID );
	void TickMakeVisibleCalculation ( float DeltaSeconds );
	bool ShouldUpdateStealthedFor ( class ATgPawn* ViewerPawn );
	float GetTerminalVelocity ( );
	int GetMeshIdFromFlairId ( int nItemId );
	void ApplyFlair ( struct FString sFlairName );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn );
	bool CanBeAffectedByVortices ( );
	bool IsInvisible ( );
	bool ShouldInHandDeviceBeHiddenThisTick ( );
	bool ShouldPawnMeshBeHiddenThisTick ( );
	class UFont* GetFont ( int nResId );
	class UMaterialInstanceConstant* GetMIC ( int nResId );
	void PlaySoundCue ( int nSoundCueId );
	void SensorAlertSound ( unsigned long bPlay );
	void NativeSet ( struct FString sCommand );
	void CheckUseQuestCredit ( );
	void CheckKillQuestCredit ( class ATgRepInfo_TaskForce* tf );
	void SpawnLoot ( class ATgRepInfo_TaskForce* tf );
	void GiveKillXp ( class ATgRepInfo_TaskForce* tf );
	void DoGenericAIEvent ( int NewActionIndex );
	void SetPhase ( int nNewPhase );
	void UpdateHUDScores ( );
	void TrackDeath ( );
	void TrackKill ( class ATgPawn* Killer );
	void UpdateDebuffer ( class ATgPawn* Debuffer );
	void UpdateBuffer ( class ATgPawn* Buffer );
	void UpdateHealer ( class ATgPawn* Healer );
	void UpdateDamagers ( class ATgPawn* Damager );
	void TrackBoost ( );
	void TrackMyBeaconUsed ( );
	void TrackDamageTaken ( int nDamage );
	void TrackSelfKill ( int nDeviceModeID );
	void TrackTeamKill ( int nDeviceModeID );
	void TrackSelfDamage ( int nDeviceModeID, int nDamage );
	void TrackTeamDamage ( int nDeviceModeID, int nDamage );
	void TrackReleaseTime ( int nDeviceModeID, float fReleaseTime );
	void TrackBuff ( int nDeviceModeID, float fValue );
	void TrackHit ( int nDeviceModeID, float fDistance, unsigned long bHitPlayer );
	void RemoveTrackFired ( int nDeviceModeID );
	void TrackCompleteKillInfo ( int nKillerCharacterID, int nKillerDeviceModeID, int nVictimCharacterID, int nVictimDeviceModeID, struct FVector KillerLocation, struct FVector VictimLocation, struct FVector PetLocation, unsigned long bPetKill );
	void TrackFired ( int nDeviceModeID );
	void TrackObjectivePointsByProgress ( int nPoints );
	void TrackObjectivePoints ( int nPoints );
	void TrackEscortObjective ( float fDeltaTime );
	void TrackObjective ( float fDeltaTime );
	void TrackDefense ( int nDeviceModeID, int nDamage );
	void TrackBotHealing ( int nDeviceModeID, float fDamage, float fMissingHealth, int nMaxHealth );
	void TrackHealing ( int nDeviceModeID, float fDamage, float fMissingHealth, int nMaxHealth );
	void TrackKilledBot ( int nDeviceModeID );
	void TrackFromPlayerDeath ( int nDeviceModeID );
	void TrackKilledPlayer ( int nDeviceModeID );
	void TrackDamagedBot ( class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage );
	void TrackDamagedPlayer ( class ATgPawn* TargetPawn, int nDeviceModeID, int nDamage );
	void EndStats ( );
	void BeginStats ( );
	void StatsCleanup ( );
	void ValidateStatsTracker ( );
	bool IsProfileNonStandard ( );
	void SetDebugParticleMaskNative ( int MaskValue );
	unsigned char CreateUITextBoxBitfield ( class UTgSeqAct_SetUITextBox* Action );
	unsigned char CreateUIClockBitfield ( unsigned long Alarm, unsigned long Bar, unsigned long Down );
	void CheckRootBoneCorrection ( float DeltaSeconds );
	class ATgPawn* FindPlayerPawn ( struct FString fsName );
	class ATgRepInfo_Player* GetPRI ( );
	void RemoveAllAnimationSets ( );
	unsigned char GetEquipPointByType ( int nDeviceType );
	void ReapplyCurrentMICFx ( );
	bool RemoveMICFx ( class UTgSpecialFx* SpecialFx, unsigned long bForceRemove );
	bool ApplyMICFx ( class UTgSpecialFx* SpecialFx, int Priority );
	class UMaterialInstanceConstant* SwapMeshToStealthed ( unsigned long bStealthed );
	void SwapMeshToDestroyed ( );
	int GetAllianceNumber ( );
	unsigned char GetTaskForceNumber ( );
	void SetTaskForceNumber ( int nTaskForce );
	float CheckTargetDistance ( class AActor* TargetActor );
	void UpdateTargetCylinderLocation ( float DeltaSeconds );
	void UpdateTargetCylinderSize ( );
	void AdjustMeshTranslation ( );
	void SetCollisionFromMesh ( int nMeshAsmId );
	void KillOwnedBots ( );
	void KillPet ( );
	void SetPet ( class ATgPawn* PetPawn );
	struct FString GetResourceFromGAssembly ( int ResId );
	void ReplaceMeshComponent ( int nNewMeshId, class UMeshComponent* DestComponent );
	class UMeshComponent* CreateMeshComponent ( int nMeshId );
	class UTgSpecialFx* GetSpecialFx ( int nSpecialFxId );
	void SetDeviceVisibility ( unsigned long bVisible );
	void SetMeshVisibility ( unsigned long bVisible );
	bool CanSeeActor ( class AActor* aActor, unsigned long bRequiresLOS );
	bool IsPhysicalLadderInFrontOfPawn ( unsigned long bTraceFromTopOfCylinder );
	float GetGravityZ ( );
	bool GetIconResource ( int nIconId, struct FIcon_Info* iconInfo );
	void AddRemoveAnimSetList ( TArray< class UAnimSet* > AnimSetList, unsigned long bAdd );
	void PlaySoundEmote ( );
	void PlayAnimEmote ( );
	bool TermRagdoll ( );
	void LogPawnAnim ( );
	bool IsPointInsideCollisionCylinder ( struct FVector Point, float AddHeight, float AddRadius );
	bool DetermineMeshVisibility ( );
	void DrawClientDebug ( );
	bool bIsEditor ( );
	void OnCrafting ( unsigned long bStart );
	void ReapplyLoadoutEffects ( );
	void ReapplyCharacterSkillTree ( );
	void SendAllDeviceSkillBuffs ( );
	int GetSpawnerDeviceInstanceId ( );
	int GetSpawnerDeviceSkillId ( );
	void ConvertPropToPropList ( struct FBuffRequest request, class UTgEffect* Effect, TArray< int >* PropList );
	void CheckBuffInfoList ( struct FBuffRequest request, TArray< int > nBuffPropertyList, float fBaseValue, float* fBuffedValue );
	struct FBuffInfo GetBuffInfo ( struct FBuffHeader BuffFilter );
	void ApplyBuff ( struct FBuffHeader BuffFilter, int nCalcMethodCode, float fAmount, unsigned long bRemove, unsigned char buffSourceType );
	void GetBuffIndex ( struct FBuffHeader BuffFilter, unsigned long bAddIfNotExists, int* nIndex );
	void GetBuffedProperty ( struct FBuffRequest request, float fBaseValue, class UTgEffect* Effect, float* fBuffedValue );
	void FlashLevelupFx ( );
	void FlashTeleportFx ( int nTeleportState, struct FVector vLocation );
	void FlashChangeMesh ( );
	void FlashHitWall ( struct FVector HitNormal );
	void FlashDestruct ( int nDeviceInstanceId, struct FVector vLocation );
	void FlashShowDamage ( int nDeviceInstanceId );
	void FlashResyncClient ( );
	void FlashModeEquipDone ( int nDeviceInstanceId, int nFireModeNum );
	void FlashEventUpdate ( );
	void FlashHit ( unsigned char byHitType, unsigned char byHitMagnitude, struct FVector vLocation, struct FVector vRayDir );
	void FlashInterrupt ( int nDeviceInstanceId );
	void FlashBlockDone ( int nDeviceInstanceId, int nFireModeNum );
	void FlashBlockFx ( int nDeviceInstanceId, int nFireModeNum );
	void FlashBlock ( int nDeviceInstanceId, int nFireModeNum );
	void FlashCooldownDone ( int nDeviceInstanceId, int nFireModeNum );
	void FlashCooldown ( int nDeviceInstanceId, int nFireModeNum );
	void FlashStartFire ( int nDeviceInstanceId, int nFireModeNum );
	void FlashStopFire ( int nDeviceInstanceId, int nFireModeNum );
	void FlashArcing ( int nDeviceInstanceId, int nFireModeNum, struct FVector vNewLoc, struct FVector vOldLoc, int nEquipSlot, int nSocketIndex, unsigned long bsuccesfulhit );
	void FlashFireNoSim ( int nDeviceInstanceId, int nFireModeNum, struct FVector vNewLoc, int nEquipSlot, int nSocketIndex, unsigned long bsuccesfulhit, unsigned long bSecondaryShot, int SituationalAttackType, float RefireTime );
	void FlashFire ( int nDeviceInstanceId, int nFireModeNum, struct FVector vNewLoc, int nEquipSlot, int nSocketIndex, unsigned long bsuccesfulhit, unsigned long bSecondaryShot, int SituationalAttackType, float RefireTime );
	void FlashBuildUp ( int nDeviceInstanceId, int nFireModeNum, int nEquipSlot, int nSocketIndex );
	void FlashFireMode ( int nDeviceInstanceId, int nFireModeNum );
	void FlashResetReplication ( );
	struct FVector NativeCanvasProject ( class UCanvas* CanvasToUse, struct FVector vLocation );
	int DrawNameText ( class UCanvas* CanvasToUse, float StartX, float StartY, struct FString NameString, class UFont* NameFont, struct FColor NameColor, float Scale );
	int DrawScaledString ( class UCanvas* CanvasToUse, float StartX, float StartY, struct FString NameString, class UFont* NameFont, struct FColor NameColor, float Scale );
	void ResetProperties ( );
	void SetProperty ( int nPropertyId, float fNewValue );
	class UTgProperty* GetProperty ( int nPropertyId );
	void AddProperty ( int nPropId, float fBase, float fRaw, float FMin, float FMax );
	void InitializeDefaultProps ( );
	bool ApplyPawnSetup ( );
	void DoBlend ( struct FName BlendName, float BlendTarget, float BlendTime, class USkeletalMeshComponent* SkelMesh );
	void DeviceFormChanged ( unsigned long bForceReload );
	class UTgDeviceForm* CreateDeviceForm ( struct FEquipDeviceInfo Info );
	class ATgDevice* CreateEquipDevice ( int nInventoryId, int nDeviceId, unsigned char ePoint );
	class ATgDevice* GetDeviceByEqPoint ( int eEqPoint );
	void UpdateClientDevices ( unsigned long bForce, unsigned long bForceDeviceFormArg );
	bool IsBlocking ( );
	void BeginEquipOffhandCooldown ( );
	void RealSetDevice ( int DeviceID );
	void SetTargetActor ( class AActor* Target );
	class ATgPawn* GetTargetPawn ( );
	class AActor* GetTargetActor ( );
	int GetTestGlobalVar ( );
	void NativeSetTestGlobalVar ( int aVar );
	void DrawLowHealthEffects ( class ATgPlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void DrawTargetBox ( class ATgPlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir, unsigned long bAnimated );
	void DrawPlayerStat ( class ATgPlayerController* PC, class UCanvas* Canvas, struct FVector ScreenLoc, unsigned long bIsFriendly, unsigned long bIsSameTeam, float fScaleFactor, float fAlphaLevel, unsigned long bIsTarget );
	void DrawPlayerIcon ( class ATgPlayerController* PC, class UCanvas* Canvas, struct FVector vScreenLoc, float fTagScaleFactor, unsigned long bIsFriendly, unsigned long bIsSameTeam );
	void TGPostRenderFor ( class APlayerController* thePlayerController, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
};

UClass* ATgPawn::pClassPointer = NULL;

// Class TgGame.TgPawn_AttackTransport
// 0x0034 (0x1660 - 0x162C)
class ATgPawn_AttackTransport : public ATgPawn
{
public:
	unsigned char                                      r_DeathType;                                      		// 0x162C (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bHasFrontHullExploded : 1;                      		// 0x1630 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bHasTailExploded : 1;                           		// 0x1630 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bDrawMainBeamToTargetingDestination : 1;        		// 0x1630 (0x0004) [0x0000000000000000] [0x00000004] 
	struct FVector                                     c_vTargetingBeamDestination;                      		// 0x1634 (0x000C) [0x0000000000000000]              
	float                                              c_fRemainingBeamHoneInTime;                       		// 0x1640 (0x0004) [0x0000000000000000]              
	float                                              c_fBeamHoneInTime;                                		// 0x1644 (0x0004) [0x0000000000000000]              
	float                                              c_fInitialBeamAngle;                              		// 0x1648 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_TargetingBeamFX;                                		// 0x164C (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      c_LaserSpinControl;                               		// 0x1650 (0x0004) [0x0000000000000000]              
	class USkelControlLookAt*                          m_AimSkelControl;                                 		// 0x1654 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_HoverControl*                     m_HoverSkelControl;                               		// 0x1658 (0x0004) [0x0000000000000000]              
	float                                              m_MaxDownwardAim;                                 		// 0x165C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1505 ];

		return pClassPointer;
	};

	void ExplodeHoveringTimer6 ( );
	void ExplodeHoveringTimer5 ( );
	void ExplodeHoveringTimer4 ( );
	void ExplodeHoveringTimer3 ( );
	void ExplodeHoveringTimer2 ( );
	void ExplodeHoveringTimer1 ( );
	void PlayDeathBasedOnDeathType ( );
	void PlayDyingPhysicsAndAnimation ( class UClass* TgDmgType, struct FVector HitLoc );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void eventOnPhaseChange ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormBuildup ( int nEquipSlot );
	bool eventPostPawnSetup ( );
	void SetMovementPhysics ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventReplicatedEvent ( struct FName VarName );
	void OnProjectileExploded ( );
	void ProcessAim ( );
	void ExplodeMeshOnRigidBodyCollision ( );
	void OnPetSpawned ( class ATgPawn* Pet );
	void InitSpawnPets ( int SpawnTableID );
};

UClass* ATgPawn_AttackTransport::pClassPointer = NULL;

// Class TgGame.TgPawn_Character
// 0x0604 (0x1C30 - 0x162C)
class ATgPawn_Character : public ATgPawn
{
public:
	int                                                s_nCharacterId;                                   		// 0x162C (0x0004) [0x0000000000000000]              
	int                                                r_nHeadMeshAsmId;                                 		// 0x1630 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nItemProfileId;                                 		// 0x1634 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nItemProfileNbr;                                		// 0x1638 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDeviceSlotUnlockGrpId;                         		// 0x163C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nSkillGroupSetId;                               		// 0x1640 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FPointer                                    s_pCombatMessages;                                		// 0x1644 (0x0004) [0x0000000000001000]              ( CPF_Native )
	float                                              s_fLastCombatMessageProcess;                      		// 0x1648 (0x0004) [0x0000000000000000]              
	int                                                m_XpLevelCap;                                     		// 0x164C (0x0004) [0x0000000000000000]              
	unsigned long                                      r_bElfGogglesEquipped : 1;                        		// 0x1650 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      m_bEnableRightFootPlacement : 1;                  		// 0x1650 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bEnableLeftFootPlacement : 1;                   		// 0x1650 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bMayDisableFootIKFromAnimNodes : 1;             		// 0x1650 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bInitializedFootIKCachedNodeList : 1;           		// 0x1650 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bApplyLeftHandWeaponIK : 1;                     		// 0x1650 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bSetHandIKStrengthFromAnimNodes : 1;            		// 0x1650 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bInitializedHandIKCachedNodeList : 1;           		// 0x1650 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bApplyMorphSettingsNextTick : 1;                		// 0x1650 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      s_bUpgradesDegraded : 1;                          		// 0x1650 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      c_bCanDropStuffOnDeath : 1;                       		// 0x1650 (0x0004) [0x0000000000000000] [0x00000400] 
	class UTgSkelCon_LookAt*                           m_AimLookAt;                                      		// 0x1654 (0x0004) [0x0000000000000000]              
	struct FQWord                                      m_qwBoostExpirationDateTime;                      		// 0x1658 (0x0008) [0x0000000000000000]              
	int                                                r_nBoostTimeRemaining;                            		// 0x1660 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                m_nPersistentBuffModifier;                        		// 0x1664 (0x0004) [0x0000000000000000]              
	int                                                m_nPersistentQuestBuffModifier;                   		// 0x1668 (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmLeftFootBone;                                 		// 0x166C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmRightFootBone;                                		// 0x1674 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmLeftFootControlName;                          		// 0x167C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_nmRightFootControlName;                         		// 0x1684 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fOldLocationZ;                                  		// 0x168C (0x0004) [0x0000000000000000]              
	float                                              m_fZSmoothingRate;                                		// 0x1690 (0x0004) [0x0000000000000002]              ( CPF_Const )
	float                                              m_fMaxFootPlacementDistSquared;                   		// 0x1694 (0x0004) [0x0000000000000000]              
	class USkelControlFootPlacement*                   m_LeftLegControl;                                 		// 0x1698 (0x0004) [0x0000000000000000]              
	class USkelControlFootPlacement*                   m_RightLegControl;                                		// 0x169C (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_FootIKZeroStrengthAnimNodeNameList;             		// 0x16A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_FootIKZeroStrengthCachedNodeList;               		// 0x16AC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FVector                                     m_vPreviousRightFootPosition;                     		// 0x16B8 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vPreviousLeftFootPosition;                      		// 0x16C4 (0x000C) [0x0000000000000000]              
	float                                              m_fCachedRightTracedFloor;                        		// 0x16D0 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedLeftTracedFloor;                         		// 0x16D4 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedRightFloorNormalZ;                       		// 0x16D8 (0x0004) [0x0000000000000000]              
	float                                              m_fCachedLeftFloorNormalZ;                        		// 0x16DC (0x0004) [0x0000000000000000]              
	int                                                m_nCachedLeftFootBoneIndex;                       		// 0x16E0 (0x0004) [0x0000000000000000]              
	int                                                m_nCachedRightFootBoneIndex;                      		// 0x16E4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_SkelControl_LeftHandName;                       		// 0x16E8 (0x0008) [0x0000000000000000]              
	class USkelControlLimb*                            m_SkelControl_LeftHand;                           		// 0x16F0 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_SkelControl_LeftHandRotate;                     		// 0x16F4 (0x0004) [0x0000000000000000]              
	struct FName                                       m_SkelControl_RightHandName;                      		// 0x16F8 (0x0008) [0x0000000000000000]              
	class USkelControlLimb*                            m_SkelControl_RightHand;                          		// 0x1700 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_SkelControl_RightHandRotate;                    		// 0x1704 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_SkelControl_RightToLeftPropSwitch;              		// 0x1708 (0x0004) [0x0000000000000000]              
	TArray< struct FName >                             m_HandIKFullStrengthAnimNodeNameList;             		// 0x170C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FName >                             m_HandIKZeroStrengthAnimNodeNameList;             		// 0x1718 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_HandIKFullStengthCachedNodeList;                		// 0x1724 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UAnimNode* >                         m_HandIKZeroStrengthCachedNodeList;               		// 0x1730 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_FadeMaterialControllerBody;                     		// 0x173C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_FadeMaterialControllerHead;                     		// 0x1740 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   m_FadeMaterialControllerHair;                     		// 0x1744 (0x0004) [0x0000000000000000]              
	class UTgSkeletalMeshComponent*                    c_HeadMesh;                                       		// 0x1748 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgStaticMeshComponent*                      c_HairMesh;                                       		// 0x174C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    c_HelmetMesh;                                     		// 0x1750 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMeshComponent*                              c_BackpackMesh;                                   		// 0x1754 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMaterialInterface*                          c_SavedHeadMICForStealth;                         		// 0x1758 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          c_SavedHelmetMICForStealth;                       		// 0x175C (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          c_SavedBackpackMICForStealth;                     		// 0x1760 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          c_SavedHairMICForStealth;                         		// 0x1764 (0x0004) [0x0000000000000000]              
	class UMaterialInterface*                          c_SavedDeviceMICForStealth;                       		// 0x1768 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_PrimaryDyeMIC;                                  		// 0x176C (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_SecondaryDyeMIC;                                		// 0x1770 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_EmissiveDyeMIC;                                 		// 0x1774 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_WeaponColorDyeMIC;                              		// 0x1778 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_WeaponEmissiveDyeMIC;                           		// 0x177C (0x0004) [0x0000000000000000]              
	int                                                c_nJetpackTrailAsmId;                             		// 0x1780 (0x0004) [0x0000000000000000]              
	struct FCustomCharacterAssembly                    r_CustomCharacterAssembly;                        		// 0x1784 (0x0044) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	struct FCustomCharacterAssembly                    s_OrigCustomCharacterAssembly;                    		// 0x17C8 (0x0044) [0x0000000000000000]              
	int                                                r_nMorphSettings[ 0xFF ];                         		// 0x180C (0x03FC) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMaxMorphIndexSentFromServer;                   		// 0x1C08 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_LastAutoTag;                                    		// 0x1C0C (0x0004) [0x0000000000000000]              
	unsigned char                                      r_eAttachedMesh;                                  		// 0x1C10 (0x0001) [0x0000000000000020]              ( CPF_Net )
	class ATgKAssetSpawnable*                          c_DroppedWeaponKAsset;                            		// 0x1C14 (0x0004) [0x0000000000000000]              
	class ATgKAssetSpawnable*                          c_DroppedBackpackKAsset;                          		// 0x1C18 (0x0004) [0x0000000000000000]              
	class ATgPawn_VanityPet*                           r_CurrentVanityPet;                               		// 0x1C1C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_WallJumpZ;                                      		// 0x1C20 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_WallJumpWallDetectionDistance;                  		// 0x1C24 (0x0004) [0x0000000000000000]              
	float                                              r_WallJumpUpperLineCheckOffset;                   		// 0x1C28 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_WallJumpLowerLineCheckOffset;                   		// 0x1C2C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1506 ];

		return pClassPointer;
	};

	void OnSetPlayerMesh ( class UTgSeqAct_SetPlayerMesh* Action );
	void SetupPIEMesh ( unsigned char PIEPawnType, int MeshId );
	void SetHeadMICVectorValue ( struct FName ParameterName, float valueX, float valueY, float valueZ );
	void SetHeadMICFloatValue ( struct FName ParameterName, float Value );
	void ShowHeadMICValues ( );
	void eventPlayFootStepSound ( int FootDown, unsigned char FootStepType );
	struct FCustomCharacterAssembly GetDefaultAssembly ( unsigned long IsFemale );
	int eventGetGenderTypeCode ( );
	void Destroyed ( );
	void KillPets ( );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	bool ShouldDoWallJump ( );
	bool DoJump ( unsigned long bUpdating );
	void eventClientPurchaseItem ( int nLootTableId, int nLootTableItemId, int nItemCount, int nAttemptedCurrencyType, int nAttemptedCostPerItem );
	bool CanTrackATarget ( );
	void SetAimTarget ( float X, float Y, float Z );
	void eventUpdateMeshBoneControllers ( float DeltaTime );
	void eventEnableFootControls ( int foot, unsigned long bDisable );
	void PossessedBy ( class AController* C, unsigned long bVehicleTransition );
	void zpivot ( float F );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void Tick ( float DeltaSeconds );
	bool eventCanPawnBeStealthed ( );
	bool eventIsCustomCharacter ( );
	void eventInitializeDefaultProps ( );
	void PostBeginPlay ( );
	void eventOnGroupChange ( );
	void eventOnCustomAssemblyChanged ( );
	void eventReplicatedEvent ( struct FName VarName );
	void AllManifestsLoaded ( );
	int eventGetBodyMeshId ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void UpdatePRIAssetRefs ( );
	void VanityPetDestroyed ( class ATgPawn_VanityPet* Pet );
	void DismissVanityPet ( );
	void SpawnVanityPet ( int nInvId );
	bool CanItemBePurchased ( int nLootTableId, int nLootTableItemId );
	void SendCombatMessage ( struct FCombatMessageInfo msgInfo );
	void ServerOnSetPlayerMesh ( int MeshAsmId );
	void ServerRemoveAllCharSkills ( );
	void ServerPurchaseItem ( int nLootTableId, int nLootTableItemId, int nItemCount, int nAttemptedCurrencyType, int nAttemptedCostPerItem );
	void UpdateDurability ( );
	void CrewBot ( class ATgPawn* bot );
	void CraftItem ( int nBlueprintId, unsigned long bSystemCraft, unsigned long bUseComponents, int nSystemCraftLevel );
	void ApplyJetpackTrail ( unsigned long bReset );
	void SetJetpackTrailId ( int nId );
	void SetDyeItemId ( int nId, unsigned char eSlot );
	int GetDyeItemId ( unsigned char eSlot );
	int GetJetpackTrailId ( );
	void GetHairColorsFromHeadMorphData ( struct FHairColorParams* OutHairColors );
	void GetSkinColorsFromHeadMorphData ( struct FLinearColor* OutSkinColor, struct FLinearColor* OutBaseSkinColor, float* OutSkinTone );
	class UAnimTree* GetHeadAnimTree ( );
	void ApplyMorphSettings ( );
	void ApplyDye ( unsigned long bResetDyeMIC );
	int GetHelmMeshIdToUse ( );
	int GetSuitMeshIdToUse ( );
	void SetCurrentItemProfile ( int nItemProfileId );
	int GetDefaultHelmMeshId ( unsigned long bFemale, int nProfileId );
	int GetDefaultSuitMeshId ( unsigned long bFemale, int nProfileId );
	void SetTeamColorForDeathSpawnedAsset ( class UMeshComponent* MeshComp, unsigned long bNeedApplySuitDye );
	void SwapSkinMaterials ( TArray< struct FFx_Material > MaterialList, unsigned long bIgnoreParams, unsigned long bIsFriendly );
	void SetSkin ( class UTgSpecialFx* NewSpecialFx, unsigned long bIgnoreParams, unsigned long bForceSetSkin );
	class UTgDeviceForm* CreateDeviceForm ( struct FEquipDeviceInfo Info );
	void ApplyFlair ( struct FString sFlairName );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn );
	bool ApplyItemEffects ( class UTgInventoryObject* pItem, unsigned long bRemove );
	void SetMeshVisibility ( unsigned long bVisible );
	void RemoveCharacterSkillTree ( );
	void ReapplyCharacterSkillTree ( );
	void ReapplyLoadoutEffects ( );
	void SendCharacterSkillMarshal ( );
	class UMaterialInstanceConstant* SwapMeshToStealthed ( unsigned long bStealthed );
	void UpdateCustomCharacterMaterialParameters ( unsigned long bUpdateOnlyHairMeshMaterial, unsigned long bUpdateOnlySuitMeshMaterial );
	void UpdateBoost ( );
	void UpdateElfGoggles ( );
	bool InitializeFootIKZeroStrengthAnimNodes ( class USkeletalMeshComponent* SkelComp );
	bool InitializeLeftHandIKAnimNodes ( class USkeletalMeshComponent* SkelComp );
	bool ApplyPawnSetup ( );
};

UClass* ATgPawn_Character::pClassPointer = NULL;

// Class TgGame.TgPawn_Boss
// 0x000C (0x1C3C - 0x1C30)
class ATgPawn_Boss : public ATgPawn_Character
{
public:
	unsigned long                                      m_bExplodeOnDeathAnimEnd : 1;                     		// 0x1C30 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fDeathExplodeImpulseRadius;                     		// 0x1C34 (0x0004) [0x0000000000000000]              
	float                                              m_fDeathExplodeImpulseStrength;                   		// 0x1C38 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1507 ];

		return pClassPointer;
	};

	void DoRagdoll ( );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	struct FVector eventGetWeaponStartTraceLocation ( class ATgDevice* Dev );
};

UClass* ATgPawn_Boss::pClassPointer = NULL;

// Class TgGame.TgPawn_ColonyEye
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_ColonyEye : public ATgPawn_Boss
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1508 ];

		return pClassPointer;
	};

	void SetMovementPhysics ( );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_ColonyEye::pClassPointer = NULL;

// Class TgGame.TgPawn_Dismantler
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Dismantler : public ATgPawn_Boss
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1509 ];

		return pClassPointer;
	};

	void OnPostureChange ( );
	bool eventPostPawnSetup ( );
	void OnPetSpawned ( class ATgPawn* Pet );
	void InitSpawnPets ( int SpawnTableID );
};

UClass* ATgPawn_Dismantler::pClassPointer = NULL;

// Class TgGame.TgPawn_FlyingBoss
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_FlyingBoss : public ATgPawn_Boss
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1510 ];

		return pClassPointer;
	};

	void SetMovementPhysics ( );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_FlyingBoss::pClassPointer = NULL;

// Class TgGame.TgPawn_Juggernaut
// 0x0008 (0x1C44 - 0x1C3C)
class ATgPawn_Juggernaut : public ATgPawn_Boss
{
public:
	class UTgSpecialFx*                                c_BeamFX;                                         		// 0x1C3C (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_SpinSkelControl;                                		// 0x1C40 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1511 ];

		return pClassPointer;
	};

	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void eventTornOff ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void UpdateTargetingBeam ( );
};

UClass* ATgPawn_Juggernaut::pClassPointer = NULL;

// Class TgGame.TgPawn_Marauder
// 0x0048 (0x1C84 - 0x1C3C)
class ATgPawn_Marauder : public ATgPawn_Boss
{
public:
	class UMaterialInstanceConstant*                   m_TreadMaterialInstance;                          		// 0x1C3C (0x0004) [0x0000000000000000]              
	float                                              m_fTreadSpeedModifier;                            		// 0x1C40 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_LeftTreadSpeed;                                 		// 0x1C44 (0x0004) [0x0000000000000000]              
	float                                              m_RightTreadSpeed;                                		// 0x1C48 (0x0004) [0x0000000000000000]              
	struct FName                                       m_LeftTreadScalarName;                            		// 0x1C4C (0x0008) [0x0000000000000000]              
	struct FName                                       m_RightTreadScalarName;                           		// 0x1C54 (0x0008) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_MinigunLSpinSkelControl;                        		// 0x1C5C (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_MinigunRSpinSkelControl;                        		// 0x1C60 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_rRotationRateOriginal;                          		// 0x1C64 (0x000C) [0x0000000000000000]              
	float                                              m_fAccelerationRateOriginal;                      		// 0x1C70 (0x0004) [0x0000000000000000]              
	float                                              m_fFrictionOriginal;                              		// 0x1C74 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_ConstrictedYawOffsetDirection;                  		// 0x1C78 (0x0001) [0x0000000000000000]              
	float                                              m_fPreviousYaw;                                   		// 0x1C7C (0x0004) [0x0000000000000000]              
	float                                              m_fRotationTreadSpeedModifier;                    		// 0x1C80 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1512 ];

		return pClassPointer;
	};

	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
	bool eventPostPawnSetup ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_Marauder::pClassPointer = NULL;

// Class TgGame.TgPawn_RecursiveSpawner
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_RecursiveSpawner : public ATgPawn_Boss
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1513 ];

		return pClassPointer;
	};

	bool eventPostPawnSetup ( );
	void OnPetSpawned ( class ATgPawn* Pet );
	void InitSpawnPets ( int SpawnTableID );
};

UClass* ATgPawn_RecursiveSpawner::pClassPointer = NULL;

// Class TgGame.TgPawn_Interact_NPC
// 0x0004 (0x1C34 - 0x1C30)
class ATgPawn_Interact_NPC : public ATgPawn_Character
{
public:
	class ATgCollisionProxy*                           m_CollisionProxy;                                 		// 0x1C30 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1514 ];

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventDestroyed ( );
	void PostBeginPlay ( );
};

UClass* ATgPawn_Interact_NPC::pClassPointer = NULL;

// Class TgGame.TgPawn_NPC
// 0x0000 (0x1C30 - 0x1C30)
class ATgPawn_NPC : public ATgPawn_Character
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1515 ];

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
};

UClass* ATgPawn_NPC::pClassPointer = NULL;

// Class TgGame.TgPawn_Sniper
// 0x000C (0x1C3C - 0x1C30)
class ATgPawn_Sniper : public ATgPawn_Character
{
public:
	class UTgSpecialFx*                                c_BeamFX;                                         		// 0x1C30 (0x0004) [0x0000000000000000]              
	class UTgAnimBlendByPosture*                       c_BlendByPostureAnimNode;                         		// 0x1C34 (0x0004) [0x0000000000000000]              
	float                                              c_ReloadTimeRemaining;                            		// 0x1C38 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1516 ];

		return pClassPointer;
	};

	void OnDeviceFormFire ( int nEquipSlot );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventTornOff ( );
	void UpdateTargetingBeam ( );
};

UClass* ATgPawn_Sniper::pClassPointer = NULL;

// Class TgGame.TgPawn_SonoranCommander
// 0x0008 (0x1C38 - 0x1C30)
class ATgPawn_SonoranCommander : public ATgPawn_Character
{
public:
	class UTgAnimNodeBlendList*                        m_WarCryPointBlendList;                           		// 0x1C30 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_WarCryPointAnimSeqNode;                         		// 0x1C34 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1517 ];

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventReplicatedEvent ( struct FName VarName );
	void PlayFullBodyAnim ( struct FName AnimName, float Rate, float BlendInTime, float BlendOutTime, unsigned long bLooping, unsigned long bOverride, unsigned long bDisablePlayerControls, unsigned long bBlendOutIfVelocityIsGreaterThanZero, unsigned long bHideInHandDevice );
};

UClass* ATgPawn_SonoranCommander::pClassPointer = NULL;

// Class TgGame.TgPawn_Turret
// 0x0048 (0x1C78 - 0x1C30)
class ATgPawn_Turret : public ATgPawn_Character
{
public:
	class USkelControlSingleBone*                      m_LookAtSkelControl;                              		// 0x1C30 (0x0004) [0x0000000000000000]              
	float                                              m_fDeployAnimLength;                              		// 0x1C34 (0x0004) [0x0000000000000000]              
	float                                              c_fImpulseStrength;                               		// 0x1C38 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fImpulseRadius;                                 		// 0x1C3C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fDefaultDeployAnimLength;                       		// 0x1C40 (0x0004) [0x0000000000000000]              
	float                                              r_fInitDeployTime;                                		// 0x1C44 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fTimeToDeploySecs;                              		// 0x1C48 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fCurrentDeployPercentage;                       		// 0x1C4C (0x0004) [0x0000000000000000]              
	float                                              r_fCurrentDeployTime;                             		// 0x1C50 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bIsDeployed : 1;                                		// 0x1C54 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      s_bWasPickedUp : 1;                               		// 0x1C54 (0x0004) [0x0000000000000000] [0x00000002] 
	float                                              m_fLastDeployedHealth;                            		// 0x1C58 (0x0004) [0x0000000000000000]              
	float                                              r_fDeployMaxHealthPCT;                            		// 0x1C5C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              m_fDamagedDuringDeploy;                           		// 0x1C60 (0x0004) [0x0000000000000000]              
	int                                                m_nPickupDeviceId;                                		// 0x1C64 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_BeamFX;                                         		// 0x1C68 (0x0004) [0x0000000000000000]              
	class UTgAnimBlendByPosture*                       c_BlendByPostureAnimNode;                         		// 0x1C6C (0x0004) [0x0000000000000000]              
	int                                                c_CheaperDeployedMaterialFriendlyID;              		// 0x1C70 (0x0004) [0x0000000000000000]              
	int                                                c_CheaperDeployedMaterialEnemyID;                 		// 0x1C74 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1518 ];

		return pClassPointer;
	};

	float GetSaveHealthPercent ( );
	bool PickUpBot ( class ATgPawn* pReceiver );
	bool CanBePickedUp ( );
	void eventOnPawnInitialized ( );
	bool CanPickupDroppedItem ( );
	void PlayDyingPhysicsAndAnimation ( class UClass* TgDmgType, struct FVector HitLoc );
	bool SupportDistanceRendering ( );
	void TickDeploy ( float DeltaSeconds );
	float ExtractDeployTimeFromMyAnimation ( );
	void CalcDeployPercentage ( );
	void DeployComplete ( );
	void StartDeploy ( );
	void UpdateTimeToDeploySecs ( float fValue );
	struct FVector eventGetWeaponStartTraceLocation ( class ATgDevice* Dev );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventEnableFootControls ( int foot, unsigned long bDisable );
	void eventReplicatedEvent ( struct FName VarName );
	void eventSetPosture ( int ePosture, float fRateScale, unsigned long bIgnoreTransition );
	void OnWaitingForPawnDone ( );
	void SetDeployStateBasedOnPosture ( );
	bool CanBeRepaired ( );
	bool eventPostPawnSetup ( );
	void eventPoke ( unsigned char byHitType, unsigned char byHitMagnitude, struct FVector HitLocation, struct FVector RayDirection );
	void eventTornOff ( );
	void UpdateTargetingBeam ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn );
	void SetInitialHealthPercent ( float fPercent );
	void SetHexItem ( class UTgHexItemInstance* newHexItem );
};

UClass* ATgPawn_Turret::pClassPointer = NULL;

// Class TgGame.TgPawn_TurretAVAFlak
// 0x0020 (0x1C98 - 0x1C78)
class ATgPawn_TurretAVAFlak : public ATgPawn_Turret
{
public:
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControl_TL;                       		// 0x1C78 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControl_TR;                       		// 0x1C7C (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControl_BL;                       		// 0x1C80 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControl_BR;                       		// 0x1C84 (0x0004) [0x0000000000000000]              
	class UGameSkelCtrl_Recoil*                        m_RecoilTopSkelControl;                           		// 0x1C88 (0x0004) [0x0000000000000000]              
	class UGameSkelCtrl_Recoil*                        m_RecoilBottomSkelControl;                        		// 0x1C8C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsFiring : 1;                                  		// 0x1C90 (0x0004) [0x0000000000000000] [0x00000001] 
	class USkelControlSingleBone*                      m_RotationControl;                                		// 0x1C94 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1519 ];

		return pClassPointer;
	};

	void StopGunRecoil ( );
	void PlayGunRecoil ( );
	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn );
};

UClass* ATgPawn_TurretAVAFlak::pClassPointer = NULL;

// Class TgGame.TgPawn_TurretAVARocket
// 0x000C (0x1C84 - 0x1C78)
class ATgPawn_TurretAVARocket : public ATgPawn_Turret
{
public:
	class UGameSkelCtrl_Recoil*                        m_RecoilTopSkelControl;                           		// 0x1C78 (0x0004) [0x0000000000000000]              
	class UGameSkelCtrl_Recoil*                        m_RecoilBottomSkelControl;                        		// 0x1C7C (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_RotationControl;                                		// 0x1C80 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1520 ];

		return pClassPointer;
	};

	void OnDeviceFormFire ( int nEquipSlot );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn );
};

UClass* ATgPawn_TurretAVARocket::pClassPointer = NULL;

// Class TgGame.TgPawn_Hover
// 0x0014 (0x1640 - 0x162C)
class ATgPawn_Hover : public ATgPawn
{
public:
	class UAnimNodePlayCustomAnim*                     m_CustomHitWallNode;                              		// 0x162C (0x0004) [0x0000000000000000]              
	TArray< class UTgAnimSequenceChain* >              m_SequenceChainNodes;                             		// 0x1630 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UAudioComponent*                             m_EngineSound;                                    		// 0x163C (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1521 ];

		return pClassPointer;
	};

	struct FVector GetWeaponStartTraceLocation ( class ATgDevice* Dev );
	void eventDestroyed ( );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void SetMovementPhysics ( );
	void eventPlayHitReaction ( struct FVector Direction );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void Tick ( float DeltaSeconds );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
	void UpdateTargetCylinderLocation ( float DeltaSeconds );
	bool InitializeHoverBot ( );
};

UClass* ATgPawn_Hover::pClassPointer = NULL;

// Class TgGame.TgPawn_NewWasp
// 0x0000 (0x1640 - 0x1640)
class ATgPawn_NewWasp : public ATgPawn_Hover
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1522 ];

		return pClassPointer;
	};

	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void SetMovementPhysics ( );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void Tick ( float DeltaSeconds );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
	bool InitializeHoverBot ( );
};

UClass* ATgPawn_NewWasp::pClassPointer = NULL;

// Class TgGame.TgPawn_WaspSpawner
// 0x0000 (0x1640 - 0x1640)
class ATgPawn_WaspSpawner : public ATgPawn_Hover
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1523 ];

		return pClassPointer;
	};

	bool eventPostPawnSetup ( );
	void OnPetSpawned ( class ATgPawn* Pet );
	void InitSpawnPets ( int SpawnTableID );
};

UClass* ATgPawn_WaspSpawner::pClassPointer = NULL;

// Class TgGame.TgPawn_Robot
// 0x000C (0x1638 - 0x162C)
class ATgPawn_Robot : public ATgPawn
{
public:
	unsigned long                                      m_bUseFootControlsThisTick : 1;                   		// 0x162C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              c_fImpulseStrength;                               		// 0x1630 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fImpulseRadius;                                 		// 0x1634 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1524 ];

		return pClassPointer;
	};

	void PlayDyingPhysicsAndAnimation ( class UClass* TgDmgType, struct FVector HitLoc );
	struct FVector eventGetWeaponStartTraceLocation ( class ATgDevice* Dev );
	bool CanTrackATarget ( );
	void DoFootPlacement ( );
	void eventUpdateMeshBoneControllers ( float DeltaTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_Robot::pClassPointer = NULL;

// Class TgGame.TgPawn_Ambush
// 0x000C (0x1644 - 0x1638)
class ATgPawn_Ambush : public ATgPawn_Robot
{
public:
	unsigned long                                      r_bIsDeployed : 1;                                		// 0x1638 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	float                                              m_fHibernateFXDelay;                              		// 0x163C (0x0004) [0x0000000000000000]              
	float                                              m_fDeployStateChangeDelay;                        		// 0x1640 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1525 ];

		return pClassPointer;
	};

	void OnDeviceFormFire ( int nEquipSlot );
	void PlayGoBackInGroundEffects ( );
	void PlayAmbushEffects ( );
	void BackInGround ( );
	void SetDeployed ( );
	void ServerSetDeployed ( );
	void eventSetPosture ( int ePosture, float fRateScale, unsigned long bIgnoreTransition );
	void PostBeginPlay ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool ShouldUpdateStealthedFor ( class ATgPawn* ViewerPawn );
};

UClass* ATgPawn_Ambush::pClassPointer = NULL;

// Class TgGame.TgPawn_Tentacle
// 0x0000 (0x1644 - 0x1644)
class ATgPawn_Tentacle : public ATgPawn_Ambush
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1526 ];

		return pClassPointer;
	};

};

UClass* ATgPawn_Tentacle::pClassPointer = NULL;

// Class TgGame.TgPawn_CTR
// 0x046C (0x1AA4 - 0x1638)
class ATgPawn_CTR : public ATgPawn_Robot
{
public:
	class UTgSkeletalMeshComponent*                    m_PilotSuitMeshComponent;                         		// 0x1638 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_PilotHeadMeshComponent;                         		// 0x163C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_PilotHelmetMeshComponent;                       		// 0x1640 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgStaticMeshComponent*                      m_PilotHairMeshComponent;                         		// 0x1644 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ATgPawn_Character*                           r_PilotPawn;                                      		// 0x1648 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class UTgSpecialFx*                                c_InteractionScreenSFX;                           		// 0x164C (0x0004) [0x0000000000000000]              
	struct FCustomCharacterAssembly                    r_CustomCharacterAssembly;                        		// 0x1650 (0x0044) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMorphSettings[ 0xFF ];                         		// 0x1694 (0x03FC) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMaxMorphIndexSentFromServer;                   		// 0x1A90 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      m_bIsImmune : 1;                                  		// 0x1A94 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bHasBeenCrewed : 1;                               		// 0x1A94 (0x0004) [0x0000000000000000] [0x00000002] 
	class UAnimNodePlayCustomAnim*                     m_RangeMeleeTransitionBlendNode;                  		// 0x1A98 (0x0004) [0x0000000000000000]              
	class UAnimNodeBlend*                              m_JetBlendNode;                                   		// 0x1A9C (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActor_CharacterBuilderSpawnable* PilotMeshActor;                                   		// 0x1AA0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1527 ];

		return pClassPointer;
	};

	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
	int eventGetGenderTypeCode ( );
	void SetDeviceTypeAnim ( int NewActiveChild, float BlendTime );
	void UpdatePilot ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventDestroyed ( );
	void PlayUncrewedAnim ( );
	void PlayPowerUpAnim ( );
	bool eventPostPawnSetup ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventHackedBy ( class ATgPawn* ControlPawn );
	void BuildPilot ( );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn );
	void UnCrewed ( unsigned long bKillControlPawn );
};

UClass* ATgPawn_CTR::pClassPointer = NULL;

// Class TgGame.TgPawn_Scanner
// 0x008C (0x16C4 - 0x1638)
class ATgPawn_Scanner : public ATgPawn_Robot
{
public:
	unsigned long                                      m_bIsSensorSweeping : 1;                          		// 0x1638 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      c_bHighlightDirectionUp : 1;                      		// 0x1638 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bEnemyDetected : 1;                             		// 0x1638 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bAlarmOnTakeDamage : 1;                         		// 0x1638 (0x0004) [0x0000000000000000] [0x00000008] 
	int                                                m_nNumSensorBeams;                                		// 0x163C (0x0004) [0x0000000000000000]              
	float                                              m_fSensorAngle;                                   		// 0x1640 (0x0004) [0x0000000000000000]              
	float                                              m_fSensorRange;                                   		// 0x1644 (0x0004) [0x0000000000000000]              
	TArray< class UTgSpecialFx* >                      c_TargetingBeams;                                 		// 0x1648 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	float                                              c_fBeamHighlightRate;                             		// 0x1654 (0x0004) [0x0000000000000000]              
	float                                              c_fTimeSinceLastHighlightUpdate;                  		// 0x1658 (0x0004) [0x0000000000000000]              
	int                                                c_nHighlightedBeamIndex;                          		// 0x165C (0x0004) [0x0000000000000000]              
	struct FVector                                     c_vBeamColorEdge;                                 		// 0x1660 (0x000C) [0x0000000000000000]              
	struct FVector                                     c_vBeamColorHighlight;                            		// 0x166C (0x000C) [0x0000000000000000]              
	struct FVector                                     c_vBeamColorStandard;                             		// 0x1678 (0x000C) [0x0000000000000000]              
	class ATgSkeletalMeshActorSpawnable*               c_HighlightBeamEndActor;                          		// 0x1684 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                c_HighlightBeamEndSFX;                            		// 0x1688 (0x0004) [0x0000000000000000]              
	class USpotLightComponent*                         c_AlarmLight;                                     		// 0x168C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FColor                                      c_LightColor;                                     		// 0x1690 (0x0004) [0x0000000000000000]              
	float                                              c_fLightBrightness;                               		// 0x1694 (0x0004) [0x0000000000000000]              
	class ULensFlareComponent*                         c_LensFlareLeft;                                  		// 0x1698 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class ULensFlareComponent*                         c_LensFlareRight;                                 		// 0x169C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UStaticMeshComponent*                        c_LightConeSMC;                                   		// 0x16A0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSkelCon_SpinControl*                      m_ScannerSpinControl;                             		// 0x16A4 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      c_ScannerRotateLock;                              		// 0x16A8 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_LookAt*                           c_FullBodyLookAt;                                 		// 0x16AC (0x0004) [0x0000000000000000]              
	class UTgSkelCon_LookAt*                           c_LeftEyeLookAtControl;                           		// 0x16B0 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_LookAt*                           c_RightEyeLookAtControl;                          		// 0x16B4 (0x0004) [0x0000000000000000]              
	float                                              m_fScanSpeed;                                     		// 0x16B8 (0x0004) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_MIC;                                            		// 0x16BC (0x0004) [0x0000000000000000]              
	float                                              s_fTimePostDetectionToKeepScanning;               		// 0x16C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1528 ];

		return pClassPointer;
	};

	void SetPhysAnimState ( unsigned char NewState );
	void eventTakeDamage ( int Damage, class AController* InstigatedBy, struct FVector HitLocation, struct FVector Momentum, class UClass* DamageType, struct FTraceHitInfo HitInfo, class AActor* DamageCauser );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	bool eventPostPawnSetup ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void eventOnPhaseChange ( );
	void eventOnPhaseEnded ( int nPhaseThatEnded );
	void OnPhaseTransitionComplete ( );
	void ConstructSensorBeamFX ( );
	void eventDoClientSideAlarmEffects ( );
	void DestroyHighlightBeamActor ( );
	void eventSensorSweepComplete ( );
	void DoSensorSweep ( );
	void DoAlarm ( );
	void EnemyDetectedTimer ( );
	bool DidSensorBeamDetectEnemy ( class AActor* HitActor );
	void UpdateBeamVisualHighlightIndex ( float DeltaSeconds );
	void UpdateSensorSweep ( float DeltaSeconds );
	void PatrolComplete ( );
	void DoPatrol ( );
	void PowerRechargeComplete ( );
	void DoPowerRecharge ( );
	void AlarmComplete ( );
};

UClass* ATgPawn_Scanner::pClassPointer = NULL;

// Class TgGame.TgPawn_Siege
// 0x0034 (0x166C - 0x1638)
class ATgPawn_Siege : public ATgPawn_Robot
{
public:
	TArray< class UGameSkelCtrl_Recoil* >              c_RecoilSkelControls;                             		// 0x1638 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                c_RecoilDeviceSlot;                               		// 0x1644 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeAimOffset*                        c_AimOffset;                                      		// 0x1648 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendList*                        c_BackJetFlareList;                               		// 0x164C (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      c_BankFSkelControl;                               		// 0x1650 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      c_BankBSkelControl;                               		// 0x1654 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      c_BankLSkelControl;                               		// 0x1658 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      c_BankRSkelControl;                               		// 0x165C (0x0004) [0x0000000000000000]              
	unsigned char                                      r_AccelDirection;                                 		// 0x1660 (0x0001) [0x0000000000000020]              ( CPF_Net )
	struct FName                                       c_AimOffsetProfileName;                           		// 0x1664 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1529 ];

		return pClassPointer;
	};

	bool DoJump ( unsigned long bUpdating );
	struct FVector eventGetWeaponStartTraceLocation ( class ATgDevice* Dev );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	struct FTgCameraValues eventGetCameraValues ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void eventReplicatedEvent ( struct FName VarName );
	bool eventPostPawnSetup ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void RecalculateMaterial ( unsigned long bIsFriendlyWithLocalPawn );
	void BlendBackJetFlares ( );
};

UClass* ATgPawn_Siege::pClassPointer = NULL;

// Class TgGame.TgPawn_TreadRobot
// 0x0020 (0x1658 - 0x1638)
class ATgPawn_TreadRobot : public ATgPawn_Robot
{
public:
	class UMaterialInstanceConstant*                   m_TreadMaterialInstance;                          		// 0x1638 (0x0004) [0x0000000000000000]              
	float                                              m_TreadSpeedModifier;                             		// 0x163C (0x0004) [0x0000000000000000]              
	float                                              m_LeftTreadSpeed;                                 		// 0x1640 (0x0004) [0x0000000000000000]              
	float                                              m_RightTreadSpeed;                                		// 0x1644 (0x0004) [0x0000000000000000]              
	struct FName                                       m_LeftTreadScalarName;                            		// 0x1648 (0x0008) [0x0000000000000000]              
	struct FName                                       m_RightTreadScalarName;                           		// 0x1650 (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1530 ];

		return pClassPointer;
	};

	void eventPoke ( unsigned char byHitType, unsigned char byHitMagnitude, struct FVector HitLocation, struct FVector RayDirection );
	void Tick ( float DeltaSeconds );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_TreadRobot::pClassPointer = NULL;

// Class TgGame.TgPawn_Widow
// 0x0008 (0x1640 - 0x1638)
class ATgPawn_Widow : public ATgPawn_Robot
{
public:
	class ATgCollisionProxy_Vortex*                    m_Vortex;                                         		// 0x1638 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_WidowVortexSFX;                                 		// 0x163C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1531 ];

		return pClassPointer;
	};

	void OnDeviceFormFire ( int nEquipSlot );
	void EndVortex ( );
	void StartVortex ( );
	void eventOnPhaseChange ( );
	void ClientSetStun ( );
	void Stun ( unsigned long bStunController, unsigned char eType );
	void PlayDying ( class UClass* dmgType, struct FVector HitLoc );
	void OnPhaseTransitionComplete ( );
	void PostBeginPlay ( );
	void eventReplicatedEvent ( struct FName VarName );
	void eventTornOff ( );
	void UpdateTargetingBeam ( );
};

UClass* ATgPawn_Widow::pClassPointer = NULL;

// Class TgGame.TgPawn_VanityPet
// 0x0004 (0x1630 - 0x162C)
class ATgPawn_VanityPet : public ATgPawn
{
public:
	int                                                r_nSpawningItemId;                                		// 0x162C (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1532 ];

		return pClassPointer;
	};

	void eventDestroyed ( );
	int eventGetBodyMeshId ( );
	void eventOnSpawningItemChanged ( );
	void ReplicatedEvent ( struct FName VarName );
	void OnAnimNodeChildChanged ( class UAnimNode* Node, int OldChild, int NewChild );
	bool IsNonCombat ( );
	int GetBodyMeshIdToUse ( );
	bool ShouldPawnMeshBeHiddenThisTick ( );
	void AllManifestsLoaded ( );
};

UClass* ATgPawn_VanityPet::pClassPointer = NULL;

// Class TgGame.TgPlayerController
// 0x0360 (0x0920 - 0x05C0)
class ATgPlayerController : public AGamePlayerController
{
public:
	unsigned long                                      bNoVoiceMessages : 1;                             		// 0x05C0 (0x0004) [0x0000000000044000] [0x00000001] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bNoVoiceTaunts : 1;                               		// 0x05C0 (0x0004) [0x0000000000044000] [0x00000002] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bNoAutoTaunts : 1;                                		// 0x05C0 (0x0004) [0x0000000000044000] [0x00000004] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bLookUpStairs : 1;                                		// 0x05C0 (0x0004) [0x0000000000044000] [0x00000008] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bSnapToLevel : 1;                                 		// 0x05C0 (0x0004) [0x0000000000044000] [0x00000010] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bAlwaysMouseLook : 1;                             		// 0x05C0 (0x0004) [0x0000000000044000] [0x00000020] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bKeyboardLook : 1;                                		// 0x05C0 (0x0004) [0x0000000000044000] [0x00000040] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      bAlwaysLevel : 1;                                 		// 0x05C0 (0x0004) [0x0000000000044000] [0x00000080] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      s_bSetHomeCalled : 1;                             		// 0x05C0 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bAcuteHearing : 1;                              		// 0x05C0 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      c_bShowZoom : 1;                                  		// 0x05C0 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bWantQuickMelee : 1;                            		// 0x05C0 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      c_queuedUpWeaponExists : 1;                       		// 0x05C0 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      c_bFloatCamera : 1;                               		// 0x05C0 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      c_bSensorView : 1;                                		// 0x05C0 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      c_ReleaseHUDShown : 1;                            		// 0x05C0 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      m_bInitiatedJetting : 1;                          		// 0x05C0 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_JetpackInitSwitch : 1;                          		// 0x05C0 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_bWasDucking : 1;                                		// 0x05C0 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      r_bLockYawRotation : 1;                           		// 0x05C0 (0x0004) [0x0000000000000020] [0x00080000] ( CPF_Net )
	unsigned long                                      r_bRove : 1;                                      		// 0x05C0 (0x0004) [0x0000000000000020] [0x00100000] ( CPF_Net )
	unsigned long                                      c_bDeathZoom : 1;                                 		// 0x05C0 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      c_bDeathZoomComplete : 1;                         		// 0x05C0 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      c_bEnableShiftingReticule : 1;                    		// 0x05C0 (0x0004) [0x0000000000044000] [0x00800000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      c_bDeviceSCTOption : 1;                           		// 0x05C0 (0x0004) [0x0000000000044000] [0x01000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      c_bReticleTargetHealthOption : 1;                 		// 0x05C0 (0x0004) [0x0000000000000000] [0x02000000] 
	unsigned long                                      c_bEnableFullHelpAlerts : 1;                      		// 0x05C0 (0x0004) [0x0000000000044000] [0x04000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      c_bDisableAllPlayerIcons : 1;                     		// 0x05C0 (0x0004) [0x0000000000044000] [0x08000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      c_bShowEnemyPlayerIconsOnly : 1;                  		// 0x05C0 (0x0004) [0x0000000000044000] [0x10000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      m_bReticuleTargetDisplayed : 1;                   		// 0x05C0 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      c_bLateBackfills : 1;                             		// 0x05C0 (0x0004) [0x0000000000044000] [0x40000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      c_bLocalOnlyQueue : 1;                            		// 0x05C0 (0x0004) [0x0000000000044000] [0x80000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      c_bJoinAvATeams : 1;                              		// 0x05C4 (0x0004) [0x0000000000044000] [0x00000001] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      r_bEDDebugEffects : 1;                            		// 0x05C4 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      m_bMinimapDisplayed : 1;                          		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      c_bShowBotAIDebug : 1;                            		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bShowFootstepInfoDebug : 1;                     		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bShowConeAttackDebug : 1;                       		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bDetailedDeviceLogging : 1;                     		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      c_bReadyToPlay : 1;                               		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      c_bCheatSeeStealthedPlayers : 1;                  		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      s_bForcePawnDeath : 1;                            		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      c_bDefaultMelee : 1;                              		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bShowTeammateStat : 1;                          		// 0x05C4 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      c_bShowLastAimedEnemyStat : 1;                    		// 0x05C4 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      s_bRefreshRandomSMSettings : 1;                   		// 0x05C4 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      r_bGMInvisible : 1;                               		// 0x05C4 (0x0004) [0x0000000000000020] [0x00004000] ( CPF_Net )
	unsigned long                                      c_bInTagPlayerMode : 1;                           		// 0x05C4 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      c_bCanHangDismount : 1;                           		// 0x05C4 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      r_bIsHackingABot : 1;                             		// 0x05C4 (0x0004) [0x0000000000000020] [0x00020000] ( CPF_Net )
	unsigned long                                      c_bRaidComplete : 1;                              		// 0x05C4 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      s_bSentAutoKickAlert : 1;                         		// 0x05C4 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      m_bForceUseCachedView : 1;                        		// 0x05C4 (0x0004) [0x0000000000000000] [0x00100000] 
	unsigned long                                      c_bTrainingMissionComplete : 1;                   		// 0x05C4 (0x0004) [0x0000000000000000] [0x00200000] 
	unsigned long                                      c_bServerRequestsEquipScreenUpdate : 1;           		// 0x05C4 (0x0004) [0x0000000000000000] [0x00400000] 
	unsigned long                                      c_bTestMatString : 1;                             		// 0x05C4 (0x0004) [0x0000000000000000] [0x00800000] 
	unsigned long                                      c_bTeamVoiceDisabled : 1;                         		// 0x05C4 (0x0004) [0x0000000000044000] [0x01000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      c_bInstanceVoiceDisabled : 1;                     		// 0x05C4 (0x0004) [0x0000000000044000] [0x02000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      c_bVoipDisabled : 1;                              		// 0x05C4 (0x0004) [0x0000000000044000] [0x04000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      c_bAudioDisabled : 1;                             		// 0x05C4 (0x0004) [0x0000000000044000] [0x08000000] ( CPF_Config | CPF_GlobalConfig )
	unsigned long                                      m_bSelfFxOnly : 1;                                		// 0x05C4 (0x0004) [0x0000000000000000] [0x10000000] 
	unsigned long                                      m_bMissileOptimization : 1;                       		// 0x05C4 (0x0004) [0x0000000000000000] [0x20000000] 
	unsigned long                                      bPressingRightMouseButton : 1;                    		// 0x05C4 (0x0004) [0x0000000000000000] [0x40000000] 
	unsigned long                                      bPressingLeftMouseButton : 1;                     		// 0x05C4 (0x0004) [0x0000000000000000] [0x80000000] 
	unsigned long                                      c_bDeathScreenshotEnabled : 1;                    		// 0x05C8 (0x0004) [0x0000000000004000] [0x00000001] ( CPF_Config )
	unsigned long                                      c_bFreeCam : 1;                                   		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bFreezePawnReplication : 1;                     		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      s_bInTransaction : 1;                             		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      c_bEchoVoiceOn : 1;                               		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      c_bCachedShiftReticule : 1;                       		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bNewsStandFound : 1;                            		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      m_bLastNewsChannelUpdateInRange : 1;              		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bNewsSpeaking : 1;                              		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      m_bMasterSoundFadeIn : 1;                         		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bHasNotifiedQuestsReady : 1;                    		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      c_bPerfBackpack : 1;                              		// 0x05C8 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      c_bPerfHelmet : 1;                                		// 0x05C8 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      c_bPerfHair : 1;                                  		// 0x05C8 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      c_bPerfHead : 1;                                  		// 0x05C8 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      c_bPerfEnabled : 1;                               		// 0x05C8 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      c_bDisablePawnPostRender : 1;                     		// 0x05C8 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      c_bDisableScaledString : 1;                       		// 0x05C8 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      c_bViewingQuestGiverCamera : 1;                   		// 0x05C8 (0x0004) [0x0000000000000000] [0x00040000] 
	int                                                s_nCharacterId;                                   		// 0x05CC (0x0004) [0x0000000000000000]              
	int                                                s_nPlayerId;                                      		// 0x05D0 (0x0004) [0x0000000000000000]              
	struct FQWord                                      s_qwNetAccessFlags;                               		// 0x05D4 (0x0008) [0x0000000000000000]              
	class AActor*                                      m_aHoverActor;                                    		// 0x05DC (0x0004) [0x0000000000000000]              
	class AActor*                                      m_aHoverActorNoDevice;                            		// 0x05E0 (0x0004) [0x0000000000000000]              
	struct FRotator                                    m_rBlendedTargetViewRotation;                     		// 0x05E4 (0x000C) [0x0000000000000000]              
	class ATgAnnouncer*                                m_Announcer;                                      		// 0x05F0 (0x0004) [0x0000000000000000]              
	float                                              m_fLastTauntAnimTime;                             		// 0x05F4 (0x0004) [0x0000000000000000]              
	float                                              m_fLastCrewBotTime;                               		// 0x05F8 (0x0004) [0x0000000000000000]              
	struct FString                                     m_MsgPlayerNotFound;                              		// 0x05FC (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	struct FVector                                     m_vMouseHoverLocation;                            		// 0x0608 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vMouseHitNormal;                                		// 0x0614 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vTargetHitLocation;                             		// 0x0620 (0x000C) [0x0000000000000000]              
	int                                                c_queuedUpWeaponSlot;                             		// 0x062C (0x0004) [0x0000000000000000]              
	float                                              c_fCrouchBlendInterpRate;                         		// 0x0630 (0x0004) [0x0000000000000000]              
	float                                              c_nNameScale;                                     		// 0x0634 (0x0004) [0x0000000000000000]              
	class AActor*                                      c_CommandTarget;                                  		// 0x0638 (0x0004) [0x0000000000000000]              
	int                                                c_nCommandType;                                   		// 0x063C (0x0004) [0x0000000000000000]              
	struct FVector                                     c_vCommandDestination;                            		// 0x0640 (0x000C) [0x0000000000000000]              
	class ATgTeamMarker*                               c_CommandMarker;                                  		// 0x064C (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingInitiatingJettingTime;                		// 0x0650 (0x0004) [0x0000000000000000]              
	float                                              m_fJetpackInitAccelMultiplier;                    		// 0x0654 (0x0004) [0x0000000000000000]              
	float                                              m_fJetpackInitTotalTime;                          		// 0x0658 (0x0004) [0x0000000000000000]              
	struct FVector                                     s_lastLookDirection;                              		// 0x065C (0x000C) [0x0000000000000000]              
	float                                              s_leakyVelocityAvg;                               		// 0x0668 (0x0004) [0x0000000000000000]              
	struct FViewShakeInfo                              m_CurrentViewShake;                               		// 0x066C (0x0038) [0x0000000000000000]              
	struct FViewShakeInfo                              m_BaseDamageShake;                                		// 0x06A4 (0x0038) [0x0000000000000000]              
	struct FViewShakeInfo                              m_SkyDiveShake;                                   		// 0x06DC (0x0038) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_vShakeOffset;                                   		// 0x0714 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rShakeRot;                                      		// 0x0720 (0x000C) [0x0000000000000000]              
	float                                              m_fLastCameraTimeStamp;                           		// 0x072C (0x0004) [0x0000000000000000]              
	class UClass*                                      m_MatineeCameraClass;                             		// 0x0730 (0x0004) [0x0000000000000000]              
	class ATgHitDisplayActor*                          c_HitDisplay;                                     		// 0x0734 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeToViewOthersCamAfterDeath;                 		// 0x0738 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeToWatchSelfDie;                            		// 0x073C (0x0004) [0x0000000000000000]              
	float                                              m_fTimeToWatchKiller;                             		// 0x0740 (0x0004) [0x0000000000000000]              
	float                                              m_fCurrentWatchSelfDieTime;                       		// 0x0744 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeToViewKillerAfterDeath;                    		// 0x0748 (0x0004) [0x0000000000000000]              
	class AActor*                                      m_aCalcViewActor;                                 		// 0x074C (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vCalcViewActorLocation;                         		// 0x0750 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vCalcViewLocation;                              		// 0x075C (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rCalcViewRotation;                              		// 0x0768 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_vKillerCamLocation;                             		// 0x0774 (0x000C) [0x0000000000000000]              
	struct FRotator                                    m_rKillerCamRotation;                             		// 0x0780 (0x000C) [0x0000000000000000]              
	struct FVector                                     c_DistanceToDebugCam;                             		// 0x078C (0x000C) [0x0000000000000000]              
	float                                              m_fKillerCamInterpSpeed;                          		// 0x0798 (0x0004) [0x0000000000000000]              
	struct FVector                                     m_vPlrRelativeCameraLocation;                     		// 0x079C (0x000C) [0x0000000000000000]              
	float                                              m_fPrevTargetShockAbsorberHeight;                 		// 0x07A8 (0x0004) [0x0000000000000000]              
	float                                              m_fPrevCameraHeight;                              		// 0x07AC (0x0004) [0x0000000000000000]              
	int                                                c_nCameraYawOffset;                               		// 0x07B0 (0x0004) [0x0000000000000000]              
	int                                                c_nCameraPitchOffset;                             		// 0x07B4 (0x0004) [0x0000000000000000]              
	int                                                c_nCameraForce;                                   		// 0x07B8 (0x0004) [0x0000000000000000]              
	float                                              c_fCameraDesiredScale;                            		// 0x07BC (0x0004) [0x0000000000000000]              
	float                                              c_fCameraSavedScale;                              		// 0x07C0 (0x0004) [0x0000000000000000]              
	struct FVector                                     c_vCameraScaleRange;                              		// 0x07C4 (0x000C) [0x0000000000000000]              
	float                                              c_fCameraHeightOffset;                            		// 0x07D0 (0x0004) [0x0000000000000000]              
	float                                              m_fCameraShockAbsorberStrength;                   		// 0x07D4 (0x0004) [0x0000000000000000]              
	float                                              c_FreeCamYawOffset;                               		// 0x07D8 (0x0004) [0x0000000000000000]              
	float                                              c_FreeCamPitchOffset;                             		// 0x07DC (0x0004) [0x0000000000000000]              
	unsigned char                                      r_WatchOtherPlayer;                               		// 0x07E0 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      DoubleClickDir_CtrlRoll;                          		// 0x07E1 (0x0001) [0x0000000000000000]              
	unsigned char                                      s_nDbPostRefCount;                                		// 0x07E2 (0x0001) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	unsigned char                                      c_GameWinState;                                   		// 0x07E3 (0x0001) [0x0000000000000000]              
	unsigned char                                      c_RaidWinState;                                   		// 0x07E4 (0x0001) [0x0000000000000000]              
	int                                                c_TiledShotMultiplier;                            		// 0x07E8 (0x0004) [0x0000000000000000]              
	int                                                c_TiledShotMargin;                                		// 0x07EC (0x0004) [0x0000000000000000]              
	int                                                m_nErezCamOption;                                 		// 0x07F0 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	class ATgEmitterSpawnable*                         c_ReticuleEmitter;                                		// 0x07F4 (0x0004) [0x0000000000000000]              
	struct FVector                                     c_ReticuleEmitterColor;                           		// 0x07F8 (0x000C) [0x0000000000000000]              
	struct FName                                       c_nmReticulePSCTemplate;                          		// 0x0804 (0x0008) [0x0000000000000000]              
	class AActor*                                      m_ReticuleTargetCached;                           		// 0x080C (0x0004) [0x0000000000000000]              
	int                                                c_PreferredRegion;                                		// 0x0810 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	int                                                c_iLockedCount;                                   		// 0x0814 (0x0004) [0x0000000000000000]              
	int                                                c_nCurrentModeIndex;                              		// 0x0818 (0x0004) [0x0000000000000000]              
	struct FName                                       m_nmTemplateName;                                 		// 0x081C (0x0008) [0x0000000000000000]              
	int                                                m_bNextRespawnLength;                             		// 0x0824 (0x0004) [0x0000000000000000]              
	float                                              c_CachedGroundSpeed;                              		// 0x0828 (0x0004) [0x0000000000000000]              
	float                                              c_TurnInterpRate;                                 		// 0x082C (0x0004) [0x0000000000000000]              
	float                                              s_fLastPawnBecomeRelevantTime;                    		// 0x0830 (0x0004) [0x0000000000000000]              
	float                                              m_fPauseTime;                                     		// 0x0834 (0x0004) [0x0000000000000000]              
	int                                                m_aHenchmanId[ 0x2 ];                             		// 0x0838 (0x0008) [0x0000000000000000]              
	struct FPointer                                    s_pTransferRequest;                               		// 0x0840 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FPointer                                    s_pQuestTracker;                                  		// 0x0844 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FPointer                                    s_pAchievementTracker;                            		// 0x0848 (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	struct FPointer                                    s_pGameFacts;                                     		// 0x084C (0x0004) [0x0000000000001002]              ( CPF_Const | CPF_Native )
	class UAudioComponent*                             c_HealthAlertSound;                               		// 0x0850 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             c_PowerAlertSound;                                		// 0x0854 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class USoundCue*                                   c_BeaconAlertSoundCue;                            		// 0x0858 (0x0004) [0x0000000000000000]              
	float                                              c_fTimeTillAFK;                                   		// 0x085C (0x0004) [0x0000000000000000]              
	float                                              s_bAutoKickStartTime;                             		// 0x0860 (0x0004) [0x0000000000000000]              
	class AActor*                                      KillerActor;                                      		// 0x0864 (0x0004) [0x0000000000000000]              
	float                                              c_fCurrentDeathPitchOffsetAmount;                 		// 0x0868 (0x0004) [0x0000000000000000]              
	int                                                m_nDeathCamOption;                                		// 0x086C (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	struct FTG_TRAINING_END_INFO                       m_trainingEndInfo;                                		// 0x0870 (0x0014) [0x0000000000000000]              
	float                                              c_fVoipMicLevel;                                  		// 0x0884 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              c_fVoipSpeakerVolume;                             		// 0x0888 (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	float                                              c_fVoipVADLevel;                                  		// 0x088C (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	struct FString                                     c_sVoipCaptureDevice;                             		// 0x0890 (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	struct FString                                     c_sVoipRenderDevice;                              		// 0x089C (0x000C) [0x0000000000444000]              ( CPF_Config | CPF_GlobalConfig | CPF_NeedCtorLink )
	class UMaterialEffect*                             c_WorldMaterialEffect;                            		// 0x08A8 (0x0004) [0x0000000000000000]              
	class ATgPostProcessVolume*                        c_TgPostProcessVolumeLastTick;                    		// 0x08AC (0x0004) [0x0000000000000000]              
	struct FTgPostProcessTransitionInfo                c_PPTransition;                                   		// 0x08B0 (0x000C) [0x0000000000000000]              
	class ATgPawn*                                     c_DeathScreenshotPawn;                            		// 0x08BC (0x0004) [0x0000000000000000]              
	float                                              m_fCachedFOV;                                     		// 0x08C0 (0x0004) [0x0000000000000000]              
	float                                              m_fLastFOVTimeStamp;                              		// 0x08C4 (0x0004) [0x0000000000000000]              
	float                                              c_fLastShiftReticuleTimeStamp;                    		// 0x08C8 (0x0004) [0x0000000000000000]              
	int                                                c_nDyeColorOption;                                		// 0x08CC (0x0004) [0x0000000000044000]              ( CPF_Config | CPF_GlobalConfig )
	struct FVector                                     m_vLastNewsChannelUpdateLocation;                 		// 0x08D0 (0x000C) [0x0000000000000000]              
	class ATgNewsStand*                                m_NewsStand;                                      		// 0x08DC (0x0004) [0x0000000000000000]              
	float                                              m_fFadeMasterTargetVolume;                        		// 0x08E0 (0x0004) [0x0000000000000000]              
	float                                              m_fFadeTime;                                      		// 0x08E4 (0x0004) [0x0000000000000000]              
	float                                              m_fFadeMasterSoundRemainingTime;                  		// 0x08E8 (0x0004) [0x0000000000000000]              
	TArray< class UTgObjectReferencer* >               c_KismetLoadedDevices;                            		// 0x08EC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                c_nCurrentLevel;                                  		// 0x08F8 (0x0004) [0x0000000000000000]              
	struct FDouble                                     s_dtLastSkillRespecTime;                          		// 0x08FC (0x0008) [0x0000000000000000]              
	float                                              c_PaperDollHeight;                                		// 0x0904 (0x0004) [0x0000000000000000]              
	float                                              c_PaperDollTransX;                                		// 0x0908 (0x0004) [0x0000000000000000]              
	float                                              c_PaperDollTransY;                                		// 0x090C (0x0004) [0x0000000000000000]              
	float                                              c_PaperDollTransZ;                                		// 0x0910 (0x0004) [0x0000000000000000]              
	float                                              c_PaperDollRotX;                                  		// 0x0914 (0x0004) [0x0000000000000000]              
	float                                              c_PaperDollRotY;                                  		// 0x0918 (0x0004) [0x0000000000000000]              
	float                                              c_PaperDollRotZ;                                  		// 0x091C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1533 ];

		return pClassPointer;
	};

	void InspectAgentProfile ( );
	void SetPaperDoll ( float Height, float TransX, float TransY, float TransZ, float RotX, float RotY, float RotZ );
	void TogglePawnPostRenderText ( );
	void TogglePawnPostRender ( );
	void CCTest1 ( unsigned long bUsePAC, unsigned long bLoadAttachments );
	void UpdateCustomChar ( int Torso, int Head, int GlovesR, int GlovesL, int Legs, int BootsR, int BootsL, int ClassSpecific );
	void PawnPerformanceTest ( unsigned long bEnablePerfTest, unsigned long bBackpack, unsigned long bHelmet, unsigned long bHair, unsigned long bHead );
	void Cloth ( unsigned long bEnabled );
	void Wind ( unsigned long bEnabled );
	void DoFade ( unsigned long bIn, float Time );
	void RandomizeMorphs ( );
	void ServerGetTraceTime ( float fRange, unsigned long bStopAtAnyHit );
	void GetTraceTimeCheck ( float fRange, unsigned long bStopAtAnyHit );
	void ServerSimNWCondition ( int nPktLoss, int nPktLag );
	void SimNWCondition ( int nPktLoss, int nPktLag );
	void f2test ( unsigned long val, unsigned long val2 );
	void TgServerExec ( struct FString stringIn );
	void TgSvrExec ( struct FString stringIn );
	void DebugFn ( unsigned long val, unsigned long val2 );
	void OnClientLoadDevices ( class UTgSeqAct_ClientLoadDevices* Action );
	void ClientShowHUDElement ( unsigned char Element );
	void ClientHideHUDElement ( unsigned char Element );
	void OnHideHUDElement ( class UTgSeqAct_HideHUDElement* Action );
	void OnShowHUDElement ( class UTgSeqAct_ShowHUDElement* Action );
	void eventClientSetCameraFade ( unsigned long bEnableFading, struct FColor FadeColor, struct FVector2D FadeAlpha, float FadeTime );
	void ClientSetCameraMode ( struct FName NewCamMode );
	void ServerCamera ( struct FName NewMode );
	void Camera ( struct FName NewMode );
	void DeathScreenshot ( unsigned long bOn );
	void EndDeathScreenshotTimer ( );
	void eventOnEndDeathScreenshot ( );
	void CheatLog ( struct FString cheatText, unsigned long bOn );
	void ClientSetGroundspeed ( float val );
	void eventServerSetGroundspeed ( float val );
	void SetGroundspeed ( float val );
	void ServerChronos ( unsigned long bPause, int nNewTime );
	void Chronos ( unsigned long bPause, int nNewTime );
	void ClientZeus ( unsigned long bOn );
	void ServerZeus ( );
	void Zeus ( );
	void ClientApollo ( unsigned long bOn );
	void ServerApollo ( );
	void Apollo ( );
	void ClientElectra ( unsigned long bOn );
	void ServerElectra ( );
	void Electra ( );
	void ClientHades ( unsigned long bOn );
	void ServerHades ( );
	void Hades ( );
	void ClientCheatFly ( unsigned long bOn );
	void eventCheatFly ( unsigned long bOn );
	void ServerIcarus ( );
	void Icarus ( );
	void ClientAthena ( unsigned long bOn );
	void ServerAthena ( );
	void Athena ( );
	void Prometheus ( );
	void CheatHelp ( );
	void Pause ( );
	void OnQuestRequirementGetStatus ( class UTgSeqAct_QuestRequirementGetStatus* Action );
	void OnQuestGetStatus ( class UTgSeqAct_QuestGetStatus* Action );
	void OnQuestIncrementReqCount ( class UTgSeqAct_QuestIncrementReqCount* Action );
	void NativeQuestIncrementRequirementCount ( class UTgSeqAct_QuestIncrementReqCount* Action );
	void NativeQuestRequirementGetStatus ( class UTgSeqAct_QuestRequirementGetStatus* Action );
	void NativeQuestGetStatus ( class UTgSeqAct_QuestGetStatus* Action );
	void NotifyPlayerQuestStateReady ( );
	void eventServerUpdateStats ( );
	bool CanCommunicate ( );
	void SpeakTTS ( struct FString S, class APlayerReplicationInfo* PRI );
	void DisableTextToSpeech ( );
	void EnableTextToSpeech ( );
	void ToggleHudTick ( );
	void ToggleHudPostRender ( );
	void ToggleLevelTimeOnly ( );
	void ServerToggleSelfFxOnly ( );
	void ToggleSelfFxOnly ( );
	void ServerToggleProjOpt ( );
	void ToggleProjectileOpt ( );
	void SetMatStringFontScale ( float fScale );
	void ToggleTestMatString ( );
	void ServerSetDeathCamOption ( int nOption );
	void SetDeathCamOption ( int nOption );
	void DumpClassInfo ( struct FString sClassName );
	void TestCrash ( );
	void SetPlayerSuits ( int SuitIndex );
	bool CanPlayerMove ( class APawn* P );
	class ATgRepInfo_TaskForce* GetTFRI ( );
	void ServerCycleTeammateView ( unsigned long bForward );
	void ViewPreviousTeammate ( );
	void ViewNextTeammate ( );
	void SetSkydiveLandingLocation ( struct FVector newAccel );
	void GetServerValue ( struct FString strObject, struct FString strVariable );
	void GetClientValue ( struct FString strObject, struct FString strVariable );
	void SetServerValue ( struct FString strObject, struct FString strVariable, struct FString StrValue );
	void SetClientValue ( struct FString strObject, struct FString strVariable, struct FString StrValue );
	void ServerGetValue ( struct FString strObject, struct FString strVariable );
	void ClientGetValue ( struct FString strObject, struct FString strVariable );
	void ServerSetValue ( struct FString strObject, struct FString strVariable, struct FString StrValue );
	void ClientSetValue ( struct FString strObject, struct FString strVariable, struct FString StrValue );
	void ServerCommandAttack ( );
	void ServerCommandTarget ( class AActor* TargetActor );
	void ServerCommandGoto ( struct FVector vDest );
	void ServerCommandFollow ( );
	void CommandAttack ( );
	void CommandTarget ( );
	void CommandGoto ( );
	void CommandFollow ( );
	void eventForceUpdateDeviceBar ( unsigned char EquippedInHand );
	void ServerKillPets ( );
	void KillPets ( );
	void HideTaskForce ( );
	void ShowTaskForce ( );
	void ServerGotoFly ( );
	void GotoFly ( );
	void Stun ( unsigned long bStunController, unsigned char eType );
	void serverdostun ( );
	void dostun ( );
	void ClientResetStunnedBehavior ( unsigned long bStunController, unsigned char eType );
	void SetTagPlayerMode ( unsigned long bSet );
	bool IsInTagPlayerMode ( );
	void OnRestartPlayers ( class UTgSeqAct_RestartPlayers* inAction );
	void ServerSetPosture ( unsigned char Posture, float fRateScale, unsigned long bIgnoreTransition );
	void DeploySlow ( );
	void DeployFast ( );
	void HibernateTrans ( );
	void Hibernate ( );
	void SetPosture ( unsigned char Posture, float fRateScale, unsigned long bIgnoreTransition );
	bool ClientPerformedUseAction ( );
	bool ServerPerformedUseAction ( );
	void ClientUse ( );
	void ServerUse ( );
	void Use ( );
	void ResetCameraYaw ( );
	void ToggleShowLastAimedEnemyStat ( );
	void ToggleShowTeammateStat ( );
	void ToggleDefaultWeaponMode ( );
	void ServerCallForHelp ( );
	void CallForHelp ( );
	void ServerSetEmote ( unsigned char emote, unsigned char Length );
	void PlayEmote ( unsigned char emote, unsigned char Length );
	void eventForceKillPawn ( );
	void AddNewDisplayMessageToHUD ( struct FString sMessage );
	void ClientToggleEndRoundScreen ( unsigned long bShow, class ATgRepInfo_TaskForce* Winner );
	void ShowReleaseDialog ( struct FDeathZoomInfo Info );
	void ClientUpdateTimeRemaining ( float fTimeRemaining );
	void ViewObjectiveCamerasTimer ( );
	void DoDeathZoomTimer ( );
	void DoDeathZoom ( struct FDeathZoomInfo Info );
	void ClientDoDeathZoom ( struct FDeathZoomInfo Info );
	struct FName eventGetStateNameEx ( );
	void ServerSetForceViewTarget ( class ATgPawn* NewTarget );
	void ResetForceViewTarget ( );
	void ClientSetForceViewTarget ( class ATgPawn* NewTarget );
	void CancelForceViewTarget ( );
	void SetForceViewTarget ( class AActor* NewTarget );
	void eventReplicatedEvent ( struct FName VarName );
	void GMVisUpdated ( );
	void ServerQuit ( );
	void CloseCurrentMap ( );
	void PawnDied ( class APawn* P );
	void ClientSetReadyState ( unsigned long bReadyToPlay );
	void ServerSetReadyToPlay ( );
	void SetReadyToPlay ( );
	void TestDie ( unsigned long bDie, int dmgType );
	void ShoulderShot ( float Intensity );
	void HeadShot ( float Intensity );
	void Impulse ( float X, float Y, float Z, struct FName BoneName );
	void ToggleWalk ( );
	void DebugUpdateConeAttackDevice ( );
	void ServerToggleDetailedDeviceLog ( );
	void ToggleServerDetailedDeviceLog ( );
	void ToggleDetailedDeviceLog ( );
	void ToggleSensorDebug ( );
	void ToggleShowConeAttackDebug ( );
	void ShowFootstepInfo ( );
	void ToggleShowBotAIDebug ( );
	void AIDebug ( );
	void ServerForceBotAction ( struct FString NewAction );
	void ForceBotAction ( struct FString NewAction );
	void _ServerEquipDevice ( int nDeviceId, int nEquipPointId );
	void _EquipDeviceByName ( struct FString sDeviceName, int nEquipPointId );
	void _EquipDevice ( int nDeviceId, int nEquipPointId );
	void _ServerSpawnTemplatePlayer ( struct FString sName );
	void _SpawnTemplatePlayer ( struct FString sName );
	class APawn* _ServerSpawnBot ( struct FString sName, int nTaskForce );
	void _SpawnBot ( struct FString sName, int nTaskForce );
	void ChangeCoalition ( unsigned char nCoalition );
	void ChangeTaskForce ( unsigned char nTaskForce );
	void CheckJumpOrDuck ( );
	void eventNotifyJumpApex ( );
	void eventReceivedPlayer ( );
	void eventPostBeginPlay ( );
	void ClientAddCheats ( );
	bool NativeClientAddCheats ( );
	void ToggleScreenShotMode ( );
	void ServerToggleSceneCaptureState ( );
	void LongClientAdjustPosition ( float TimeStamp, struct FName NewState, unsigned char newPhysics, float NewLocX, float NewLocY, float NewLocZ, float NewVelX, float NewVelY, float NewVelZ, class AActor* NewBase, float NewFloorX, float NewFloorY, float NewFloorZ );
	void ToggleSceneCaptureState ( );
	void CaptureScene ( );
	int GetCurrentDeviceBehaviorType ( );
	int GetCurrentDeviceType ( );
	unsigned char GetCurrentEqPoint ( );
	class ATgDevice* GetEqPointDevice ( unsigned char eEqPoint );
	class UTgDeviceFire* GetEqPointDevFire ( );
	unsigned char GetTargetModeBasedOnDevFire ( );
	void RemoveTarget ( );
	bool IsValidTarget ( class AActor* HoverActor );
	bool IsTargetDied ( class AActor* TargetActor );
	bool IsTargetInFrontOfPawn ( struct FVector TargetLocation );
	bool AllowCursorSelectAction ( );
	bool CheckCurrTargetMode ( unsigned char TargetMode );
	struct FRotator GetAdjustedAimFor ( class AWeapon* W, struct FVector StartFireLoc );
	void SetTargetDrawScale ( float NewScale );
	void SetCameraZScale ( float NewScale );
	void DisplayHiddenActorsTimer ( );
	void DisplayHiddenActors ( float Time );
	bool CanAFK ( class ATgPawn* ThePawn );
	void ServerToggleAFK ( unsigned long bEnabled );
	void GoAFK ( );
	void GoAFKTimer ( );
	void CheckBotsAround ( );
	bool IsInOpenPVE ( );
	bool IsInPVE ( );
	void eventPlayerTick ( float DeltaTime );
	void CheckAFKForDC ( );
	void CheckAutoKickTimer ( );
	void StopAutoKickTimer ( );
	void StartAutoKickTimer ( );
	bool ShouldAutoKick ( );
	bool CanPlayerAFK ( );
	void ServerSetGameSpeed ( float fSpeedModifer );
	void SetGameSpeed ( float fSpeedModifer );
	void eventInitInputSystem ( );
	void CrouchDebug ( );
	void SetPlayerTeam ( class ATeamInfo* NewTeam );
	void TeamTalk ( );
	void Talk ( );
	void ClientSetRaidChallengerWon ( unsigned long bAttackerWon );
	void eventSendClientSetRaidChallengerWon ( unsigned long bAttackerWon );
	void ClientTrainingMissionEnded ( class AActor* EndGameFocus, struct FTG_TRAINING_END_INFO trainingEndInfo );
	void TrainingMissionHasEnded ( class AActor* EndGameFocus, int awardedMedal, float ElapsedTime );
	void ClientSetGameWinState ( unsigned char gameWinState );
	void eventSendClientSetGameWinState ( unsigned char gameWinState );
	void FindGoodView ( );
	void SetSpecTiledShot ( int nMultiplier, int nMargin );
	void GoSpectate ( );
	void ClientForwardToSpectatingMatch ( );
	void ForwardToSpectatingMatch ( );
	void RoveReplicateMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	void ServerSetSpectatorLocation ( struct FVector NewLoc );
	void RoveProcessMove ( float DeltaTime, struct FVector newAccel, unsigned char DoubleClickMove, struct FRotator DeltaRot );
	bool LimitSpectatorVelocity ( );
	void RovePlayerMove ( float DeltaTime );
	void AddNavFailedAlert ( unsigned long bAlreadyThere );
	void eventShowPathTo ( class AActor* destActor );
	void ClientShowPathTo ( class AActor* destActor );
	void OnNavIndicator ( class UTgSeqAct_NavIndicator* Action );
	void ShowPathToNearestPOI ( );
	void ShowPathToObjective ( );
	void AdjustCameraScale ( unsigned long bIn );
	void CrouchBlendInterpRate ( float fIn );
	void CamShock ( float fIn );
	void ZoomOut ( );
	void DebugCam ( int X );
	void ZoomIn ( );
	void ServerViewPlayerByName ( struct FString PlayerName );
	void DoSetViewTarget ( class AActor* NewTarget );
	void ViewPlayerByName ( struct FString PlayerName );
	void ServerViewAPlayer ( int Dir, unsigned long bFriendlyOnly );
	void ServerViewPrevPlayer ( unsigned long bFriendlyOnly );
	void ServerViewNextPlayer ( unsigned long bFriendlyOnly );
	float eventGetFOVAngle ( );
	int BlendRot ( float DeltaTime, int BlendC, int NewC );
	void ClientEnterStartState ( );
	void EnterStartState ( );
	void ShortServerMove ( float TimeStamp, struct FVector ClientLoc, unsigned char NewFlags, unsigned char ClientRoll, int View );
	void CallServerMove ( class USavedMove* NewMove, struct FVector ClientLoc, unsigned char ClientRoll, int View, class USavedMove* OldMove );
	void RMServerMove ( float TimeStamp, struct FVector InAccel, struct FVector ClientLoc, unsigned char MoveFlags, unsigned char ClientRoll, int View );
	void ViewShake ( float DeltaTime );
	void UpdateShakeRotComponent ( float Time, float DeltaTime, float* Max, int* Current, float* Rate );
	void CheckShake ( float Time, float* MaxOffset, float* Offset, float* Rate );
	void StopViewShaking ( );
	void OnCameraShake ( class UTgSeqAct_CameraShake* ShakeAction );
	void TestCameraShake ( float Duration, float newLocAmplitude );
	void ShakeView ( struct FViewShakeInfo NewViewShake );
	void CameraShake ( float Duration, struct FVector newRotAmplitude, struct FVector newRotFrequency, struct FVector newLocAmplitude, struct FVector newLocFrequency, float newFOVAmplitude, float newFOVFrequency );
	void SkyDiveShake ( );
	void WeaponShake ( int Intensity );
	void DamageShake ( int Damage );
	bool AllowVoiceMessage ( struct FName MessageType );
	void PlayAnnouncement ( class UClass* InMessageClass, unsigned char m_byMessageIndex );
	void ClientPlayAnnouncement ( class UClass* InMessageClass, unsigned char m_byMessageIndex );
	void ClientSetHUD ( class UClass* newHUDType, class UClass* newScoringType );
	void eventGetPlayerViewPoint ( struct FVector* POVLocation, struct FRotator* POVRotation );
	void eventCreatePlayerCamera ( );
	void SetRadius ( float NewRadius );
	void eventClientReset ( );
	void Reset ( );
	void ClientSetCinematicMode ( unsigned long bInCinematicMode, unsigned long bAffectsMovement, unsigned long bAffectsTurning, unsigned long bAffectsHUD );
	void SetCinematicMode ( unsigned long bInCinematicMode, unsigned long bHidePlayer, unsigned long bAffectsHUD, unsigned long bAffectsMovement, unsigned long bAffectsTurning, unsigned long bAffectsButtons );
	void OnToggleCinematicMode ( class USeqAct_ToggleCinematicMode* Action );
	void DisplayDebug ( class AHUD* HUD, float* out_YL, float* out_YPos );
	void ReviveTimer ( );
	void SetState ( );
	void EndDeathZoom ( );
	void DeathZoomTimerCallback ( );
	void RequestRelease ( unsigned long bOverride );
	void Release ( unsigned long bOverride );
	void eventRevive ( );
	void ServerGotoPlayerPauseState ( float PauseTime );
	void GotoPlayerPauseState ( float PauseTime );
	void DisarmGrapple ( unsigned long bDismount );
	void ServerDisarmGrapple ( unsigned long bDismount );
	void ServerSetAutoGrappling ( unsigned long bOn );
	void LadderLetGo ( );
	void ServerLadderLetGo ( );
	void ServerHangingLetGo ( );
	void PressFreeCam ( unsigned long bOn );
	void eventRestartPlayerOnTransfer ( );
	void CancelActiveCombat ( );
	void NotifyActiveCombat ( int nParam );
	void CancelBeingDetected ( );
	void NotifyBeingDetected ( int nParam );
	void CancelBeingTargeted ( );
	void NotifyBeingTargeted ( );
	void CancelInBombRange ( );
	void NotifyInBombRange ( );
	void CancelBeingLocked ( );
	void NotifyBeingLocked ( );
	void CancelBodyUnderAttack ( );
	void ClientNotifyBodyUnderAttack ( unsigned char Damage );
	void NotifyBodyUnderAttack ( unsigned char Damage );
	void ClientPlayTakeHit ( struct FVector HitLoc, unsigned char Damage, class UClass* DamageType );
	void NotifyTakeHit ( class AController* InstigatedBy, struct FVector HitLocation, int Damage, class UClass* DamageType, struct FVector Momentum );
	void NotifyChangedWeapon ( class AWeapon* PreviousWeapon, class AWeapon* NewWeapon );
	void AcknowledgePossession ( class APawn* P );
	void eventPreRender ( class UCanvas* Canvas );
	void eventDestroyed ( );
	void ServerAssignTarget ( class ATgPawn* TargetPawn );
	void PressJump ( unsigned long bOn );
	void StartJetpack ( );
	int SetDeviceSlotAndMode ( unsigned char eqPoint, int nMode );
	void ServerPickupPutdownDeployable ( );
	void PickupPutdownDeployable ( );
	bool ChangeToPreviousWeapon ( );
	void ServerProfiling ( struct FString Command );
	void ServerProfileScript ( struct FString Command );
	void FloatCamera ( unsigned long bFloatOn );
	void SelfAlert ( int nPriority, float fDuration, int nMsgId );
	void RemoveAlertScript ( int nMsgId );
	void AddAlertScript ( unsigned char Priority, unsigned char Type, float fDuration, int nMsgId, unsigned long bBlockDuplicates, unsigned long bRequestKeybinds );
	int eventGetCamOption ( );
	void CycleCamOption ( );
	void CamOption ( int X, unsigned long saveSetting );
	void ServerCamOption ( int X );
	void ClientSetRotationAndDesired ( struct FRotator NewRotation, unsigned long bResetCamera );
	void eventServerReleasePet ( );
	void eventControlPet ( );
	void SetHackingBotState ( unsigned long bIsHacking );
	void ReleaseHackedPet ( );
	void eventLoadItemProfile ( int nId );
	void eventAcceptNewProfileFromEquipScreen ( int nProfileId, struct FTGEQUIP_SLOTS_STRUCT DeviceArray );
	void ServerRove ( unsigned long bOn );
	void ToggleRove ( );
	void ServerViewSelf ( struct FViewTargetTransitionParams TransitionParams );
	void ServerWatchOtherPlayer ( unsigned char Mode );
	void StopWatchOthers ( );
	void StartWatchOthers ( unsigned char Mode );
	void SetCorrectViewTarget ( );
	void ServerSetViewTarget ( class AActor* me );
	void OnRightMouseReleased ( );
	void OnRightMousePressed ( );
	void OnLeftMouseReleased ( );
	void OnLeftMousePressed ( );
	bool CheckNonCombatInteraction ( );
	void CCE ( struct FName EventName );
	void CauseClientEvent ( struct FName EventName );
	void ServerCallKismetEventFromClient ( );
	void CallServerSideKismetEvent ( );
	void RaidW ( struct FString Message );
	void RgW ( struct FString Message );
	void SetSpawnAtMe ( int bSetToMe );
	void ServerSetSpawnAtMe ( int bSetToMe );
	void AddAutoKickAlert ( );
	void AddMoraleReadyAlert ( );
	void AddAssistAlert ( struct FString KilledName, struct FString KillerName );
	void AddKillAlert ( struct FString KilledName, struct FString KillerName, unsigned long KillerWasPlayer );
	void eventClientAddKilled ( struct FString KilledName, struct FString KillerName, unsigned long KillerWasPlayer );
	void eventRequestBeaconNetworkHop ( class ATgStartPoint* sp );
	void ToggleBinoculars ( );
	void SensorModeChanged ( int nNewMode );
	void ServerSetHenchman ( int nHenchmanNumber, int nBotId );
	void SetTaskforceLead ( struct FString fsName );
	void NameScale ( float nScaleIn );
	void SetShowRangeTargeter ( unsigned long bShow );
	void Wear ( struct FString flairName );
	void ClientPlaySound ( class USoundCue* ASound );
	void eventClientResetEquipScreen ( );
	void rbgrav ( float F );
	void TestShowInventory ( );
	void ServerSetLookingForMembers ( int nCount );
	void eventSetLookingForMembers ( int nCount );
	void ServerAbandonAssignment ( );
	void AbandonAssignment ( );
	bool ServerRequestAssignment ( class ATgMissionObjective* Objective );
	void eventRequestAssignment ( class ATgMissionObjective* Objective );
	void ServerTestCloseAllAssignments ( );
	void TestCloseAllAssignments ( );
	void ServerTestRequestAssignment ( int nPriority );
	void TestRequestAssignment ( int nPriority );
	void ServerTestBeginAssignment ( int nPriority, int nAttackerTf, int nDefenderTf );
	void TestBeginAssignment ( int nPriority, int nAttackerTf, int nDefenderTf );
	void ServerTestAwardLoot ( int nLootTableId );
	void TestAwardLoot ( int nLootTableId );
	void TestSystemMailItem ( int nPlayerId, int nItemId, int nQuantity, unsigned long bSystemCraft, int nMaxQuanlityValueId );
	void ClearMeProfiles ( );
	void ResetMeSkills ( );
	void SetMeLevel ( int nLevel );
	void GiveMeXP ( int Amt );
	void SetPawnAlwaysRelevant ( int nDistSquared );
	void GMGiven ( int nCharacterId, int nCurrency );
	void AddHZPoints ( int nValue );
	void AddToken ( int nValue );
	void Obama ( int nCurrency );
	void ActivateInvItem ( int nInvId );
	void SalvageInvItem ( int nInvId, int nCount );
	void RepairAllUpgrades ( );
	void RepairInvItem ( int nInvId );
	void CombineItems ( int nInvId, int nModKitInvId );
	void CraftItem ( int nBlueprintId );
	void DestroyInvItem ( int nInvId, int nCount, unsigned long bSellIt );
	void ServerActivateInvItem ( int nInvId );
	void ServerSalvageInvItem ( int nInvId, int nCount );
	void ServerRepairAllUpgrades ( );
	void ServerRepairInvItem ( int nInvId );
	void ServerDestroyInvItem ( int nInvId, int nCount, unsigned long bSellIt );
	void ServerCombineItems ( int nInvId, int nModKitInvId );
	void ServerCraftItem ( int nBlueprintId );
	void ServerAddHZPoints ( int nValue, int nCharId );
	void ServerGMGiven ( int nCharacterId, int nCurrency );
	void ServerAddToken ( int nValue, int nCharId );
	void ServerObama ( int nCurrency, int nCharId );
	void ServerClearSkillsAndDevices ( );
	void ServerClearProfiles ( );
	void ServerApplyFlair ( struct FString flairName );
	void ServerSetLevel ( int nLevel );
	void ServerDevGiveXP ( int Amt );
	bool CanPlayerUseVolume ( class ATgOmegaVolume* pOmega );
	void SetNWCondition ( int nPktLoss, int nPktLag );
	void TestCrashReport ( );
	void ServerExecQuit ( );
	class UMaterialInstanceConstant* GetMICResource ( int nResourceId );
	void ServerLogSpeedHack ( );
	void CheckPostSpawnAchievements ( );
	void DebugGetLangMsg ( int nMsgId );
	void PostLimitedAuctionItems ( int nItemId, int nItemCount, int nDurationHours, int nStartPrice, int nBuyoutPrice );
	void ClaimPromotion ( struct FString sCode );
	void SetSoundMode ( struct FName NewSoundMode );
	void DumpPerfTrackData ( );
	void DebugVoice ( );
	void ToggleEchoVoice ( );
	void TestVoice ( unsigned long bOn );
	void TgPerfTrack ( unsigned long bStart );
	void SetPawnTickState ( int nState );
	void ToggleTick ( struct FString ClassName, unsigned long bDisable );
	void DoClientSidePerfTracking ( int nLength );
	float GetTraceTime ( float fRange, unsigned long bStopAtAnyHit );
	void DebugLoc ( );
	void OutputRelevantActors ( );
	void DebugInvisiblePlayer ( );
	void DebugStealth ( );
	void DebugRandomSMActors ( );
	void ActiveVoiceChannel ( int nChannelType );
	void ActiveNewsChannel ( unsigned long bOn );
	void SetNewsSpeakerLocation ( );
	void UpdateNewsListeningLocation ( );
	bool CheckMaxEffectDistance ( class APlayerController* P, struct FVector SpawnLocation, float CullDistance );
	void DisplayReticuleEmitter ( unsigned long bDisplay, struct FVector HitLocation );
	void CheckRangedTargetDevice ( class ATgDevice* Dev );
	struct FVector TraceWeaponFire ( class ATgDevice* Dev, struct FVector StartTrace, struct FVector EndTrace, class AActor* TraceActor );
	bool UseFreezeDeathCam ( );
	void OpenUpdateFaceScreen ( );
	void OpenUpdateHairScreen ( );
	void OpenCraftScreen ( );
	void OpenVendorScene ( int nLootTableId );
	void DoAutoLogin ( );
	void ConvertTimeDisplay ( int nMinutes, struct FString* sDisplay );
	int GetAfkTimeout ( );
	void CheckStealthedCharacter ( class ATgPawn* P );
	void CheckPendingDevice ( );
	void LoopRelevantPawns ( );
	void RefreshRandomSMSettings ( );
	bool ShouldShowDyeColor ( class ATgPawn* P );
	void SetDyeColorOption ( int nOpt );
	void EnableVoip ( );
	void DisableVoip ( );
	void Unfilter ( struct FString PlayerName );
	void Filter ( struct FString PlayerName );
	void PropagateVoipSettings ( );
	void ToggleVoipDetailedLog ( );
	void UnmuteAll ( );
	void MuteAll ( );
	void UnMute ( struct FString fsPlayerName );
	void Mute ( struct FString fsPlayerName );
	void ServerTestSystemMailItem ( int nPlayerId, int nItemId, int nQuantity, unsigned long bSystemCraft, int nMaxQuanlityValueId );
	void ServerSetPawnAlwaysRelevant ( int nDistSquared );
	void ServerAcceptNewProfileFromEquipScreen ( int nProfileId, struct FTGEQUIP_SLOTS_STRUCT DeviceArray );
	void ServerChangeCoalition ( unsigned char nCoalition );
	void ServerChangeTaskForce ( unsigned char nTaskForce );
	void ServerLoadItemProfile ( int nId );
	class ATgPawn* GetPlayerControlPawn ( );
	void SendGameOverEvent ( unsigned char gameWinState, unsigned long bPlayerIsAttacker );
	void ToggleDeathZoom ( unsigned long bOn );
	float GetDeathPitchOffset ( float CurrentPitch, float DeltaTime );
	void ToggleVoiceCapture ( unsigned long bEnabled, int nChannelType );
	void DumpClassInfoToFile ( struct FString sClassName );
	void ClientLoadDevices ( class UTgSeqAct_ClientLoadDevices* Action );
	void SetHUDFade ( unsigned long bFadeIn, float FadeTime );
	void HideHUDElement ( unsigned char Element );
	void ShowHUDElement ( unsigned char Element );
	void FadeMasterSound ( unsigned long bFadeIn, float FadeTime );
	void TriggerOmegaAlert ( unsigned long bForced );
	void CloseConfirmPopup ( struct FName fnCallback, unsigned long bTellGameClient );
	void OpenConfirmPopup ( struct FString fsMessage, struct FName fnCallback );
	int GetDeviceIdByName ( struct FString sDeviceName );
	bool CanShiftReticule ( );
	void CheckAlertSounds ( unsigned long bHealthAlert, unsigned long bPowerAlert );
	void SetValue ( struct FString fsObject, struct FString fsVariable, struct FString fsValue );
	void GetValue ( struct FString fsObject, struct FString fsValue );
	bool bIsEditor ( );
	void ForceRelevant ( class AActor* pActor, float fDuration );
	void FinalSave ( );
	void StopLogTo ( );
	void LogTo ( struct FString fsHost, int nPort );
	class AActor* GetHoverTarget ( );
	struct FVector GetHoverLocation ( );
	void _Crash ( );
	void Bug ( );
	void Support ( );
	class ATgRepInfo_Player* GetPRI ( );
	void ChangeInstance ( int nMapGameId, int nInstanceId );
	void GmBand ( struct FString fsPlayerName );
	void ProcessSkillPromptResponse ( unsigned long bValue );
	void AccompanyOnQuestMap ( unsigned long bAccepted );
	void AcceptHexOwnership ( unsigned long bAccepted );
	void RaidSetLeader ( struct FString fsLeader );
	void RaidAcceptLaunch ( unsigned long bAccepted );
	void HexMissionLeave ( );
	void HexGotoBattle ( unsigned long bAccepted );
	void eventMatchAccept ( unsigned long bAccepted );
	void MatchLeave ( unsigned long bAsTeam );
	void ConfirmMatchLeave ( unsigned long bLeave );
	void OpenConfirmMatchLeave ( );
	void AllianceAccept ( unsigned long bAccepted );
	void AllianceInvite ( struct FString fsName );
	void AgencyDisband ( );
	void AgencyLeave ( );
	void AgencyAccept ( unsigned long bAccepted );
	void AgencyInvite ( struct FString fsName );
	void SetHomeMapGame ( );
	void TeamChallenge ( struct FString fsInfo );
	void TeamSetLeader ( struct FString fsLeader );
	void TeamLeave ( );
	void TeamAccept ( unsigned long bAccepted );
	void TeamInvite ( struct FString fsName );
	void GMCommand ( struct FString fsCommand );
	void ServerRequestBeaconNetworkHop ( class ATgStartPoint* pStartPoint );
	void ServerMarkSpawnReturn ( class ATeleporter* pTeleporter );
	void ServerSetTaskforceLead ( struct FString fsName );
	bool CanCameraSeeActorCenter ( class AActor* Other, float ZOffset );
	bool CanCameraSeePawnCenter ( class ATgPawn* Other );
	void CalcCameraView ( struct FVector* vOutCamLoc, struct FRotator* rOutCamRot );
	class UClass* GetHudClass ( class UClass* pNewHudType );
	bool IsReadyForStart ( );
};

UClass* ATgPlayerController::pClassPointer = NULL;

// Class TgGame.TgPlayerInput
// 0x0028 (0x0190 - 0x0168)
class UTgPlayerInput : public UPlayerInput
{
public:
	class ATgPlayerController*                         c_TgPC;                                           		// 0x0168 (0x0004) [0x0000000000000000]              
	struct FScriptDelegate                             __OnRawInputKey__Delegate;                        		// 0x016C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnInputAxis__Delegate;                          		// 0x0178 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FScriptDelegate                             __OnInputChar__Delegate;                          		// 0x0184 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1534 ];

		return pClassPointer;
	};

	void eventPlayerInput ( float DeltaTime );
	unsigned char CheckForDoubleClickMove ( float DeltaTime );
	void Duck ( );
	bool eventInputChar ( int ControllerId, struct FString Unicode );
	bool OnInputChar ( int ControllerId, struct FString Unicode );
	bool OnInputAxis ( int ControllerId, struct FName Key, float Delta, float DeltaTime );
	bool OnRawInputKey ( int ControllerId, struct FName Key, unsigned char Event, float AmountDepressed );
};

UClass* UTgPlayerInput::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_CharacterBuilder
// 0x09C8 (0x0BEC - 0x0224)
class ATgSkeletalMeshActor_CharacterBuilder : public ATgSkeletalMeshActor
{
public:
	unsigned long                                      m_bIsCharacterBuildDirty : 1;                     		// 0x0224 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bAreAnimationsDirty : 1;                        		// 0x0224 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bUpdateAnimationsFromDB : 1;                    		// 0x0224 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bIsHeadShotHead : 1;                            		// 0x0224 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      m_bIsMorphingDirty : 1;                           		// 0x0224 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bUtilRandomizeMorphs : 1;                       		// 0x0224 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bUtilSpinRight : 1;                             		// 0x0224 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_bUtilSpinLeft : 1;                              		// 0x0224 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	unsigned long                                      m_bUtilPauseSpin : 1;                             		// 0x0224 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_bUtilZoomIn : 1;                                		// 0x0224 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_bUtilZoomOut : 1;                               		// 0x0224 (0x0004) [0x0000000000000001] [0x00000400] ( CPF_Edit )
	unsigned long                                      m_bGoToCharBuilder : 1;                           		// 0x0224 (0x0004) [0x0000000000000001] [0x00000800] ( CPF_Edit )
	unsigned long                                      m_bSaveHeadMorphDataToActor : 1;                  		// 0x0224 (0x0004) [0x0000000000000001] [0x00001000] ( CPF_Edit )
	unsigned long                                      m_bClearSavedHeadMorphData : 1;                   		// 0x0224 (0x0004) [0x0000000000000001] [0x00002000] ( CPF_Edit )
	unsigned long                                      c_bIsCharacterSelect : 1;                         		// 0x0224 (0x0004) [0x0000000000000001] [0x00004000] ( CPF_Edit )
	struct FCustomCharacterAssembly                    m_Assembly;                                       		// 0x0228 (0x0044) [0x0000000000000001]              ( CPF_Edit )
	struct FDeviceAttachmentAssembly                   m_DeviceAssembly;                                 		// 0x026C (0x001C) [0x0000000000000001]              ( CPF_Edit )
	class UTgSkeletalMeshComponent*                    m_SMCHead;                                        		// 0x0288 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_SMCHelmet;                                      		// 0x028C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgStaticMeshComponent*                      m_SMCHair;                                        		// 0x0290 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UStaticMesh*                                 m_PreviewHair;                                    		// 0x0294 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UMeshComponent*                              m_BackpackMC;                                     		// 0x0298 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMeshComponent*                              m_InHandDeviceMC;                                 		// 0x029C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UMeshComponent*                              m_InLeftHandDeviceMC;                             		// 0x02A0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTexture2D*                                  m_HeadShotDiffuseTexture;                         		// 0x02A4 (0x0004) [0x0000000000000000]              
	class UMorphTargetSet*                             m_HeadShotMorphTargetSet;                         		// 0x02A8 (0x0004) [0x0000000000000000]              
	struct FHeadMorphData                              m_HeadMorphData;                                  		// 0x02AC (0x0520) [0x0000000000000000]              
	int                                                m_MorphSettings[ 0xFF ];                          		// 0x07CC (0x03FC) [0x0000000000000000]              
	int                                                m_nMaxMorphIndexSentFromServer;                   		// 0x0BC8 (0x0004) [0x0000000000000000]              
	TArray< struct FMorphInfo >                        m_SavedHeadMorphData;                             		// 0x0BCC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UAnimTree*                                   m_HeadMorphTree;                                  		// 0x0BD8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_NPCVoice;                                       		// 0x0BDC (0x0001) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    c_DefaultRotation;                                		// 0x0BE0 (0x000C) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1535 ];

		return pClassPointer;
	};

	void eventRandomizeMorphs ( );
	void RemoveAllMorphPoses ( );
	void eventSetMorphPose ( float fPct, unsigned char PoseToSet );
	void RemoveHeadShot ( );
	void SetHeadShotHead ( class UTexture2D* DiffuseTexture, class UMorphTargetSet* MorphSet );
	void eventStopAnims ( );
	void eventBuildHair ( class UMaterialInstanceConstant* HeadMIC, int HairMeshId );
	void eventBuildDude ( );
	void eventBeginAnimControl ( TArray< class UAnimSet* > InAnimSets, TArray< class UAnimSet* > InFemaleAnimSets );
	void Tick ( float DeltaSeconds );
	struct FDeviceAttachmentAssembly eventGetDefaultDeviceAssembly ( );
	struct FCustomCharacterAssembly eventGetDefaultCharacterAssembly ( unsigned long bIsFemale );
	void eventSetAssemblyToDefaults ( unsigned long bIsFemale );
	void eventSetDeviceAssembly ( struct FDeviceAttachmentAssembly devassembly );
	void eventSetMorphSettings ( int* Settings );
	void eventSetCustomAssembly ( struct FCustomCharacterAssembly charassembly );
	void eventSetGenderTypeId ( int nId );
	void eventSetEyeColorParameterId ( int Id );
	void eventSetSkinRaceParameterId ( int Id );
	void eventSetSkinToneParameterId ( int Id );
	void eventSetSuitFlairId ( int Id );
	void eventSetHeadFlairId ( int Id );
	void eventSetHideHelmetFlag ( unsigned long bHideHelmetFlag );
	void eventSetBaldFlag ( unsigned long bBaldFlag );
	void SetInHandDeviceIdAndAnimSet ( int MeshId, int InHandAnimSetDeviceId, int InHandLeftHandDeviceMeshId, int InHandLeftHandDeviceAnimSetId );
	void eventSetBackpackMeshId ( int Id );
	void eventSetHelmetMeshId ( int Id );
	void eventSetHairMeshId ( int Id );
	void eventSetHeadMeshId ( int Id );
	void eventSetSuitMeshId ( int Id );
	void eventSetDyeItem ( int nId, unsigned char eSlot );
	void eventPostBeginPlay ( );
	void GetHairColorsFromHeadMorphData ( struct FHairColorParams* OutHairColors );
	void GetSkinColorsFromHeadMorphData ( struct FLinearColor* OutSkinColor, struct FLinearColor* OutBaseSkinColor, float* OutSkinTone );
	bool ShouldDrawHair ( );
	bool ShouldDrawHelmet ( );
	bool ShouldDrawHead ( );
	void ApplyDyeColor ( );
	void ApplyHeadMorphData ( );
	void ClearHeadMorphData ( );
	void SaveHeadMorphData ( );
	int ResolveMorphNodeIndex ( struct FName NodeName );
	void RemoveAllMorphPoseWeights ( );
	void SetMorphNodeWeight ( float fPct, struct FName PoseToSet );
	float GetMorphNodeWeight ( struct FName PoseID );
	int GetNumMorphsInMorphBlendList ( struct FName PoseID );
	void RandomizeAllMorphNodes ( );
	void RandomizeMorphNodesByGroup ( unsigned char GroupID, TArray< unsigned char > IgnorePoses );
	void RandomizeMorphNode ( struct FName PoseID );
	unsigned char GetHeadMorphGroup ( struct FName PoseID );
	class UAnimTree* GetHeadAnimTree ( );
	void UpdateSkelPose ( class USkeletalMeshComponent* SMC );
	int GetMeshIdFromFlairId ( int nItemId );
	void UpdateHalfHelmetStatus ( );
	struct FName GetRootBoneName ( class USkeletalMeshComponent* SMC );
	void UpdateAnimations ( );
	class UMaterialInstanceConstant* GetHairMIC ( int MeshAsmId, int MaterialSubTypeId );
	struct FLinearColor GetMaterialParameter ( int ParameterId );
};

UClass* ATgSkeletalMeshActor_CharacterBuilder::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_CharacterBuilderSpawnable
// 0x0000 (0x0BEC - 0x0BEC)
class ATgSkeletalMeshActor_CharacterBuilderSpawnable : public ATgSkeletalMeshActor_CharacterBuilder
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1536 ];

		return pClassPointer;
	};

};

UClass* ATgSkeletalMeshActor_CharacterBuilderSpawnable::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_EquipScreen
// 0x0004 (0x0BF0 - 0x0BEC)
class ATgSkeletalMeshActor_EquipScreen : public ATgSkeletalMeshActor_CharacterBuilder
{
public:
	class UTgAnimNodeBlendList_EquipScreen*            m_EquipScreenBlendList;                           		// 0x0BEC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1537 ];

		return pClassPointer;
	};

	void eventPlayBackpackReaction ( );
	void eventPlaySuitReaction ( );
	void eventPlayHelmetReaction ( );
	void eventPlayWeaponDeployAnimation ( );
	void eventPlayWeaponReaction ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgSkeletalMeshActor_EquipScreen::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActorNPC
// 0x0145 (0x0D31 - 0x0BEC)
class ATgSkeletalMeshActorNPC : public ATgSkeletalMeshActor_CharacterBuilder
{
public:
	class ATgPlayerController*                         c_LocalPC;                                        		// 0x0BEC (0x0004) [0x0000000000000000]              
	class UTgSkelCon_LookAt*                           c_RightEyeLookAt;                                 		// 0x0BF0 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_LookAt*                           c_LeftEyeLookAt;                                  		// 0x0BF4 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_LookAt*                           c_HeadLookAt;                                     		// 0x0BF8 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeAimOffset*                        m_AimOffsetNode;                                  		// 0x0BFC (0x0004) [0x0000000000000000]              
	float                                              c_AimOffsetTurnSpeed;                             		// 0x0C00 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendNPC*                         c_NPCBlendNode;                                   		// 0x0C04 (0x0004) [0x0000000000000000]              
	float                                              c_fLookAtZOffset;                                 		// 0x0C08 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fLookAtEffectiveRange;                          		// 0x0C0C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      c_bCanCallOut : 1;                                		// 0x0C10 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      c_bIsCallingOut : 1;                              		// 0x0C10 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      c_bLoadAnimationTreeAndSetsFromDB : 1;            		// 0x0C10 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      c_bEnableCamera : 1;                              		// 0x0C10 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      c_bPreviewCamera : 1;                             		// 0x0C10 (0x0004) [0x0000000000002001] [0x00000010] ( CPF_Edit | CPF_Transient )
	unsigned long                                      c_bCamOverridePostProcess : 1;                    		// 0x0C10 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	float                                              c_fCallOutLookAtEffectiveRange;                   		// 0x0C14 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fMinCallOutTime;                                		// 0x0C18 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fMaxCallOutTime;                                		// 0x0C1C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fTimeRemainingUntilNextCallOut;                 		// 0x0C20 (0x0004) [0x0000000000000000]              
	float                                              c_fTimeToPlayCustomerPresentAnim;                 		// 0x0C24 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fRemainingTimeToPlayCustomerPresentAnim;        		// 0x0C28 (0x0004) [0x0000000000000000]              
	TArray< class ATgPawn* >                           c_PawnList;                                       		// 0x0C2C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgPawn*                                     c_PawnWithMyAttention;                            		// 0x0C38 (0x0004) [0x0000000000000000]              
	struct FString                                     c_strDisplayName;                                 		// 0x0C3C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	float                                              c_fDisplayNameHeight;                             		// 0x0C48 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FNPCAttachmentInfo >                Attachments;                                      		// 0x0C4C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class UTgSpecialFx*                                c_OverheadFx;                                     		// 0x0C58 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UTgSpecialFx*                                c_ExitOverheadFx;                                 		// 0x0C5C (0x0004) [0x0000000000000000]              
	int                                                c_OnExitOverheadId;                               		// 0x0C60 (0x0004) [0x0000000000000000]              
	float                                              c_OverheadFXZOffset;                              		// 0x0C64 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgOmegaVolume*                              c_OmegaVolume;                                    		// 0x0C68 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	TArray< struct FName >                             c_NoQuestAvailableAnimList;                       		// 0x0C6C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             c_QuestAvailableAnimList;                         		// 0x0C78 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             c_QuestCompletedAnimList;                         		// 0x0C84 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	struct FVector                                     c_CameraLocationOffset;                           		// 0x0C90 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FRotator                                    c_CameraRotationOffset;                           		// 0x0C9C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_CameraFOVAngle;                                 		// 0x0CA8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ADynamicCameraActor*                         c_Camera;                                         		// 0x0CAC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FPostProcessSettings                        c_CamOverridePostProcess;                         		// 0x0CB0 (0x0080) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      c_PreviewAspectRatio;                             		// 0x0D30 (0x0001) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1538 ];

		return pClassPointer;
	};

	void eventPostRenderFor ( class APlayerController* PC, class UCanvas* Canvas, struct FVector CameraPosition, struct FVector CameraDir );
	void eventOnAnimPlay ( class UAnimNodeSequence* SeqNode );
	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void SetAttentionToNextTarget ( );
	void eventPawnLeftPresence ( class ATgPawn* P );
	void eventPawnEnteredPresence ( class ATgPawn* P );
	bool CheckCallOut ( float DeltaSeconds );
	void eventTick ( float DeltaTime );
	void CreateAttachments ( );
	void eventPostBeginPlay ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void SetOverheadFx ( int FxId, int ExitFxId );
};

UClass* ATgSkeletalMeshActorNPC::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_Composite
// 0x010C (0x0330 - 0x0224)
class ATgSkeletalMeshActor_Composite : public ATgSkeletalMeshActor
{
public:
	struct FCompositeCharacterInfo                     m_CompositeCharacterInfo;                         		// 0x0224 (0x0040) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bCompositeMesh : 1;                             		// 0x0264 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bComposeFromBank : 1;                           		// 0x0264 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bParentAnimMeshComponents : 1;                  		// 0x0264 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bLoadBackpack : 1;                              		// 0x0264 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bLoadHead : 1;                                  		// 0x0264 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bLoadWeapon1 : 1;                               		// 0x0264 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned long                                      m_bLoadWeapon2 : 1;                               		// 0x0264 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_bLoadHair : 1;                                  		// 0x0264 (0x0004) [0x0000000000000001] [0x00000080] ( CPF_Edit )
	TArray< struct FString >                           m_sTorsoMeshes;                                   		// 0x0268 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_sHelmetMeshes;                                  		// 0x0274 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_sGlovesRMeshes;                                 		// 0x0280 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_sGlovesLMeshes;                                 		// 0x028C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_sLegsMeshes;                                    		// 0x0298 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_sBootsRMeshes;                                  		// 0x02A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_sBootsLMeshes;                                  		// 0x02B0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FString >                           m_sClassMeshes;                                   		// 0x02BC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class UTgSkeletalMeshComponent*                    m_GlovesRMeshComponent;                           		// 0x02C8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_GlovesLMeshComponent;                           		// 0x02CC (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_LegsMeshComponent;                              		// 0x02D0 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_BootsRMeshComponent;                            		// 0x02D4 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_BootsLMeshComponent;                            		// 0x02D8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_ClassMeshComponent;                             		// 0x02DC (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_BackpackMeshComponent;                          		// 0x02E0 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_HeadMeshComponent;                              		// 0x02E4 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_Weapon1MeshComponent;                           		// 0x02E8 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_Weapon2MeshComponent;                           		// 0x02EC (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class UStaticMeshComponent*                        m_HairMeshComponent;                              		// 0x02F0 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	struct FString                                     m_sBackpackMesh;                                  		// 0x02F4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_sHeadMesh;                                      		// 0x0300 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_sWeapon1Mesh;                                   		// 0x030C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_sWeapon2Mesh;                                   		// 0x0318 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	struct FString                                     m_sHairMesh;                                      		// 0x0324 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1539 ];

		return pClassPointer;
	};

	void SetCompositeCharacterInfo ( int Torso, int Head, int GlovesR, int GlovesL, int Legs, int BootsR, int BootsL, int ClassSpecific );
	void ComposeMesh ( );
	void CreateMeshesFromBank ( );
	void CreateMeshesFromIds ( );
};

UClass* ATgSkeletalMeshActor_Composite::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActor_MeleePreVis
// 0x00D5 (0x02F9 - 0x0224)
class ATgSkeletalMeshActor_MeleePreVis : public ATgSkeletalMeshActor
{
public:
	class UTgAnimNodeBlendList*                        m_RunAttackBlendNode;                             		// 0x0224 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_AttackFromLeftSeqNode;                          		// 0x0228 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_AttackFromRightSeqNode;                         		// 0x022C (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendList*                        m_AttackBlendNode;                                		// 0x0230 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendList*                        m_IdleBlendNode;                                  		// 0x0234 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendList*                        m_IdleAttackBlendNode;                            		// 0x0238 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendList*                        m_PostAttackPoseBlendNode;                        		// 0x023C (0x0004) [0x0000000000000000]              
	class UTgAnimNodeBlendList*                        m_JumpBlendNode;                                  		// 0x0240 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_JumpSeqNode;                                    		// 0x0244 (0x0004) [0x0000000000000000]              
	class UTgAnimBlendPerBone*                         m_JumpBlendPerBone;                               		// 0x0248 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_LungeControl;                                   		// 0x024C (0x0004) [0x0000000000000000]              
	float                                              m_fBlendToAttackTime;                             		// 0x0250 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBlendToRunTime;                                		// 0x0254 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fBlendTimeToChainedAttacks;                     		// 0x0258 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_AttackIntervalMin;                              		// 0x025C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_AttackIntervalMax;                              		// 0x0260 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AttackMovingFromRightAnimName;                  		// 0x0264 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AttackMovingFromLeftAnimName;                   		// 0x026C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AttackIdleFromRightAnimName;                    		// 0x0274 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AttackIdleFromLeftAnimName;                     		// 0x027C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AttackJumpUpFromLeftAnimName;                   		// 0x0284 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AttackJumpUpFromRightAnimName;                  		// 0x028C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AttackJumpDownFromLeftAnimName;                 		// 0x0294 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_AttackJumpDownFromRightAnimName;                		// 0x029C (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bForceSingleAttacks : 1;                        		// 0x02A4 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bAttackFromLeft : 1;                            		// 0x02A4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bIsInMeleeAttack : 1;                           		// 0x02A4 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bEnableLunge : 1;                               		// 0x02A4 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bEnableIdle : 1;                                		// 0x02A4 (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bIdleEnabledLastTick : 1;                       		// 0x02A4 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      m_bForceIdle : 1;                                 		// 0x02A4 (0x0004) [0x0000000000000001] [0x00000040] ( CPF_Edit )
	unsigned long                                      m_bIsIdle : 1;                                    		// 0x02A4 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bEnableJumping : 1;                             		// 0x02A4 (0x0004) [0x0000000000000001] [0x00000100] ( CPF_Edit )
	unsigned long                                      m_bIsJumping : 1;                                 		// 0x02A4 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      m_bIsLanding : 1;                                 		// 0x02A4 (0x0004) [0x0000000000000000] [0x00000400] 
	float                                              m_ChanceToChainAttacks;                           		// 0x02A8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_PostAttackPoseHoldTime;                         		// 0x02AC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_PostAttackPoseMovingAnimName;                   		// 0x02B0 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	struct FName                                       m_PostAttackPoseIdleAnimName;                     		// 0x02B8 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_LungeStartPos;                                  		// 0x02C0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_LungeEndPos;                                    		// 0x02C4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_LungeBlendTime;                                 		// 0x02C8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_LungeTranslation;                               		// 0x02CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_IdleTimeMin;                                    		// 0x02D0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_IdleTimeMax;                                    		// 0x02D4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_RunTimeMin;                                     		// 0x02D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_RunTimeMax;                                     		// 0x02DC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_IdleBlendTime;                                  		// 0x02E0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_JumpTimeMin;                                    		// 0x02E4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_JumpTimeMax;                                    		// 0x02E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_JumpBlendTime;                                  		// 0x02EC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_LandingAnimPct;                                 		// 0x02F0 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_DownAnimPct;                                    		// 0x02F4 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      m_MovingDirection;                                		// 0x02F8 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1540 ];

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void eventOnAnimPlay ( class UAnimNodeSequence* SeqNode );
	void EndPostAttackHoldPose ( );
	void GoRun ( );
	void GoIdle ( );
	void Attack ( );
	bool CanJumpNow ( );
	void DoJump ( );
	void eventPostBeginPlay ( );
	void eventTick ( float DeltaTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgSkeletalMeshActor_MeleePreVis::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActorGenericUIPreview
// 0x0000 (0x0224 - 0x0224)
class ATgSkeletalMeshActorGenericUIPreview : public ATgSkeletalMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1541 ];

		return pClassPointer;
	};

};

UClass* ATgSkeletalMeshActorGenericUIPreview::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshComponent
// 0x056C (0x0A44 - 0x04D8)
class UTgSkeletalMeshComponent : public USkeletalMeshComponent
{
public:
	float                                              FOV;                                              		// 0x04D8 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class UTgSpecialFx* >                      c_FxList;                                         		// 0x04DC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nAssemblyId;                                    		// 0x04E8 (0x0004) [0x0000000000000000]              
	struct FVector                                     FPCTranslation;                                   		// 0x04EC (0x000C) [0x0000000000000000]              
	struct FRotator                                    FPCRotation;                                      		// 0x04F8 (0x000C) [0x0000000000000000]              
	struct FVector                                     FPCScale;                                         		// 0x0504 (0x000C) [0x0000000000000000]              
	struct FName                                       c_AimOffsetProfileName;                           		// 0x0510 (0x0008) [0x0000000000000000]              
	int                                                c_AudioGroupId;                                   		// 0x0518 (0x0004) [0x0000000000000000]              
	struct FHeadMorphData                              m_MorphData;                                      		// 0x051C (0x0520) [0x0000000000000000]              
	int                                                c_nForceUpdateAttachmentsInTick;                  		// 0x0A3C (0x0004) [0x0000000000000000]              
	unsigned long                                      c_bIsFemale : 1;                                  		// 0x0A40 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1542 ];

		return pClassPointer;
	};

	void GetHairColorsFromMorphData ( struct FHairColorParams* OutHairColors );
	void GetSkinColorsFromMorphData ( struct FLinearColor* OutSkinColor, struct FLinearColor* OutBaseSkinColor, float* OutSkinTone );
	void SetForceUpdateAttachmentsInTick ( unsigned long bSet );
	int ResolveMorphNodeIndex ( struct FName NodeName );
	void SetMorphNodeWeight ( float fPct, struct FName PoseToSet );
	float GetMorphNodeWeight ( struct FName PoseID );
	int GetNumMorphsInMorphBlendList ( struct FName PoseID );
	class UAnimTree* GetAnimTree ( );
	void ApplyDye ( class UMaterialInterface* PrimaryDyeMI, class UMaterialInterface* SecondaryDyeMI, class UMaterialInterface* EmissiveDyeMI );
	void OnMeshSetHidden ( unsigned long bHidden );
	void RecalculateFx ( );
	void ActivateOnWhenDeployedFx ( );
	float GetDefaultDeployAnimLength ( );
	float GetCurrentDeployPercentage ( );
	void SwapMaterial ( class UMaterialInterface* MI, unsigned long bNoParamReaping );
	class UMaterialInterface* GetDefaultMaterial ( int nIndex );
	void SetDefaultSkin ( int nIndex );
	void FxActivateIndependant ( struct FName nmGroup, int nMode, struct FVector HitLocation, struct FVector HitNormal, int nSocketIndex, int nEquipSlot );
	class UAudioComponent* FxSpawnSound ( struct FName nmGroup, int nMode, struct FVector SoundLocation, int nSocketIndex, int nEquipSlot );
	void FxSpawnEmitter ( struct FName nmGroup, int nMode, struct FVector HitLocation, struct FVector HitNormal, int nSocketIndex, int nEquipSlot );
	void FxSpawnTracer ( struct FName nmGroup, int nMode, struct FVector HitLocation, int nSocketIndex, int nEquipSlot );
	void FxDeactivateGroup ( struct FName nmGroup, int nMode, int nSocketIndex, int nEquipSlot );
	class UObject* FxActivateGroup ( struct FName nmGroup, int nMode, int nSocketIndex, int nEquipSlot, unsigned long bIgnoreRelevancy );
	class UObject* FxGet ( struct FName nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot );
	void FxRemove ( class UObject* Fx );
	void FxAdd ( class UObject* Fx );
	void EndRagdoll ( );
	void InitRagdoll ( );
};

UClass* UTgSkeletalMeshComponent::pClassPointer = NULL;

// Class TgGame.TgStaticMeshComponent
// 0x0010 (0x025C - 0x024C)
class UTgStaticMeshComponent : public UStaticMeshComponent
{
public:
	TArray< class UTgSpecialFx* >                      c_FxList;                                         		// 0x024C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                m_nAssemblyId;                                    		// 0x0258 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1543 ];

		return pClassPointer;
	};

	void ApplyDye ( class UMaterialInterface* PrimaryDyeMI, class UMaterialInterface* SecondaryDyeMI, class UMaterialInterface* EmissiveDyeMI );
	void RecalculateFx ( );
	void OnMeshSetHidden ( unsigned long bHidden );
	class UMaterialInterface* GetDefaultMaterial ( int nIndex );
	void SetDefaultSkin ( int nIndex );
	void SwapMaterial ( class UMaterialInterface* MI, unsigned long bNoParamReaping );
	void FxActivateIndependant ( struct FName nmGroup, int nMode, struct FVector HitLocation, struct FVector HitNormal, int nSocketIndex, int nEquipSlot );
	class UAudioComponent* FxSpawnSound ( struct FName nmGroup, int nMode, struct FVector SoundLocation, int nSocketIndex, int nEquipSlot );
	void FxSpawnEmitter ( struct FName nmGroup, int nMode, struct FVector HitLocation, struct FVector HitNormal, int nSocketIndex, int nEquipSlot );
	void FxSpawnTracer ( struct FName nmGroup, int nMode, struct FVector HitLocation, int nSocketIndex, int nEquipSlot );
	void FxDeactivateGroup ( struct FName nmGroup, int nMode, int nSocketIndex, int nEquipSlot );
	class UObject* FxActivateGroup ( struct FName nmGroup, int nMode, int nSocketIndex, int nEquipSlot, unsigned long bIgnoreRelevancy );
	class UObject* FxGet ( struct FName nmGroup, int nMode, int nIndex, int nSocketIndex, int nEquipSlot );
	void FxRemove ( class UObject* Fx );
	void FxAdd ( class UObject* Fx );
};

UClass* UTgStaticMeshComponent::pClassPointer = NULL;

// Class TgGame.TgBotEncounterVolume
// 0x0010 (0x0218 - 0x0208)
class ATgBotEncounterVolume : public AVolume
{
public:
	TArray< class ATgBotFactory* >                     m_Factories;                                      		// 0x0208 (0x000C) [0x0000000000400003]              ( CPF_Edit | CPF_Const | CPF_NeedCtorLink )
	int                                                m_nPlayers;                                       		// 0x0214 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1544 ];

		return pClassPointer;
	};

	void CheckTouching ( );
	void PostBeginPlay ( );
};

UClass* ATgBotEncounterVolume::pClassPointer = NULL;

// Class TgGame.TgDeviceVolume
// 0x001D (0x0225 - 0x0208)
class ATgDeviceVolume : public AVolume
{
public:
	unsigned long                                      bPainCausing : 1;                                 		// 0x0208 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      BACKUP_bPainCausing : 1;                          		// 0x0208 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bDeviceActive : 1;                              		// 0x0208 (0x0004) [0x0000000000000000] [0x00000004] 
	class AInfo*                                       PainTimer;                                        		// 0x020C (0x0004) [0x0000000000000000]              
	class AController*                                 DamageInstigator;                                 		// 0x0210 (0x0004) [0x0000000000000000]              
	int                                                m_nMapObjectId;                                   		// 0x0214 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                s_nDeviceId;                                      		// 0x0218 (0x0004) [0x0000000000020000]              ( CPF_EditConst )
	class UTgDeviceFire*                               s_DeviceFireMode;                                 		// 0x021C (0x0004) [0x0000000000000000]              
	int                                                s_nTeamNumber;                                    		// 0x0220 (0x0004) [0x0000000000020000]              ( CPF_EditConst )
	unsigned char                                      s_nTaskForce;                                     		// 0x0224 (0x0001) [0x0000000000020000]              ( CPF_EditConst )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1545 ];

		return pClassPointer;
	};

	void ApplyHit ( class AActor* Target );
	void OnSetDamageInstigator ( class USeqAct_SetDamageInstigator* Action );
	void CausePainTo ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void TimerPop ( class ATgDeviceVolumeInfo* T );
	void OnToggle ( class USeqAct_Toggle* inAction );
	void Reset ( );
	void eventPostBeginPlay ( );
	bool setupDevice ( );
};

UClass* ATgDeviceVolume::pClassPointer = NULL;

// Class TgGame.TgHelpAlertVolume
// 0x0008 (0x0210 - 0x0208)
class ATgHelpAlertVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                   		// 0x0208 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_nHelpId;                                        		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1546 ];

		return pClassPointer;
	};

};

UClass* ATgHelpAlertVolume::pClassPointer = NULL;

// Class TgGame.TgMissionListVolume
// 0x0010 (0x0218 - 0x0208)
class ATgMissionListVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                   		// 0x0208 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                s_nQueueTableId;                                  		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                s_nQueueTableMsgId;                               		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATeleporter*                                 m_Teleporter;                                     		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1547 ];

		return pClassPointer;
	};

};

UClass* ATgMissionListVolume::pClassPointer = NULL;

// Class TgGame.TgModifyPawnPropertiesVolume
// 0x0020 (0x0228 - 0x0208)
class ATgModifyPawnPropertiesVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                   		// 0x0208 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	unsigned long                                      m_bDisableJump : 1;                               		// 0x020C (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bDisableBlockActors : 1;                        		// 0x020C (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bDisableHanging : 1;                            		// 0x020C (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bDisableAllDevices : 1;                         		// 0x020C (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	unsigned long                                      m_bTriggerUseEvent : 1;                           		// 0x020C (0x0004) [0x0000000000000001] [0x00000010] ( CPF_Edit )
	unsigned long                                      m_bOneWayMovement : 1;                            		// 0x020C (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	struct FRotator                                    m_vOnewWay;                                       		// 0x0210 (0x000C) [0x0000000000000000]              
	class UArrowComponent*                             m_DirArrow;                                       		// 0x021C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                s_nLootTableId;                                   		// 0x0220 (0x0004) [0x0000000000000000]              
	class ATgSkeletalMeshActorNPC*                     c_Vendor;                                         		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1548 ];

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void eventPostBeginPlay ( );
	void Used ( class AActor* Other );
	void LoadObjectConfig ( );
};

UClass* ATgModifyPawnPropertiesVolume::pClassPointer = NULL;

// Class TgGame.TgOmegaVolume
// 0x002D (0x0235 - 0x0208)
class ATgOmegaVolume : public AVolume
{
public:
	int                                                m_nMapObjectId;                                   		// 0x0208 (0x0004) [0x0000000000020001]              ( CPF_Edit | CPF_EditConst )
	int                                                m_nOmegaAlertId;                                  		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nSubzoneNameMsgId;                              		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nSubzoneSecondaryNameMsgId;                     		// 0x0214 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nOmegaPriority;                                 		// 0x0218 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_nBilboardKey;                                   		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bEnableEquip : 1;                               		// 0x0220 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bEnableSkills : 1;                              		// 0x0220 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bEnableCrafting : 1;                            		// 0x0220 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      m_bAutoKickIfIdle : 1;                            		// 0x0220 (0x0004) [0x0000000000000001] [0x00000008] ( CPF_Edit )
	class ATeleporter*                                 m_QueueTeleporter;                                		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgSkeletalMeshActorNPC*                     c_OmegaNPC;                                       		// 0x0228 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class ATgStartPoint*                               m_StartPoint;                                     		// 0x022C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FPointer                                    m_pAmVolume;                                      		// 0x0230 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	unsigned char                                      m_eVisualCue;                                     		// 0x0234 (0x0001) [0x0000000000002001]              ( CPF_Edit | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1549 ];

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	struct FVector GetDisplayLocation ( );
	void eventPostBeginPlay ( );
	void NativePostBeginPlay ( );
	void Used ( class ATgPlayerController* UsingPlayer );
};

UClass* ATgOmegaVolume::pClassPointer = NULL;

// Class TgGame.TgPlayerCountVolume
// 0x001C (0x0224 - 0x0208)
class ATgPlayerCountVolume : public AVolume
{
public:
	int                                                PlayerCountTarget;                                		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                TaskForceNumber;                                  		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                messageID;                                        		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class APawn* >                             Players;                                          		// 0x0214 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      Enabled : 1;                                      		// 0x0220 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1550 ];

		return pClassPointer;
	};

	int eventGetCount ( );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void Update ( class ATgPawn* Other );
};

UClass* ATgPlayerCountVolume::pClassPointer = NULL;

// Class TgGame.TgSkydivingVolume
// 0x0010 (0x0260 - 0x0250)
class ATgSkydivingVolume : public APhysicsVolume
{
public:
	float                                              r_PawnGravityModifier;                            		// 0x0250 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	float                                              r_PawnUpForce;                                    		// 0x0254 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	float                                              r_PawnLaunchForce;                                		// 0x0258 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	class ATgSkydiveTarget*                            r_SkydiveTarget;                                  		// 0x025C (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1551 ];

		return pClassPointer;
	};

	void eventPawnEnteredVolume ( class APawn* P );
};

UClass* ATgSkydivingVolume::pClassPointer = NULL;

// Class TgGame.TgUIDataProvider_SimpleElementProvider
// 0x0004 (0x005C - 0x0058)
class UTgUIDataProvider_SimpleElementProvider : public UUIDataProvider
{
public:
	struct FPointer                                    VfTable_IUIListElementCellProvider;               		// 0x0058 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1552 ];

		return pClassPointer;
	};

	int GetElementCount ( );
};

UClass* UTgUIDataProvider_SimpleElementProvider::pClassPointer = NULL;

// Class TgGame.TgUIDataProvider_StringArray
// 0x000C (0x0068 - 0x005C)
class UTgUIDataProvider_StringArray : public UTgUIDataProvider_SimpleElementProvider
{
public:
	TArray< struct FString >                           Strings;                                          		// 0x005C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1553 ];

		return pClassPointer;
	};

	int GetElementCount ( );
};

UClass* UTgUIDataProvider_StringArray::pClassPointer = NULL;

// Class TgGame.TgUIDataStore_StringList
// 0x0014 (0x008C - 0x0078)
class UTgUIDataStore_StringList : public UUIDataStore_StringBase
{
public:
	struct FPointer                                    VfTable_IUIListElementProvider;                   		// 0x0078 (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	struct FPointer                                    VfTable_IUIListElementCellProvider;               		// 0x007C (0x0004) [0x0000000000801002]              ( CPF_Const | CPF_Native | CPF_NoExport )
	TArray< struct FEStringListData >                  StringData;                                       		// 0x0080 (0x000C) [0x0000000000404000]              ( CPF_Config | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1554 ];

		return pClassPointer;
	};

	int eventNum ( struct FName FieldName );
	int eventSetCurrentValueIndex ( struct FName FieldName, int NewValueIndex );
	int eventGetCurrentValueIndex ( struct FName FieldName );
	bool eventGetCurrentValue ( struct FName FieldName, struct FString* out_Value );
	TArray< struct FString > GetList ( struct FName FieldName );
	struct FString GetStr ( struct FName FieldName, int StrIndex );
	int FindStr ( struct FName FieldName, struct FString SearchString );
	void Empty ( struct FName FieldName, unsigned long bBatchOp );
	void RemoveStrByIndex ( struct FName FieldName, int Index, int Count, unsigned long bBatchOp );
	void RemoveStr ( struct FName FieldName, struct FString StringToRemove, unsigned long bBatchOp );
	void UpdateStr ( struct FName FieldName, struct FString NewString, int UpdateIndex, unsigned long bBatchOp );
	void InsertStr ( struct FName FieldName, struct FString NewString, int InsertIndex, unsigned long bBatchOp );
	void AddStr ( struct FName FieldName, struct FString NewString, unsigned long bBatchOp );
	int GetFieldIndex ( struct FName FieldName );
	void eventRegistered ( class ULocalPlayer* PlayerOwner );
};

UClass* UTgUIDataStore_StringList::pClassPointer = NULL;

// Class TgGame.TgUIHexWidget
// 0x00E0 (0x0504 - 0x0424)
class UTgUIHexWidget : public UUIMeshWidget
{
public:
	float                                              HEX_PIECE_WIDTH;                                  		// 0x0424 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              HEX_PIECE_HEIGHT;                                 		// 0x0428 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              HEX_PIECE_WIDTH_OFFSET;                           		// 0x042C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              HEX_PIECE_HEIGHT_OFFSET;                          		// 0x0430 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FHexData >                          m_Hexes;                                          		// 0x0434 (0x000C) [0x0000000000482000]              ( CPF_Transient | CPF_Component | CPF_NeedCtorLink )
	struct FMatrix                                     m_CachedMapTransform;                             		// 0x0440 (0x0040) [0x0000000000002000]              ( CPF_Transient )
	class UTgStaticMeshComponent*                      m_BackgroundMesh;                                 		// 0x0480 (0x0004) [0x0000000004082008]              ( CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	TArray< class UMaterialInstanceConstant* >         m_BackgroundMICs;                                 		// 0x0484 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UMaterialInstanceConstant*                   m_BorderMICParent;                                		// 0x0490 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_HexMaterialParent;                              		// 0x0494 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_CulledHexMaterialParent;                        		// 0x0498 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_HexBaseMaterialParent;                          		// 0x049C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_CulledHexBaseMaterialParent;                    		// 0x04A0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class ULightComponent*                             DefaultLight;                                     		// 0x04A4 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FVector                                     LightDirection;                                   		// 0x04A8 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_BaseAdjust;                                     		// 0x04B4 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_BaseRotation;                                   		// 0x04C0 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_BaseHeight;                                     		// 0x04CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bNeedsMICUpdate : 1;                            		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bNeedsTransformUpdate : 1;                      		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bNeedsUnderlayUpdate : 1;                       		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bNeedsTileUpdate : 1;                           		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bNeedsButtonUpdate : 1;                         		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bNeedsOverlayUpdate : 1;                        		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_bNeedsIndicatorUpdate : 1;                      		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_bNeedsFilterUpdate : 1;                         		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	unsigned long                                      m_bPrimsInitialized : 1;                          		// 0x04D0 (0x0004) [0x0000000000002000] [0x00000100] ( CPF_Transient )
	unsigned long                                      m_bUseZoomHide : 1;                               		// 0x04D0 (0x0004) [0x0000000000000001] [0x00000200] ( CPF_Edit )
	unsigned long                                      m_bHideUnusable : 1;                              		// 0x04D0 (0x0004) [0x0000000000000000] [0x00000400] 
	int                                                m_nPlayerTeamId;                                  		// 0x04D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_SelectedIndex;                                  		// 0x04D8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_HoverIndex;                                     		// 0x04DC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_InitialHexCount;                                		// 0x04E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nWidth;                                         		// 0x04E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FVector                                     m_ZoomAdjust;                                     		// 0x04E8 (0x000C) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_ZoomValue;                                      		// 0x04F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FZoomLock                                   m_ZoomLocks;                                      		// 0x04F8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nBackgroundResId;                               		// 0x04FC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nZoneObjectId;                                  		// 0x0500 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1555 ];

		return pClassPointer;
	};

	void SetMICParams ( class UMaterialInstanceConstant* MIC, struct FHexMICParams Params );
	struct FHexMICParams GetMICParams ( int nIndex );
	void ClearSelection ( );
	struct FScaleData GetScaleData ( );
	int GetHexIndexMouse ( int xMouse, int yMouse );
	int GetHexPositionFromIndex ( int nIndex );
	int GetHexIndexFromPosition ( int nPos );
	void GetHexPosition ( int XPos, int YPos, int* nPos );
	void GetGridPosition ( int nPos, int* XPos, int* YPos );
	TArray< int > GetNeighborIndexes ( int nIndex );
	void UpdateZoomLocks ( );
	unsigned char HexInBounds ( int Index, float fPct );
	void ResizeHexGrid ( int nNewWidth, int nNewHeight );
	void ResizeNumHexes ( int nNewSize );
	float GetAdjustedAspectRatio ( );
	bool GetHexData ( int Index, struct FHexData* Data );
	void CenterMapOn ( int nPos );
	void CenterMap ( );
	void OnZoom ( float fDeltaZoom );
	void OnPan ( int X, int Y, int pX, int pY );
	void OnClick ( int X, int Y );
	void OnHover ( int X, int Y );
	void UpdateFilters ( int nIndex );
	void UpdateIndicators ( int nIndex );
	void UpdateOverlays ( int nIndex );
	void UpdateButtons ( int nIndex );
	void UpdateTiles ( int nIndex );
	void UpdateUnderlays ( int nIndex );
	void UpdateMICs ( int nIndex );
	void UpdateBackground ( );
	void TickComponents ( float DeltaSeconds );
};

UClass* UTgUIHexWidget::pClassPointer = NULL;

// Class TgGame.TgUIHexWidget_Raid
// 0x000C (0x0510 - 0x0504)
class UTgUIHexWidget_Raid : public UTgUIHexWidget
{
public:
	int                                                m_nRaidPhase;                                     		// 0x0504 (0x0004) [0x0000000000000000]              
	int                                                m_nTeamNumber;                                    		// 0x0508 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsDefender : 1;                                		// 0x050C (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1556 ];

		return pClassPointer;
	};

};

UClass* UTgUIHexWidget_Raid::pClassPointer = NULL;

// Class TgGame.TgUIHexWidget_Zone
// 0x001C (0x0520 - 0x0504)
class UTgUIHexWidget_Zone : public UTgUIHexWidget
{
public:
	unsigned long                                      m_bShowCombat : 1;                                		// 0x0504 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bShowStrategic : 1;                             		// 0x0504 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bShowMyEnemies : 1;                             		// 0x0504 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bShowClosed : 1;                                		// 0x0504 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bShowMyAgency : 1;                              		// 0x0504 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bShowMyAlliance : 1;                            		// 0x0504 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	unsigned long                                      m_bShowBuildings : 1;                             		// 0x0504 (0x0004) [0x0000000000002000] [0x00000040] ( CPF_Transient )
	unsigned long                                      m_bShowOnlyMyBuildings : 1;                       		// 0x0504 (0x0004) [0x0000000000002000] [0x00000080] ( CPF_Transient )
	int                                                m_nPlayerAgencyId;                                		// 0x0508 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nPlayerAllianceId;                              		// 0x050C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nCurrentZoneId;                                 		// 0x0510 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	TArray< struct FHexAgencyData >                    m_AgencyList;                                     		// 0x0514 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1557 ];

		return pClassPointer;
	};

	void UpdateFilters ( int nIndex );
	struct FHexMICParams GetMICParams ( int nIndex );
	void SetRegionHighlightRegion ( int nRegionId, unsigned long bEnabled );
	void SetRegionHighlightAgency ( int nAgencyId, unsigned long bEnabled );
	void ClearRegionHighlight ( );
	void OnClick ( int X, int Y );
	bool GetAgencyData ( int nAgencyId, struct FHexAgencyData* Data );
	bool IsHexFriendlyWithLocalPlayer ( int nIndex );
	bool IsFriendlyWithLocalPlayer ( int nAgencyId );
};

UClass* UTgUIHexWidget_Zone::pClassPointer = NULL;

// Class TgGame.TgUIIconWidget
// 0x001C (0x0448 - 0x042C)
class UTgUIIconWidget : public UUIButton
{
public:
	class UMaterialInstanceConstant*                   m_IconMIC;                                        		// 0x042C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_BgMIC;                                          		// 0x0430 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterial*                                   m_IconMaterialParent;                             		// 0x0434 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bIsSelected : 1;                                		// 0x0438 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bIsUnavailable : 1;                             		// 0x0438 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	class UUIComp_DrawImage*                           m_IconImageComponent;                             		// 0x043C (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                m_nIconId;                                        		// 0x0440 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_nTipMsgId;                                      		// 0x0444 (0x0004) [0x0000000000002000]              ( CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1558 ];

		return pClassPointer;
	};

};

UClass* UTgUIIconWidget::pClassPointer = NULL;

// Class TgGame.TgUIInvWidget
// 0x0028 (0x0454 - 0x042C)
class UTgUIInvWidget : public UUIButton
{
public:
	class UMaterialInstanceConstant*                   m_IconMIC;                                        		// 0x042C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_BgMIC;                                          		// 0x0430 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterial*                                   m_IconMaterialParent;                             		// 0x0434 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTgInventoryObject*                          m_InventoryObject;                                		// 0x0438 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bIsSelected : 1;                                		// 0x043C (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bIsUnavailable : 1;                             		// 0x043C (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bIsAttracting : 1;                              		// 0x043C (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned char                                      m_ItemSubType;                                    		// 0x0440 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FsTimedParameter >                  m_TimedParamList;                                 		// 0x0444 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	class UUIComp_DrawImage*                           m_IconImageComponent;                             		// 0x0450 (0x0004) [0x000000000408000A]              ( CPF_Const | CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1559 ];

		return pClassPointer;
	};

};

UClass* UTgUIInvWidget::pClassPointer = NULL;

// Class TgGame.TgUIMapWidget
// 0x0148 (0x0574 - 0x042C)
class UTgUIMapWidget : public UUIButton
{
public:
	TArray< struct FZoneObjectiveStruct >              m_Objectives;                                     		// 0x042C (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FZonePlayerStruct >                 m_AllyPlayers;                                    		// 0x0438 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FZonePlayerStruct >                 m_TeamPlayers;                                    		// 0x0444 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FZoneVolumeStruct >                 m_SubzoneVolumes;                                 		// 0x0450 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FZoneQuestVolumeStruct >            m_QuestVolumes;                                   		// 0x045C (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FZoneQuestPOIStruct >               m_QuestPOIArea;                                   		// 0x0468 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FZoneQuestPOIStruct >               m_QuestPOI;                                       		// 0x0474 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	TArray< struct FZonePortalStruct >                 m_PortalPoints;                                   		// 0x0480 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	struct FZonePlayerStruct                           m_LocalPlayer;                                    		// 0x048C (0x0020) [0x0000000000002000]              ( CPF_Transient )
	class ATgPlayerController*                         m_PC;                                             		// 0x04AC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	struct FPointer                                    m_HoveredObject;                                  		// 0x04B0 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	struct FPointer                                    m_HoveredSubZone;                                 		// 0x04B4 (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	class UUIImage*                                    m_MapImage;                                       		// 0x04B8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MinX;                                           		// 0x04BC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MinY;                                           		// 0x04C0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MaxX;                                           		// 0x04C4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MaxY;                                           		// 0x04C8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	int                                                m_MapTextureResId;                                		// 0x04CC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_MapTextureUL;                                   		// 0x04D0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              m_MapTextureVL;                                   		// 0x04D4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	unsigned long                                      m_bShowObjectives : 1;                            		// 0x04D8 (0x0004) [0x0000000000002000] [0x00000001] ( CPF_Transient )
	unsigned long                                      m_bShowQuests : 1;                                		// 0x04D8 (0x0004) [0x0000000000002000] [0x00000002] ( CPF_Transient )
	unsigned long                                      m_bShowTeam : 1;                                  		// 0x04D8 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	unsigned long                                      m_bShowPlayer : 1;                                		// 0x04D8 (0x0004) [0x0000000000002000] [0x00000008] ( CPF_Transient )
	unsigned long                                      m_bShowPortalNetwork : 1;                         		// 0x04D8 (0x0004) [0x0000000000002000] [0x00000010] ( CPF_Transient )
	unsigned long                                      m_bRequestedPortalHop : 1;                        		// 0x04D8 (0x0004) [0x0000000000002000] [0x00000020] ( CPF_Transient )
	struct FPointer                                    m_pPortalNetwork;                                 		// 0x04DC (0x0004) [0x0000000000003000]              ( CPF_Native | CPF_Transient )
	class UMaterialInstanceConstant*                   m_IconLocalPlayer;                                		// 0x04E0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_IconTeamPlayer;                                 		// 0x04E4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_IconFriendlyPlayer;                             		// 0x04E8 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_IconObjective;                                  		// 0x04EC (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_IconObjectivePVP;                               		// 0x04F0 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   m_IconPortal;                                     		// 0x04F4 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UTexture2D*                                  m_MapTexture;                                     		// 0x04F8 (0x0004) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class UTexture2D*                                  m_IconTextures[ 0xF ];                            		// 0x04FC (0x003C) [0x0000000000002002]              ( CPF_Const | CPF_Transient )
	class UTexture2D*                                  m_IconTexturesPVP[ 0xF ];                         		// 0x0538 (0x003C) [0x0000000000002002]              ( CPF_Const | CPF_Transient )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1560 ];

		return pClassPointer;
	};

	int GetObjectiveIconSize ( class ATgMissionObjective* Obj );
	void CalcMapFromObjectives ( );
	float GetScreenScale ( );
	struct FVector GetScreenLocation ( struct FVector Location );
	void OnClick ( );
	void OnTick ( );
	void InitializeMap ( class ATgPlayerController* PC );
};

UClass* UTgUIMapWidget::pClassPointer = NULL;

// Class TgGame.TgUIProgressBar
// 0x0007 (0x0480 - 0x0479)
class UTgUIProgressBar : public UUIProgressBar
{
public:
	class UUIComp_DrawImage*                           EnemyFillImageComponent;                          		// 0x047C (0x0004) [0x000000000608000B]              ( CPF_Edit | CPF_Const | CPF_ExportObject | CPF_Component | CPF_NoClear | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1561 ];

		return pClassPointer;
	};

	void SetEnemyFillImage ( class USurface* NewImage );
};

UClass* UTgUIProgressBar::pClassPointer = NULL;

// Class TgGame.TgUIScrollList
// 0x0030 (0x048C - 0x045C)
class UTgUIScrollList : public UUIScrollFrame
{
public:
	TArray< class UUIPrefab* >                         m_ArchetypeTemplates;                             		// 0x045C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UUIPrefabInstance* >                 m_ListMembers;                                    		// 0x0468 (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	int                                                m_ListOffsetBuffer;                               		// 0x0474 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                m_ListElementBuffer;                              		// 0x0478 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< int >                                      m_ArchetypeUsedIndices;                           		// 0x047C (0x000C) [0x0000000000502000]              ( CPF_Transient | CPF_NeedCtorLink )
	unsigned long                                      m_bShowVertSb : 1;                                		// 0x0488 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1562 ];

		return pClassPointer;
	};

	class UUIPrefabInstance* GetListEntry ( int nNum );
	int GetListLength ( );
	void EmptyList ( );
};

UClass* UTgUIScrollList::pClassPointer = NULL;

// Class TgGame.TgUIChatScrollList
// 0x0008 (0x0494 - 0x048C)
class UTgUIChatScrollList : public UTgUIScrollList
{
public:
	unsigned long                                      m_bEntryMode : 1;                                 		// 0x048C (0x0004) [0x0000000000000000] [0x00000001] 
	int                                                m_nNumUsedChats;                                  		// 0x0490 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1563 ];

		return pClassPointer;
	};

	void SetEntryMode ( unsigned long bEntryMode );
	void AddChatMessage ( struct FString msgString, struct FColor msgColor );
	void InitializeChatList ( );
};

UClass* UTgUIChatScrollList::pClassPointer = NULL;

// Class TgGame.TgUISkeletalMeshWidget
// 0x009C (0x04C0 - 0x0424)
class UTgUISkeletalMeshWidget : public UUIMeshWidget
{
public:
	class ASkeletalMeshActor*                          m_BoundActor;                                     		// 0x0424 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bEnableAnimations : 1;                          		// 0x0428 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	unsigned long                                      m_bAdjustForMirror : 1;                           		// 0x0428 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      m_bLoadMeshAssets : 1;                            		// 0x0428 (0x0004) [0x0000000000002000] [0x00000004] ( CPF_Transient )
	float                                              m_PivotAngle;                                     		// 0x042C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_MeshRenderFOV;                                  		// 0x0430 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USkeletalMeshComponent*                      SkeletalMeshComp;                                 		// 0x0434 (0x0004) [0x0000000004082009]              ( CPF_Edit | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	class USkeletalMeshComponent*                      SkeletalMeshComp2;                                		// 0x0438 (0x0004) [0x0000000004082009]              ( CPF_Edit | CPF_ExportObject | CPF_Transient | CPF_Component | CPF_EditInline )
	struct FVector                                     m_MeshTranslation;                                		// 0x043C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_MeshRotation;                                   		// 0x0448 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_Mesh2Translation;                               		// 0x0454 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_Mesh2Rotation;                                  		// 0x0460 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	class ULightComponent*                             DefaultLight;                                     		// 0x046C (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FVector                                     LightDirection;                                   		// 0x0470 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	class ULightComponent*                             DefaultLight2;                                    		// 0x047C (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FVector                                     LightDirection2;                                  		// 0x0480 (0x000C) [0x0000000000000001]              ( CPF_Edit )
	float                                              BaseHeight;                                       		// 0x048C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FMeshAssets                                 c_MeshAssets;                                     		// 0x0490 (0x0030) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1564 ];

		return pClassPointer;
	};

	void LoadClientOnlyMeshAssets ( );
	void TickComponents ( float DeltaSeconds );
	void SetSkeletalMeshComponent ( class USkeletalMeshComponent* SMC );
	void SetSkeletalMeshActor ( class ASkeletalMeshActor* SMActor );
};

UClass* UTgUISkeletalMeshWidget::pClassPointer = NULL;

// Class TgGame.TgGame
// 0x00FC (0x04A4 - 0x03A8)
class ATgGame : public AGameInfo
{
public:
	unsigned long                                      s_bSecuringMode : 1;                              		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bAllowPlayerRelease : 1;                        		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bRaidDefenderFlag : 1;                          		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      m_bAllowOvertime : 1;                             		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      s_bBossTimeIncremented : 1;                       		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      m_bShouldWait : 1;                                		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000020] 
	unsigned long                                      s_bFallbackBeacon : 1;                            		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000040] 
	unsigned long                                      s_bQuietEndMission : 1;                           		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000080] 
	unsigned long                                      m_bIsTutorialMap : 1;                             		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      s_bGameInitialized : 1;                           		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000200] 
	unsigned long                                      s_bGameEndMissionProcessed : 1;                   		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000400] 
	unsigned long                                      s_bMissionSealed : 1;                             		// 0x03A8 (0x0004) [0x0000000000000000] [0x00000800] 
	unsigned long                                      s_bLateBackfillsSealed : 1;                       		// 0x03A8 (0x0004) [0x0000000000000000] [0x00001000] 
	unsigned long                                      s_UseCustomReviveTimer : 1;                       		// 0x03A8 (0x0004) [0x0000000000000000] [0x00002000] 
	unsigned long                                      s_bSixtySecondAlertSent : 1;                      		// 0x03A8 (0x0004) [0x0000000000000000] [0x00004000] 
	unsigned long                                      s_bThirtySecondAlertSent : 1;                     		// 0x03A8 (0x0004) [0x0000000000000000] [0x00008000] 
	unsigned long                                      s_bTenSecondAlertSent : 1;                        		// 0x03A8 (0x0004) [0x0000000000000000] [0x00010000] 
	unsigned long                                      m_bRewardCalculated : 1;                          		// 0x03A8 (0x0004) [0x0000000000000000] [0x00020000] 
	unsigned long                                      m_bStatsCanTie : 1;                               		// 0x03A8 (0x0004) [0x0000000000000000] [0x00040000] 
	unsigned long                                      m_bStatsIsSymmetric : 1;                          		// 0x03A8 (0x0004) [0x0000000000000000] [0x00080000] 
	unsigned long                                      m_bUseSavedInstLoc : 1;                           		// 0x03A8 (0x0004) [0x0000000000044000] [0x00100000] ( CPF_Config | CPF_GlobalConfig )
	unsigned char                                      m_GameWinState;                                   		// 0x03AC (0x0001) [0x0000000000000000]              
	unsigned char                                      m_GameType;                                       		// 0x03AD (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eTimerState;                                    		// 0x03AE (0x0001) [0x0000000000000000]              
	unsigned char                                      m_eTimerStatePaused;                              		// 0x03AF (0x0001) [0x0000000000000000]              
	unsigned char                                      m_AwardedMedal;                                   		// 0x03B0 (0x0001) [0x0000000000000000]              
	float                                              m_fSpawnProtectionTime;                           		// 0x03B4 (0x0004) [0x0000000000000000]              
	int                                                m_iBotIndex;                                      		// 0x03B8 (0x0004) [0x0000000000000000]              
	int                                                m_nSecsToAutoRelease;                             		// 0x03BC (0x0004) [0x0000000000000000]              
	int                                                m_nSecsToAutoReleaseAttackers;                    		// 0x03C0 (0x0004) [0x0000000000000000]              
	int                                                m_nSecsToAutoReleaseDefenders;                    		// 0x03C4 (0x0004) [0x0000000000000000]              
	int                                                m_nRaidDefenderRespawnBonus;                      		// 0x03C8 (0x0004) [0x0000000000000000]              
	int                                                m_nRaidAttackerRespawnBonus;                      		// 0x03CC (0x0004) [0x0000000000000000]              
	float                                              m_fGameSpeedModifier;                             		// 0x03D0 (0x0004) [0x0000000000000000]              
	float                                              m_fMissionTime;                                   		// 0x03D4 (0x0004) [0x0000000000000000]              
	float                                              m_fPausedAtTime;                                  		// 0x03D8 (0x0004) [0x0000000000000000]              
	float                                              m_fGameMissionTime;                               		// 0x03DC (0x0004) [0x0000000000000000]              
	float                                              m_fGameOvertimeTime;                              		// 0x03E0 (0x0004) [0x0000000000000000]              
	float                                              s_fMissionTimerStartedAt;                         		// 0x03E4 (0x0004) [0x0000000000000000]              
	int                                                s_nCurrentPriority;                               		// 0x03E8 (0x0004) [0x0000000000000000]              
	int                                                s_nFirstPriority;                                 		// 0x03EC (0x0004) [0x0000000000000000]              
	int                                                s_nPrevPriority;                                  		// 0x03F0 (0x0004) [0x0000000000000000]              
	class ATgBeaconFactory*                            s_FallbackBeaconExit;                             		// 0x03F4 (0x0004) [0x0000000000000000]              
	int                                                m_nRouteNumber;                                   		// 0x03F8 (0x0004) [0x0000000000000000]              
	float                                              m_fLastAlarmTime;                                 		// 0x03FC (0x0004) [0x0000000000000000]              
	int                                                s_nNextMapGameId;                                 		// 0x0400 (0x0004) [0x0000000000000000]              
	float                                              s_MissionTimeAccumulator;                         		// 0x0404 (0x0004) [0x0000000000000000]              
	int                                                s_nNextPawnId;                                    		// 0x0408 (0x0004) [0x0000000000000000]              
	int                                                s_nNextDeviceInstanceId;                          		// 0x040C (0x0004) [0x0000000000000000]              
	float                                              s_fTimeToSeal;                                    		// 0x0410 (0x0004) [0x0000000000000000]              
	float                                              s_fTimeToSealLateBackfills;                       		// 0x0414 (0x0004) [0x0000000000000000]              
	TArray< class AController* >                       s_AttackerReviveList;                             		// 0x0418 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< class AController* >                       s_DefenderReviveList;                             		// 0x0424 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                s_nForceFieldCount;                               		// 0x0430 (0x0004) [0x0000000000000000]              
	class UTgDebug*                                    m_DebugSettings;                                  		// 0x0434 (0x0004) [0x0000000000000000]              
	TArray< class ATgActorFactory* >                   s_ActorFactories;                                 		// 0x0438 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgSeqEvent_AlarmBots* >             s_SeqEventAlarmBots;                              		// 0x0444 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgSeqAct_AlarmBots* >               s_SeqActAlarmBots;                                		// 0x0450 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UTgSeqEvent_MissionTimeRemaining* >  s_TimerRemainingAlerts;                           		// 0x045C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned char                                      UnknownData00[ 0x3C ];                            		// 0x0468 (0x003C) UNKNOWN PROPERTY: MapProperty TgGame.TgGame.s_PlayerRewardAccum

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1565 ];

		return pClassPointer;
	};

	bool PreventDeath ( class APawn* KilledPawn, class AController* Killer, class UClass* DamageType, struct FVector HitLocation );
	bool CanSpectate ( class APlayerController* Viewer, class APlayerReplicationInfo* ViewTarget );
	unsigned char eventGetMissionTimerStatus ( );
	bool ObjectiveTaken ( class ATgMissionObjective* Objective );
	void SetMissionTimerShouldWait ( unsigned long bWait );
	void eventPostCommitMapChange ( );
	void eventSendMissionTimerNotify ( unsigned char eState, float fRemainingSecs );
	void eventMissionTimerBossIncrement ( );
	void eventMissionTimeIncrement ( float fInc );
	void eventMissionTimerModify ( unsigned long bPause, int nNewTime );
	float eventElapsedTime ( );
	bool eventMissionTimerActive ( );
	void eventChangeTimerState ( unsigned char eTimerState );
	void eventMissionTimer ( );
	void eventMissionTimerPause ( );
	void eventMissionTimerStop ( );
	void eventMissionTimerStart ( );
	void eventSetMissionTime ( float fTime );
	void KeepClientsInSync ( );
	void StartGameTimer ( );
	void eventAwardMedal ( unsigned char newMedalStatus );
	struct FString GetAwardStringByType ( unsigned char medal );
	void eventPostLogin ( class APlayerController* NewPlayer );
	bool FindInactivePRI ( class APlayerController* PC );
	void AddInactivePRI ( class APlayerReplicationInfo* PRI, class APlayerController* PC );
	void RestartGame ( );
	void PlayClientMessage ( struct FString theMessage );
	void PlayStartupMessage ( );
	int GetBotIndex ( );
	void EndGame ( class APlayerReplicationInfo* Winner, struct FString Reason );
	void StartMatch ( );
	bool ChangeTeam ( class AController* Other, int Num, unsigned long bNewTeam );
	float RatePlayerStart ( class APlayerStart* P, unsigned char Team, class AController* Player );
	float eventRatePlayerStartPoint ( class APlayerStart* P, class AController* Player );
	class ANavigationPoint* FindPlayerGroupStart ( class AController* Player, int groupNumber, unsigned char InTeam, struct FString IncomingName );
	class ANavigationPoint* FindPlayerStart ( class AController* Player, unsigned char InTeam, struct FString IncomingName );
	class ANavigationPoint* GetReviveLocation ( class AController* Player, struct FVector* OutLocation, struct FRotator* OutRotation );
	class ANavigationPoint* eventFindPlayerStartPoint ( class AController* Player, struct FString SpawnTagName );
	void SetPlayerDefaults ( class APawn* PlayerPawn );
	void AddDefaultInventory ( class APawn* PlayerPawn );
	void RestartPlayer ( class AController* aPlayer );
	void eventAllPlayersEndGame ( class ACameraActor* Camera );
	class APlayerController* eventLogin ( struct FString Portal, struct FString Options, struct FString* ErrorMessage );
	class APawn* SpawnDefaultPawnFor ( class AController* NewPlayer, class ANavigationPoint* StartSpot );
	void StartBots ( );
	void eventInitGame ( struct FString Options, struct FString* ErrorMessage );
	float GetSetupTime ( );
	void SetGameSpeed ( float T );
	int GeneratePlayerId ( );
	class UClass* eventSetGameType ( struct FString MapName, struct FString Options, struct FString Portal );
	void Reset ( );
	int eventGetNextDeviceInstanceId ( );
	int eventGetNextPawnId ( );
	bool GameHasForceField ( );
	void InitGameReplicationInfo ( );
	void eventPostBeginPlay ( );
	void ResetAlertsForExtendedTime ( );
	int GetReviveTimeRemaining ( class AController* C );
	float CalcDefenderReviveTime ( );
	float CalcAttackerReviveTime ( );
	void ReviveDefendersTimer ( );
	void ReviveAttackersTimer ( );
	void UnRegisterForWaveRevive ( class AController* C );
	void RegisterForWaveRevive ( class AController* C );
	int GetRouteNumber ( );
	float GetDifficultyModifier ( int nPriority );
	void SpawnAllHenchman ( );
	float MissionTimeRemaining ( );
	void SendObjectivesOvertimeNotify ( );
	void SetObjectivesInactive ( );
	void UpdateMissionTimerEventWinVar ( );
	void SendMissionTimerEvent ( int nEventId );
	bool IsFinalObjective ( class ATgMissionObjective* Objective );
	TArray< class ATgMissionObjective* > GetFinalObjectivesList ( );
	void SpawnLandMarks ( );
	void AdjustBeaconForwardSpawn ( int nPriority );
	void LockoutObjectives ( int nPriority );
	void CheckRandomObjectives ( );
	void UnlockObjective ( int nPrority );
	void NotifyPostCommitMapChange ( );
	void SetDeployPointAssociation ( );
	struct FString GetGameVersion ( );
	void DeactivateAlarm ( class AActor* Originator, int nGlobalAlarmId, struct FString sTypeCode );
	void ActivateAlarm ( class AActor* Originator, int nGlobalAlarmId, struct FString sTypeCode );
	void BuildAlarmsArray ( );
	class APawn* SpawnTemplatePlayer ( class ATgPlayerController* pTgPC, struct FName sName );
	class APawn* SpawnBotPawn ( class ATgAIController* pTgAI, struct FVector vLocation, struct FRotator rRotation, unsigned long bIgnoreCollision, class ATgPawn* pOwnerPawn, unsigned long bIsDecoy, float fDeploySecs );
	class APawn* SpawnBotById ( int nBotId, struct FVector vLocation, struct FRotator rRotation, unsigned long bKillController, class ATgBotFactory* pFactory, unsigned long bIgnoreCollision, class ATgPawn* pOwnerPawn, unsigned long bIsDecoy, class UTgDeviceFire* deviceFire, float fDeployAnimLength );
	class APawn* SpawnBot ( struct FName sName, struct FVector vLocation, struct FRotator rRotation, class ATgBotFactory* pFactory, unsigned long bIgnoreCollision, class ATgPawn* pOwnerPawn, unsigned long bIsDecoy, class UTgDeviceFire* deviceFire, float fDeploySecs );
	bool IsOpenWorld ( );
	bool IsTerritory ( );
	bool IsTutorial ( );
	bool IsTraining ( );
	bool IsMission ( );
	void Loot ( int nLootTableId, struct FVector vBaseLocation, int nTaskForce );
	void DbUpdateQuests ( );
	void DbSaveReward ( );
	void CalcAndAwardMedal ( );
	bool FinishEndMission ( );
	bool BeginEndMission ( unsigned long bClearNextMapGame, class ACameraActor* endMissionCamera, float fDelayOverride );
	int GetWinningTaskforce ( );
	class APawn* SpawnPlayerCharacter ( class ATgPlayerController* pTgPC, struct FVector vLocation );
	void eventSendCombatMessage ( int nMsgId, class AActor* Source, class AActor* Target, int nAmount1, int nAmount2 );
	bool TgFindPlayerSpawnLocation ( class AController* pPlayer, struct FVector* vLoc );
	class ANavigationPoint* TgFindPlayerStart ( class AController* pPlayer, struct FString fsIncomingName );
	void InitGameRepInfo ( );
	void LoadGameConfig ( );
};

UClass* ATgGame::pClassPointer = NULL;

// Class TgGame.TgGame_City
// 0x0000 (0x04A4 - 0x04A4)
class ATgGame_City : public ATgGame
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1566 ];

		return pClassPointer;
	};

	class APawn* SpawnDefaultPawnFor ( class AController* NewPlayer, class ANavigationPoint* StartSpot );
};

UClass* ATgGame_City::pClassPointer = NULL;

// Class TgGame.TgGame_Mission
// 0x0010 (0x04B4 - 0x04A4)
class ATgGame_Mission : public ATgGame
{
public:
	unsigned long                                      m_bSpawnInTaskForceArea : 1;                      		// 0x04A4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bScoreTeamKills : 1;                            		// 0x04A4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bOverTimeBroadcast : 1;                         		// 0x04A4 (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                m_nPlayerKillValue;                               		// 0x04A8 (0x0004) [0x0000000000000000]              
	int                                                s_nPointsNeeded;                                  		// 0x04AC (0x0004) [0x0000000000000000]              
	int                                                s_nHighestPointCount;                             		// 0x04B0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1567 ];

		return pClassPointer;
	};

	bool CheckScore ( class APlayerReplicationInfo* Scorer );
	void ScoreKill ( class AController* Killer, class AController* Other );
	void AddObjectiveScore ( class APlayerReplicationInfo* Scorer, int Score );
	void StartMatch ( );
	void LoadGameConfig ( );
};

UClass* ATgGame_Mission::pClassPointer = NULL;

// Class TgGame.TgGame_Arena
// 0x0014 (0x04C8 - 0x04B4)
class ATgGame_Arena : public ATgGame_Mission
{
public:
	int                                                s_nRoundNumber;                                   		// 0x04B4 (0x0004) [0x0000000000000000]              
	int                                                s_nBetweenRoundDelay;                             		// 0x04B8 (0x0004) [0x0000000000000000]              
	int                                                s_nRoundSetupTime;                                		// 0x04BC (0x0004) [0x0000000000000000]              
	int                                                s_nObjectiveUnlockDelay;                          		// 0x04C0 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bResetPlayfieldBetweenRounds : 1;               		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bResetPlayersBetweenRounds : 1;                 		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      s_bDisplayEndRoundScreen : 1;                     		// 0x04C4 (0x0004) [0x0000000000000000] [0x00000004] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1568 ];

		return pClassPointer;
	};

	bool ObjectiveTaken ( class ATgMissionObjective* Objective );
	void eventMissionTimer ( );
	void eventResetPlayField ( );
	void eventResetObjectives ( );
	void eventRespawnPlayers ( );
	void eventMissionTimerBossIncrement ( );
	void StartGameTimer ( );
	void eventObjectiveUnlock ( );
	void eventNextRoundStart ( );
	void eventPreRoundFinished ( );
	void eventGameStarted ( );
	void eventPostBeginPlay ( );
	bool eventCheckWinGame ( unsigned long bForceWin, class ATgRepInfo_TaskForce** Winner );
	bool eventCheckWinRound ( class ATgRepInfo_TaskForce** Winner );
	void FinalizeGameScore ( class ATgRepInfo_TaskForce* Winner );
	void FinalizeRoundScore ( class ATgRepInfo_TaskForce* Winner );
	void AdjustBeaconForwardSpawn ( int nPriority );
	void LoadGameConfig ( );
};

UClass* ATgGame_Arena::pClassPointer = NULL;

// Class TgGame.TgGame_CTF
// 0x0000 (0x04C8 - 0x04C8)
class ATgGame_CTF : public ATgGame_Arena
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1569 ];

		return pClassPointer;
	};

	void OvertimeIsOverTester ( );
	void Tick ( float DeltaTime );
	void eventMissionTimer ( );
	bool CheckOvertime ( );
	bool ObjectiveTaken ( class ATgMissionObjective* Objective );
	bool eventCheckWinRound ( class ATgRepInfo_TaskForce** Winner );
};

UClass* ATgGame_CTF::pClassPointer = NULL;

// Class TgGame.TgGame_Defense
// 0x0014 (0x04DC - 0x04C8)
class ATgGame_Defense : public ATgGame_Arena
{
public:
	TArray< class UTgSeqAct_DefenseWaveSpawner* >      s_WaveSpawnerList;                                		// 0x04C8 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                s_nMaxRoundNumber;                                		// 0x04D4 (0x0004) [0x0000000000000000]              
	float                                              s_fRoundDuration;                                 		// 0x04D8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1570 ];

		return pClassPointer;
	};

	void eventResetObjectives ( );
	bool ObjectiveTaken ( class ATgMissionObjective* Objective );
	void eventRoundTimer ( );
	void eventPostBeginPlay ( );
	float GetRoundDuration ( int nRoundNumber );
	void SendNewRoundMessage ( );
	void LockoutObjectives ( int nPriority );
	void UnlockObjective ( int nPriority );
	void FinalizeRoundScore ( class ATgRepInfo_TaskForce* Winner );
	void LoadGameConfig ( );
	void TickWaveNodes ( );
	void CacheKismetConfiguration ( );
	bool eventCheckWinRound ( class ATgRepInfo_TaskForce** Winner );
	bool eventCheckWinGame ( unsigned long bForceWin, class ATgRepInfo_TaskForce** Winner );
};

UClass* ATgGame_Defense::pClassPointer = NULL;

// Class TgGame.TgGame_PointRotation
// 0x0008 (0x04D0 - 0x04C8)
class ATgGame_PointRotation : public ATgGame_Arena
{
public:
	class ATgMissionObjective*                         m_NextObjective;                                  		// 0x04C8 (0x0004) [0x0000000000000000]              
	class ATgMissionObjective*                         m_PreviousObjective;                              		// 0x04CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1571 ];

		return pClassPointer;
	};

	void SetMissionTimerShouldWait ( unsigned long bWait );
	void UpdateShouldWait ( );
	bool eventCheckWinRound ( class ATgRepInfo_TaskForce** Winner );
	void UnlockObjective ( int nPriority );
	void CalcNextObjective ( );
};

UClass* ATgGame_PointRotation::pClassPointer = NULL;

// Class TgGame.TgGame_Control
// 0x0010 (0x04C4 - 0x04B4)
class ATgGame_Control : public ATgGame_Mission
{
public:
	float                                              m_fCurrentCountdownTime;                          		// 0x04B4 (0x0004) [0x0000000000000000]              
	float                                              m_fControlTimeToWin;                              		// 0x04B8 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bCountdownEnabled : 1;                          		// 0x04BC (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fObjectiveRespawnTimeAdjust;                    		// 0x04C0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1572 ];

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void SetMissionTimerShouldWait ( unsigned long bWait );
	bool ObjectiveTaken ( class ATgMissionObjective* Objective );
	void SendCountdownRemainingMessages ( float oldTimeRemaining, float newTimeRemaining );
	float CalcDefenderReviveTime ( );
	float CalcAttackerReviveTime ( );
	void TickCountdownCalculation ( float DeltaTime );
};

UClass* ATgGame_Control::pClassPointer = NULL;

// Class TgGame.TgGame_Escort
// 0x0000 (0x04B4 - 0x04B4)
class ATgGame_Escort : public ATgGame_Mission
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1573 ];

		return pClassPointer;
	};

};

UClass* ATgGame_Escort::pClassPointer = NULL;

// Class TgGame.TgGame_Ticket
// 0x000C (0x04C0 - 0x04B4)
class ATgGame_Ticket : public ATgGame_Mission
{
public:
	float                                              m_fTicketTickDelay;                               		// 0x04B4 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bDefendersAhead : 1;                            		// 0x04B8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bTeamsTied : 1;                                 		// 0x04B8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bTicketCountReached : 1;                        		// 0x04B8 (0x0004) [0x0000000000000000] [0x00000004] 
	int                                                m_nTfControlledLast;                              		// 0x04BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1574 ];

		return pClassPointer;
	};

	void eventMissionTimer ( );
	void SetMissionTimerShouldWait ( unsigned long bWait );
	bool ObjectiveTaken ( class ATgMissionObjective* Objective );
	void PostBeginPlay ( );
	bool BeginEndMission ( unsigned long bClearNextMapGame, class ACameraActor* endMissionCamera, float fDelayOverride );
	void LoadGameConfig ( );
	void UpdateGameWinState ( );
	void AwardTickets ( );
	void TickTicketsCalculation ( );
};

UClass* ATgGame_Ticket::pClassPointer = NULL;

// Class TgGame.TgGame_DualCTF
// 0x0004 (0x04C4 - 0x04C0)
class ATgGame_DualCTF : public ATgGame_Ticket
{
public:
	unsigned long                                      s_bNeedsToTickTickets : 1;                        		// 0x04C0 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1575 ];

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	bool ObjectiveTaken ( class ATgMissionObjective* Objective );
	void PostBeginPlay ( );
	void UpdateGameWinState ( );
	void AwardTickets ( );
};

UClass* ATgGame_DualCTF::pClassPointer = NULL;

// Class TgGame.TgGame_OpenWorld
// 0x000C (0x04B0 - 0x04A4)
class ATgGame_OpenWorld : public ATgGame
{
public:
	TArray< class ATgObjectiveAssignment* >            s_ObjectiveAssignments;                           		// 0x04A4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1576 ];

		return pClassPointer;
	};

	void eventPostBeginPlay ( );
	bool ObjectiveTaken ( class ATgMissionObjective* Objective );
	class ANavigationPoint* TgFindPlayerStart ( class AController* pPlayer, struct FString fsIncomingName );
	void InitGameRepInfo ( );
	void AdjustBeaconForwardSpawn ( int nPriority );
	void LockoutObjectives ( int nPriority );
	void UnlockObjective ( int nPrority );
};

UClass* ATgGame_OpenWorld::pClassPointer = NULL;

// Class TgGame.TgGame_OpenWorldPVE
// 0x0000 (0x04B0 - 0x04B0)
class ATgGame_OpenWorldPVE : public ATgGame_OpenWorld
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1577 ];

		return pClassPointer;
	};

};

UClass* ATgGame_OpenWorldPVE::pClassPointer = NULL;

// Class TgGame.TgGame_OpenWorldPVP
// 0x0010 (0x04C0 - 0x04B0)
class ATgGame_OpenWorldPVP : public ATgGame_OpenWorld
{
public:
	float                                              m_fTicketTickDelay;                               		// 0x04B0 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_CurrentWinner;                                  		// 0x04B4 (0x0001) [0x0000000000000000]              
	unsigned long                                      m_bTicketCountReached : 1;                        		// 0x04B8 (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fShieldThreshold;                               		// 0x04BC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1578 ];

		return pClassPointer;
	};

	void eventMissionTimer ( );
	void SetMissionTimerShouldWait ( unsigned long bWait );
	void eventPostBeginPlay ( );
	bool BeginEndMission ( unsigned long bClearNextMapGame, class ACameraActor* endMissionCamera, float fDelayOverride );
	bool ObjectiveTaken ( class ATgMissionObjective* Objective );
	void LoadGameConfig ( );
	void UpdateGameWinState ( );
	void AwardTickets ( );
	void TickTicketsCalculation ( );
};

UClass* ATgGame_OpenWorldPVP::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Deployable
// 0x0024 (0x01F0 - 0x01CC)
class ATgRepInfo_Deployable : public AReplicationInfo
{
public:
	int                                                r_nHealthCurrent;                                 		// 0x01CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nHealthMaximum;                                 		// 0x01D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fDeployMaxHealthPCT;                            		// 0x01D4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nDeployableId;                                  		// 0x01D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nUniqueDeployableId;                            		// 0x01DC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgDeployable*                               r_DeployableOwner;                                		// 0x01E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Player*                           r_InstigatorInfo;                                 		// 0x01E4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_TaskForce*                        r_TaskforceInfo;                                  		// 0x01E8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bOwnedByTaskforce : 1;                          		// 0x01EC (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      c_bReceivedOwner : 1;                             		// 0x01EC (0x0004) [0x0000000000000000] [0x00000002] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1579 ];

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void eventDestroyed ( );
	void eventPostBeginPlay ( );
	void SetTaskForce ( class ATgRepInfo_TaskForce* tf );
};

UClass* ATgRepInfo_Deployable::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Beacon
// 0x001C (0x020C - 0x01F0)
class ATgRepInfo_Beacon : public ATgRepInfo_Deployable
{
public:
	struct FString                                     r_nName;                                          		// 0x01F0 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FVector                                     r_vLoc;                                           		// 0x01FC (0x000C) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bDeployed : 1;                                  		// 0x0208 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1580 ];

		return pClassPointer;
	};

};

UClass* ATgRepInfo_Beacon::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Game
// 0x01DC (0x043C - 0x0260)
class ATgRepInfo_Game : public AGameReplicationInfo
{
public:
	unsigned char                                      r_GameType;                                       		// 0x0260 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nMissionTimerState;                             		// 0x0261 (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      r_bIsRaid : 1;                                    		// 0x0264 (0x0004) [0x0000000000000020] [0x00000001] ( CPF_Net )
	unsigned long                                      r_bIsMission : 1;                                 		// 0x0264 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      r_bIsPVP : 1;                                     		// 0x0264 (0x0004) [0x0000000000000020] [0x00000004] ( CPF_Net )
	unsigned long                                      r_bIsTraining : 1;                                		// 0x0264 (0x0004) [0x0000000000000020] [0x00000008] ( CPF_Net )
	unsigned long                                      r_bIsTutorialMap : 1;                             		// 0x0264 (0x0004) [0x0000000000000020] [0x00000010] ( CPF_Net )
	unsigned long                                      r_bIsArena : 1;                                   		// 0x0264 (0x0004) [0x0000000000000020] [0x00000020] ( CPF_Net )
	unsigned long                                      r_bIsMatch : 1;                                   		// 0x0264 (0x0004) [0x0000000000000020] [0x00000040] ( CPF_Net )
	unsigned long                                      r_bIsTerritoryMap : 1;                            		// 0x0264 (0x0004) [0x0000000000000020] [0x00000080] ( CPF_Net )
	unsigned long                                      r_bIsOpenWorld : 1;                               		// 0x0264 (0x0004) [0x0000000000000000] [0x00000100] 
	unsigned long                                      r_bAllowBuildMorale : 1;                          		// 0x0264 (0x0004) [0x0000000000000020] [0x00000200] ( CPF_Net )
	unsigned long                                      r_bActiveCombat : 1;                              		// 0x0264 (0x0004) [0x0000000000000020] [0x00000400] ( CPF_Net )
	unsigned long                                      r_bAllowPlayerRelease : 1;                        		// 0x0264 (0x0004) [0x0000000000000020] [0x00000800] ( CPF_Net )
	unsigned long                                      r_bDefenseAlarm : 1;                              		// 0x0264 (0x0004) [0x0000000000000020] [0x00001000] ( CPF_Net )
	unsigned long                                      r_bInOverTime : 1;                                		// 0x0264 (0x0004) [0x0000000000000020] [0x00002000] ( CPF_Net )
	float                                              s_fActiveCombatTime;                              		// 0x0268 (0x0004) [0x0000000000000000]              
	int                                                r_nSecsToAutoReleaseAttackers;                    		// 0x026C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nSecsToAutoReleaseDefenders;                    		// 0x0270 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nReleaseDelay;                                  		// 0x0274 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fGameSpeedModifier;                             		// 0x0278 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nPointsToWin;                                   		// 0x027C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nVictoryBonusLives;                             		// 0x0280 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nRaidDefenderRespawnBonus;                      		// 0x0284 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nRaidAttackerRespawnBonus;                      		// 0x0288 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fMissionRemainingTime;                          		// 0x028C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMissionTimerStateChange;                       		// 0x0290 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fMissionTime;                                   		// 0x0294 (0x0004) [0x0000000000000000]              
	float                                              c_fMissionTimeSeconds;                            		// 0x0298 (0x0004) [0x0000000000000000]              
	int                                                r_nRoundNumber;                                   		// 0x029C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nMaxRoundNumber;                                		// 0x02A0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_fServerTimeLastUpdate;                          		// 0x02A4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fLocalTimeLastUpdate;                           		// 0x02A8 (0x0004) [0x0000000000000000]              
	class ATgRepInfo_TaskForce*                        r_Winner;                                         		// 0x02AC (0x0004) [0x0000000000000000]              
	int                                                r_nAutoKickTimeout;                               		// 0x02B0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgDeployable* >                     m_Deployables;                                    		// 0x02B4 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< class ATgProjectile* >                     m_Projectiles;                                    		// 0x02C0 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< class ATgMissionObjective* >               m_MissionObjectives;                              		// 0x02CC (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	TArray< class ATgRepInfo_Deployable* >             m_DRIArray;                                       		// 0x02D8 (0x000C) [0x0000000000500000]              ( CPF_NeedCtorLink )
	int                                                s_DeployableIdAssignmentIndex;                    		// 0x02E4 (0x0004) [0x0000000000000000]              
	class ATgMissionObjective*                         r_Objectives[ 0x4B ];                             		// 0x02E8 (0x012C) [0x0000000000000020]              ( CPF_Net )
	struct FMiniMapInfo                                r_MiniMapInfo;                                    		// 0x0414 (0x001C) [0x0000000000000020]              ( CPF_Net )
	struct FMapLogoResIdInfo                           r_MapLogoResIds;                                  		// 0x0430 (0x0008) [0x0000000000000020]              ( CPF_Net )
	struct FPointer                                    s_pRandomSMSettings;                              		// 0x0438 (0x0004) [0x0000000000001000]              ( CPF_Native )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1581 ];

		return pClassPointer;
	};

	bool IsOpenPveMission ( );
	bool eventIsPvPMission ( );
	bool eventIsPvEMission ( );
	void RemoveDRI ( class ATgRepInfo_Deployable* DRI );
	void AssignUniqueDeployableId ( class ATgRepInfo_Deployable* DRI );
	void AddDRI ( class ATgRepInfo_Deployable* DRI );
	void MissionTimeUpdateAllClients ( );
	void UpdateMissionTimer ( );
	void InitMissionTime ( );
	void ClientRespawnTimerDefenders ( );
	void ClientRespawnTimerAttackers ( );
	float eventGetApproxRespawnTimeRemaining ( unsigned long bAttacker );
	void ServerUpdateTimer ( );
	void eventPostBeginPlay ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool IsObjectiveInList ( class ATgMissionObjective* ObjectivePoint );
	void AddObjectivePointToList ( class ATgMissionObjective* ObjectivePoint );
	float GetApproximateServerTime ( );
	void UpdateDefenseAlarm ( );
	bool CheckIsEnemy ( class AActor* A, class AActor* B );
	bool TaskForceEnumerate ( unsigned long bPlayerOnly, class ATgRepInfo_TaskForce** rpTaskForce, int* rnTaskForceNum );
	class ATgRepInfo_TaskForce* CreateTaskForce ( int nTaskForceNum, int nCoalition );
	class ATgRepInfo_TaskForce* GetTaskForce ( int nTaskForceNum, unsigned long bCreate );
	class ATgRepInfo_TaskForce* GetTaskForceFor ( class AActor* Actor );
	class ATgProjectile* GetProjectile ( int nIndex );
	class ATgDeployable* GetDeployable ( int nIndex );
};

UClass* ATgRepInfo_Game::pClassPointer = NULL;

// Class TgGame.TgRepInfo_GameOpenWorld
// 0x000C (0x0448 - 0x043C)
class ATgRepInfo_GameOpenWorld : public ATgRepInfo_Game
{
public:
	int                                                r_GameTickets[ 0x3 ];                             		// 0x043C (0x000C) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1582 ];

		return pClassPointer;
	};

	bool CheckIsEnemy ( class AActor* A, class AActor* B );
	unsigned char GetCoalitionFor ( class AActor* Actor );
};

UClass* ATgRepInfo_GameOpenWorld::pClassPointer = NULL;

// Class TgGame.TgRepInfo_Player
// 0x0424 (0x0694 - 0x0270)
class ATgRepInfo_Player : public APlayerReplicationInfo
{
public:
	int                                                r_nCharacterId;                                   		// 0x0270 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              c_fLastUpdateTime;                                		// 0x0274 (0x0004) [0x0000000000000000]              
	int                                                r_nHealthCurrent;                                 		// 0x0278 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nHealthMaximum;                                 		// 0x027C (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_ApproxLocation;                                 		// 0x0280 (0x000C) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Player*                           r_MasterPrep;                                     		// 0x028C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_TaskForce*                        r_TaskForce;                                      		// 0x0290 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class ATgPawn* >                           s_AutoTaggedPawns;                                		// 0x0294 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgRepInfo_Player* >                 m_PRIArray;                                       		// 0x02A0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class ATgRepInfo_Deployable* >             m_DRIArray;                                       		// 0x02AC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgRepInfo_Player*                           c_PriorMasterPrep;                                		// 0x02B8 (0x0004) [0x0000000000000000]              
	class ATgRepInfo_TaskForce*                        c_PriorTaskForce;                                 		// 0x02BC (0x0004) [0x0000000000000000]              
	struct FEquipDeviceInfo                            r_EquipDeviceInfo[ 0x19 ];                        		// 0x02C0 (0x012C) [0x0000000000000020]              ( CPF_Net )
	struct FCustomCharacterAssembly                    r_CustomCharacterAssembly;                        		// 0x03EC (0x0044) [0x0000000000000020]              ( CPF_Net )
	class UTgObjectReferencer*                         c_pDeviceObjRefs[ 0x19 ];                         		// 0x0430 (0x0064) [0x0000000000000000]              
	class UTgManifestGroup*                            c_pFlairManifestGroup;                            		// 0x0494 (0x0004) [0x0000000004400008]              ( CPF_ExportObject | CPF_NeedCtorLink | CPF_EditInline )
	int                                                r_eBonusType;                                     		// 0x0498 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_Scores[ 0xB ];                                  		// 0x049C (0x002C) [0x0000000000000020]              ( CPF_Net )
	struct FDeviceStatInfo                             r_DeviceStats[ 0x9 ];                             		// 0x04C8 (0x018C) [0x0000000000000020]              ( CPF_Net )
	unsigned long                                      c_bSpeaking : 1;                                  		// 0x0654 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bDropped : 1;                                   		// 0x0654 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	float                                              c_fLastSpeakingTime;                              		// 0x0658 (0x0004) [0x0000000000000000]              
	class UTgSpriteComponent*                          c_SpriteComponent;                                		// 0x065C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	int                                                r_nLevel;                                         		// 0x0660 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nProfileId;                                     		// 0x0664 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FString                                     r_sOrigPlayerName;                                		// 0x0668 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FString                                     r_sAgencyName;                                    		// 0x0674 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	struct FString                                     r_sAllianceName;                                  		// 0x0680 (0x000C) [0x0000000000400020]              ( CPF_Net | CPF_NeedCtorLink )
	int                                                r_nTitleMsgId;                                    		// 0x068C (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgPawn*                                     r_PawnOwner;                                      		// 0x0690 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1583 ];

		return pClassPointer;
	};

	class ATgPlayerController* GetLocalPlayerController ( );
	bool ShouldBroadCastWelcomeMessage ( unsigned long bExiting );
	class ATgPawn* FindLocalPlayerPawn ( );
	void eventReplicatedEvent ( struct FName VarName );
	unsigned char GetTaskForceNumber ( );
	void PostScore ( float fScore );
	void eventUpdateHealth ( int nCurrentHealth, int nMaxHealth );
	void UpdatePlayerLocation ( );
	void eventUpdateIdAndProfile ( );
	void eventTimer ( );
	void ResetPlayerName ( );
	void SetOrigPlayerName ( struct FString S );
	void PreBeginPlay ( );
	void OnAllFlairManifestsLoaded ( );
	void UpdateDeviceAssetRefs ( );
	void UpdateCharacterAssetRefs ( );
	struct FString GetPlayerNameForMsgDisplay ( );
	struct FVector GetCurrentLocation ( );
	int GetCurrentHealth ( );
	void CheckMembership ( );
	void RemoveMinion ( class AReplicationInfo* pRepInfo );
	void AddMinion ( class AReplicationInfo* pRepInfo );
	void SetTeam ( class ATgRepInfo_TaskForce* pNewTeamRep );
	void UpdateLevel ( );
	void UpdateScoreBoard ( );
	void OnProfileChanged ( );
	int GetCharacterId ( );
	bool IsBot ( );
	bool IsFriendlyWithLocalPlayer ( );
};

UClass* ATgRepInfo_Player::pClassPointer = NULL;

// Class TgGame.TgRepInfo_TaskForce
// 0x007C (0x0264 - 0x01E8)
class ATgRepInfo_TaskForce : public ATeamInfo
{
public:
	struct FString                                     c_fsName;                                         		// 0x01E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	int                                                r_nTeamId;                                        		// 0x01F4 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nLeaderCharId;                                  		// 0x01F8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_nTaskForce;                                     		// 0x01FC (0x0001) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_eCoalition;                                     		// 0x01FD (0x0001) [0x0000000000000020]              ( CPF_Net )
	int                                                s_nTaskForceChatId;                               		// 0x0200 (0x0004) [0x0000000000000000]              
	int                                                s_nStrikeForceId;                                 		// 0x0204 (0x0004) [0x0000000000000000]              
	int                                                s_nTaskTeamNum;                                   		// 0x0208 (0x0004) [0x0000000000000000]              
	struct FColor                                      m_Color;                                          		// 0x020C (0x0004) [0x0000000000000000]              
	int                                                s_nPlayerStartCount;                              		// 0x0210 (0x0004) [0x0000000000000000]              
	TArray< struct FTGTEAM_ENTRY >                     m_TeamPlayers;                                    		// 0x0214 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< struct FTGTEAM_ENTRY >                     m_TeamBots;                                       		// 0x0220 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bDestroyOnEmpty : 1;                            		// 0x022C (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bBotOwned : 1;                                  		// 0x022C (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	class ATgMissionObjective*                         r_CurrActiveObjective;                            		// 0x0230 (0x0004) [0x0000000000000020]              ( CPF_Net )
	struct FVector                                     r_LocationSpawnPoint;                             		// 0x0234 (0x000C) [0x0000000000000000]              
	int                                                r_nCurrentPointCount;                             		// 0x0240 (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nNumDeaths;                                     		// 0x0244 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgTeamBeaconManager*                        r_BeaconManager;                                  		// 0x0248 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgInventoryManager*                         s_InventoryManager;                               		// 0x024C (0x0004) [0x0000000000000000]              
	TArray< class ATgHexItemFactory* >                 s_ItemFactoryList;                                		// 0x0250 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class ATgObjectiveAssignment*                      r_ObjectiveAssignment;                            		// 0x025C (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              r_nLookingForMembers;                             		// 0x0260 (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1584 ];

		return pClassPointer;
	};

	void NotifyInactive ( );
	class ATgPlayerController* FindLocalPlayerController ( );
	void eventReplicatedEvent ( struct FName VarName );
	bool HasActivePlayers ( );
	void RemoveFromTeam ( class AController* Other );
	void eventPostInit ( );
	void UpdateHexFactoryList ( );
	void PopulateHexFactoryList ( );
	class ATgTeamBeaconManager* GetBeaconManager ( );
	int GetOpenPlayerSlots ( );
	void TeamRemoveFrom ( class AController* Other );
	bool IsLeader ( class ATgRepInfo_Player* pTgPri );
	class ATgRepInfo_Player* GetBot ( int nIndex );
	class ATgRepInfo_Player* GetPlayer ( int nIndex );
	int GetBotCount ( );
	int GetPlayerCount ( );
	void AddDeath ( );
	bool RepEvent ( struct FName VarName );
	bool IsDefender ( );
	bool IsAttacker ( );
	class ATgRepInfo_Player* CycleFrom ( class ATgRepInfo_Player* pFrom, unsigned long bForward );
};

UClass* ATgRepInfo_TaskForce::pClassPointer = NULL;

// Class TgGame.TgTeamBeaconManager
// 0x0030 (0x01FC - 0x01CC)
class ATgTeamBeaconManager : public AReplicationInfo
{
public:
	class ATgRepInfo_TaskForce*                        r_TaskForce;                                      		// 0x01CC (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_BeaconDestroyed;                                		// 0x01D0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	unsigned char                                      r_BeaconStatus;                                   		// 0x01D4 (0x0001) [0x0000000000000020]              ( CPF_Net )
	class ATgDeploy_Beacon*                            r_Beacon;                                         		// 0x01D8 (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Player*                           r_BeaconHolder;                                   		// 0x01DC (0x0004) [0x0000000000000020]              ( CPF_Net )
	class ATgRepInfo_Beacon*                           r_BeaconInfo;                                     		// 0x01E0 (0x0004) [0x0000000000000020]              ( CPF_Net )
	float                                              s_fHealthPercent;                                 		// 0x01E4 (0x0004) [0x0000000000000000]              
	class UTgHexItemInstance*                          s_HexItem;                                        		// 0x01E8 (0x0004) [0x0000000000000000]              
	unsigned long                                      s_bUsingBeaconInventory : 1;                      		// 0x01EC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      s_bAutoAdjustingBeacon : 1;                       		// 0x01EC (0x0004) [0x0000000000000000] [0x00000002] 
	TArray< class ATgBeaconFactory* >                  s_BeaconFactoryList;                              		// 0x01F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 1585 ];

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void eventInitFor ( class ATgRepInfo_TaskForce* tf );
	void SetHealthPercent ( float fPercent );
	void SetHexItem ( class UTgHexItemInstance* newHexItem );
	bool LoadInventoryBeacon ( );
	int GetExitDeployableId ( );
	int GetEntranceDeployableId ( );
	void BeaconDestroyedClient ( );
	void PopulateBeaconFactoryList ( );
	bool UnRegisterBeacon ( class ATgDeploy_Beacon* pBeacon );
	bool RegisterBeacon ( class ATgDeploy_Beacon* pBeacon, unsigned long bDeployed );
	bool CheckBeacon ( unsigned long bAttemptRespawn );
	bool ShouldSpawnBeacon ( );
	void SpawnNewBeaconForTeam ( );
	class ATgDeploy_Beacon* GetBeacon ( );
};

UClass* ATgTeamBeaconManager::pClassPointer = NULL;

// Class TgGame.TgActorFactoryFracturedStaticMesh
// 0x0000 (0x0068 - 0x0068)
class UTgActorFactoryFracturedStaticMesh : public UActorFactoryFracturedStaticMesh
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 31117 ];

		return pClassPointer;
	};

};

UClass* UTgActorFactoryFracturedStaticMesh::pClassPointer = NULL;

// Class TgGame.TgDamageTypeAOE
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeAOE : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 32005 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeAOE::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetTaskforce
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_SetTaskforce : public USequenceAction
{
public:
	int                                                TaskForceNumber;                                  		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 32012 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetTaskforce::pClassPointer = NULL;

// Class TgGame.TgSkeletalMeshActorNPCVendor
// 0x0007 (0x0D38 - 0x0D31)
class ATgSkeletalMeshActorNPCVendor : public ATgSkeletalMeshActorNPC
{
public:
	unsigned long                                      c_bHasMadeAPurchase : 1;                          		// 0x0D34 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 32780 ];

		return pClassPointer;
	};

	void eventPawnEnteredPresence ( class ATgPawn* P );
	void ClientHasFinishedPurchasing ( );
};

UClass* ATgSkeletalMeshActorNPCVendor::pClassPointer = NULL;

// Class TgGame.TgAnimBlendByNPC
// 0x0000 (0x012C - 0x012C)
class UTgAnimBlendByNPC : public UTgAnimNodeBlendList
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 33395 ];

		return pClassPointer;
	};

	void eventOnBecomeRelevant ( );
};

UClass* UTgAnimBlendByNPC::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendByAFK
// 0x000C (0x0138 - 0x012C)
class UTgAnimNodeBlendByAFK : public UTgAnimNodeBlendList
{
public:
	float                                              c_BlendTimeToTransition;                          		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_BlendTimeToLoop;                                		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_BlendTimeToDefault;                             		// 0x0134 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 33582 ];

		return pClassPointer;
	};

	void eventOnChildAnimEnd ( class UAnimNodeSequence* Child, float PlayedTime, float ExcessTime );
	void StopAFK ( );
	void PlayAFK ( );
};

UClass* UTgAnimNodeBlendByAFK::pClassPointer = NULL;

// Class TgGame.TgAnimNodeBlendNPC
// 0x0038 (0x0164 - 0x012C)
class UTgAnimNodeBlendNPC : public UTgAnimNodeBlendList
{
public:
	float                                              m_NoCustomerPresentBlendInTime;                   		// 0x012C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_CustomerPresentBlendInTime;                     		// 0x0130 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_GreetingBlendInTime;                            		// 0x0134 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_NoSaleBlendInTime;                              		// 0x0138 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_CallOutBlendInTime;                             		// 0x013C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_SaleBlendInTime;                                		// 0x0140 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_TransCustomerPresentToNotPresentBlendInTime;    		// 0x0144 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FName >                             m_UninterruptibleAnims;                           		// 0x0148 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned char                                      m_QueuedChild;                                    		// 0x0154 (0x0001) [0x0000000000000000]              
	float                                              m_QueuedBlendTime;                                		// 0x0158 (0x0004) [0x0000000000000000]              
	struct FName                                       m_CurrentAnimPlaying;                             		// 0x015C (0x0008) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 33770 ];

		return pClassPointer;
	};

	void eventOnChildAnimEnd ( class UAnimNodeSequence* Child, float PlayedTime, float ExcessTime );
	void PlaySaleAnimation ( );
	void PlayNoSaleAnimation ( );
	void PlayCallOutAnimation ( );
	void PlayCustomerPresentAnimation ( );
	void PlayGreetingAnimation ( );
	void PlayNoCustomerPresentAnimation ( );
	void QueueActiveChild ( unsigned char QueuedChild, float BlendTime );
	bool IsAnUninterruptableAnim ( struct FName AnimName );
};

UClass* UTgAnimNodeBlendNPC::pClassPointer = NULL;

// Class TgGame.TgAnimNodeSequenceByBoneRotation
// 0x001A (0x0138 - 0x011E)
class UTgAnimNodeSequenceByBoneRotation : public UAnimNodeSequence
{
public:
	struct FName                                       BoneName;                                         		// 0x0120 (0x0008) [0x0000000000000001]              ( CPF_Edit )
	unsigned char                                      BoneAxis;                                         		// 0x0128 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	TArray< struct FAnimByRotation >                   AnimList;                                         		// 0x012C (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 33861 ];

		return pClassPointer;
	};

	void eventOnBecomeRelevant ( );
};

UClass* UTgAnimNodeSequenceByBoneRotation::pClassPointer = NULL;

// Class TgGame.TgAnimNotify_ViewShake
// 0x0044 (0x0080 - 0x003C)
class UTgAnimNotify_ViewShake : public UAnimNotify_Scripted
{
public:
	float                                              m_fShakeRadius;                                   		// 0x003C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fDuration;                                      		// 0x0040 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     RotAmplitude;                                     		// 0x0044 (0x000C) [0x0000000000000000]              
	struct FVector                                     RotFrequency;                                     		// 0x0050 (0x000C) [0x0000000000000000]              
	float                                              m_fAmplitude;                                     		// 0x005C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     LocFrequency;                                     		// 0x0060 (0x000C) [0x0000000000000000]              
	float                                              FOVAmplitude;                                     		// 0x006C (0x0004) [0x0000000000000000]              
	float                                              FOVFrequency;                                     		// 0x0070 (0x0004) [0x0000000000000000]              
	unsigned long                                      bUseBoneLocation : 1;                             		// 0x0074 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	struct FName                                       BoneName;                                         		// 0x0078 (0x0008) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 33951 ];

		return pClassPointer;
	};

	void eventNotify ( class AActor* Owner, class UAnimNodeSequence* AnimSeqInstigator );
};

UClass* UTgAnimNotify_ViewShake::pClassPointer = NULL;

// Class TgGame.TgAnnouncer
// 0x0048 (0x0214 - 0x01CC)
class ATgAnnouncer : public AInfo
{
public:
	struct FAnnouncerPackageInfo                       m_StatusSoundPackage;                             		// 0x01CC (0x0010) [0x0000000000000000]              
	struct FAnnouncerPackageInfo                       m_FallbackStatusSoundPackage;                     		// 0x01DC (0x0010) [0x0000000000000000]              
	unsigned char                                      m_byAnnouncerLevel;                               		// 0x01EC (0x0001) [0x0000000000000000]              
	unsigned char                                      m_byPlayingAnnouncementIndex;                     		// 0x01ED (0x0001) [0x0000000000000000]              
	TArray< struct FCachedSound >                      m_CachedSounds;                                   		// 0x01F0 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	unsigned long                                      m_bPrecachedBaseSounds : 1;                       		// 0x01FC (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      m_bPrecachedGameSounds : 1;                       		// 0x01FC (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      m_bEnglishOnly : 1;                               		// 0x01FC (0x0004) [0x0000000000000002] [0x00000004] ( CPF_Const )
	class UClass*                                      m_PlayingAnnouncementClass;                       		// 0x0200 (0x0004) [0x0000000000000000]              
	class ATgQueuedAnnouncement*                       m_Queue;                                          		// 0x0204 (0x0004) [0x0000000000000000]              
	float                                              m_fLastTimerCheck;                                		// 0x0208 (0x0004) [0x0000000000000000]              
	float                                              m_fGapTime;                                       		// 0x020C (0x0004) [0x0000000000000000]              
	class ATgPlayerController*                         m_PlayerOwner;                                    		// 0x0210 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34033 ];

		return pClassPointer;
	};

	void PrecacheAnnouncements ( );
	class USoundCue* PrecacheStatusSound ( struct FName AName );
	class USoundCue* GetSound ( struct FName AName );
	struct FString GetFullSoundName ( struct FAnnouncerPackageInfo Package, struct FName CueName );
	void PlayAnnouncement ( class UClass* InMessageClass, unsigned char m_byMessageIndex );
	void PlayAnnouncementNow ( class UClass* InMessageClass, unsigned char m_byMessageIndex );
	void Timer ( );
	void PostBeginPlay ( );
	void Destroyed ( );
};

UClass* ATgAnnouncer::pClassPointer = NULL;

// Class TgGame.TgQueuedAnnouncement
// 0x0009 (0x01D5 - 0x01CC)
class ATgQueuedAnnouncement : public AInfo
{
public:
	class ATgQueuedAnnouncement*                       m_NextAnnouncement;                               		// 0x01CC (0x0004) [0x0000000000000000]              
	class UClass*                                      m_AnnouncementClass;                              		// 0x01D0 (0x0004) [0x0000000000000000]              
	unsigned char                                      m_byMessageIndex;                                 		// 0x01D4 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34046 ];

		return pClassPointer;
	};

};

UClass* ATgQueuedAnnouncement::pClassPointer = NULL;

// Class TgGame.TgLocalMessage
// 0x0000 (0x0050 - 0x0050)
class UTgLocalMessage : public ULocalMessage
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34048 ];

		return pClassPointer;
	};

	void PrecacheGameAnnouncements ( class ATgAnnouncer* Announcer, class UClass* GameClass );
	void AddAnnouncement ( class ATgAnnouncer* Announcer, unsigned char m_byMessageIndex );
	struct FName AnnouncementSound ( unsigned char m_byMessageIndex );
	bool IsRewardAnnouncement ( unsigned char m_byMessageIndex );
	unsigned char AnnouncementLevel ( unsigned char m_byMessageIndex );
};

UClass* UTgLocalMessage::pClassPointer = NULL;

// Class TgGame.TgSeqAct_KillBots
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_KillBots : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34385 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_KillBots::pClassPointer = NULL;

// Class TgGame.TgSeqAct_DespawnBots
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_DespawnBots : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34388 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_DespawnBots::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetBot
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_GetBot : public USequenceAction
{
public:
	int                                                m_nBotNumber;                                     		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34392 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetBot::pClassPointer = NULL;

// Class TgGame.TgSeqAct_JoinTeam
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_JoinTeam : public USequenceAction
{
public:
	class AActor*                                      TeamLeader;                                       		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34400 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_JoinTeam::pClassPointer = NULL;

// Class TgGame.TgSeqAct_HackBot
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_HackBot : public USequenceAction
{
public:
	class AActor*                                      m_ControlPawn;                                    		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34407 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_HackBot::pClassPointer = NULL;

// Class TgGame.TgBaseObjective_KOTH
// 0x0004 (0x030C - 0x0308)
class ATgBaseObjective_KOTH : public ATgMissionObjective_Proximity
{
public:
	float                                              c_fPrevClientCaptTime;                            		// 0x0308 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34540 ];

		return pClassPointer;
	};

	bool eventUpdateObjectiveStatus ( unsigned char eStatus );
	void OnObjectiveStatusChange ( );
	unsigned char eventGetDefaultStatus ( );
	void eventResetObjective ( );
};

UClass* ATgBaseObjective_KOTH::pClassPointer = NULL;

// Class TgGame.TgBotStart
// 0x0000 (0x02BC - 0x02BC)
class ATgBotStart : public ATgNavigationPoint
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34698 ];

		return pClassPointer;
	};

};

UClass* ATgBotStart::pClassPointer = NULL;

// Class TgGame.TgDamageTypeBullet
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeBullet : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34870 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeBullet::pClassPointer = NULL;

// Class TgGame.TgDamageTypeExplosion
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeExplosion : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34872 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeExplosion::pClassPointer = NULL;

// Class TgGame.TgDamageTypeFalling
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeFalling : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34874 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeFalling::pClassPointer = NULL;

// Class TgGame.TgDamageTypeMelee
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeMelee : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34876 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeMelee::pClassPointer = NULL;

// Class TgGame.TgDamageTypeMeleeHeavy
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeMeleeHeavy : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34878 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeMeleeHeavy::pClassPointer = NULL;

// Class TgGame.TgDamageTypeMeleeLight
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeMeleeLight : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34880 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeMeleeLight::pClassPointer = NULL;

// Class TgGame.TgDamageTypeMinigun
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeMinigun : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34882 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeMinigun::pClassPointer = NULL;

// Class TgGame.TgDamageTypeOnFire
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeOnFire : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34884 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeOnFire::pClassPointer = NULL;

// Class TgGame.TgDamageTypePoison
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypePoison : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34886 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypePoison::pClassPointer = NULL;

// Class TgGame.TgDamageTypeRanged
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeRanged : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34888 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeRanged::pClassPointer = NULL;

// Class TgGame.TgDamageTypeShotgun
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeShotgun : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34890 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeShotgun::pClassPointer = NULL;

// Class TgGame.TgDamageTypeSnipe
// 0x0000 (0x00E0 - 0x00E0)
class UTgDamageTypeSnipe : public UTgDamageType
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34892 ];

		return pClassPointer;
	};

};

UClass* UTgDamageTypeSnipe::pClassPointer = NULL;

// Class TgGame.TgDebugCameraController
// 0x0000 (0x05D0 - 0x05D0)
class ATgDebugCameraController : public ADebugCameraController
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34903 ];

		return pClassPointer;
	};

	void OnDeactivate ( class APlayerController* PC );
	void Camera ( struct FName NewMode );
};

UClass* ATgDebugCameraController::pClassPointer = NULL;

// Class TgGame.TgDebugCameraInput
// 0x0000 (0x0168 - 0x0168)
class UTgDebugCameraInput : public UDebugCameraInput
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34915 ];

		return pClassPointer;
	};

};

UClass* UTgDebugCameraInput::pClassPointer = NULL;

// Class TgGame.TgDefensePoint
// 0x0018 (0x02D4 - 0x02BC)
class ATgDefensePoint : public ATgNavigationPoint
{
public:
	class AController*                                 CurrentUser;                                      		// 0x02BC (0x0004) [0x0000000000000000]              
	class ATgDefensePoint*                             NextDefensePoint;                                 		// 0x02C0 (0x0004) [0x0000000000000000]              
	unsigned long                                      bFirstScript : 1;                                 		// 0x02C4 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bSniping : 1;                                     		// 0x02C4 (0x0004) [0x0000000000000001] [0x00000002] ( CPF_Edit )
	unsigned long                                      bDontChangePosition : 1;                          		// 0x02C4 (0x0004) [0x0000000000000001] [0x00000004] ( CPF_Edit )
	unsigned long                                      bAvoid : 1;                                       		// 0x02C4 (0x0004) [0x0000000000000000] [0x00000008] 
	unsigned long                                      bDisabled : 1;                                    		// 0x02C4 (0x0004) [0x0000000000000000] [0x00000010] 
	unsigned long                                      bNotInVehicle : 1;                                		// 0x02C4 (0x0004) [0x0000000000000001] [0x00000020] ( CPF_Edit )
	unsigned char                                      Priority;                                         		// 0x02C8 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UClass*                                      WeaponPreference;                                 		// 0x02CC (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              NumChecked;                                       		// 0x02D0 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 34918 ];

		return pClassPointer;
	};

	class AActor* GetMoveTarget ( );
	bool HigherPriorityThan ( class ATgDefensePoint* S, class ATgAIController* B );
	void PreBeginPlay ( );
	void FreePoint ( );
	void Reset ( );
};

UClass* ATgDefensePoint::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetTaskForceNumber
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_GetTaskForceNumber : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 35132 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetTaskForceNumber::pClassPointer = NULL;

// Class TgGame.TgDummyActor
// 0x0000 (0x01CC - 0x01CC)
class ATgDummyActor : public AActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 36164 ];

		return pClassPointer;
	};

};

UClass* ATgDummyActor::pClassPointer = NULL;

// Class TgGame.TgDeviceVolumeInfo
// 0x0004 (0x01D0 - 0x01CC)
class ATgDeviceVolumeInfo : public AInfo
{
public:
	class ATgDeviceVolume*                             V;                                                		// 0x01CC (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 37279 ];

		return pClassPointer;
	};

	void eventTimer ( );
	void eventPostBeginPlay ( );
};

UClass* ATgDeviceVolumeInfo::pClassPointer = NULL;

// Class TgGame.TgEffect_Damage
// 0x0000 (0x0070 - 0x0070)
class UTgEffect_Damage : public UTgEffect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 37622 ];

		return pClassPointer;
	};

};

UClass* UTgEffect_Damage::pClassPointer = NULL;

// Class TgGame.TgEffect_Movement
// 0x0000 (0x0070 - 0x0070)
class UTgEffect_Movement : public UTgEffect
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 37624 ];

		return pClassPointer;
	};

};

UClass* UTgEffect_Movement::pClassPointer = NULL;

// Class TgGame.TgEffectBuff
// 0x0001 (0x0071 - 0x0070)
class UTgEffectBuff : public UTgEffect
{
public:
	unsigned char                                      m_BuffSourceType;                                 		// 0x0070 (0x0001) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 37626 ];

		return pClassPointer;
	};

	void TrackBuffDebuff ( class AActor* Buffer, class ATgPawn* Buffee, struct FImpactInfo Impact );
	void Remove ( class AActor* Target, unsigned long bResetToFollow );
	bool ApplyEffect ( class AActor* Target, struct FImpactInfo Impact, unsigned long bConvertDOT );
	bool ApplyBuff ( class AActor* Target, unsigned long bRemove, struct FImpactInfo Impact );
	unsigned char GetBuffType ( class AActor* Target );
	bool CanBeApplied ( class AActor* Target );
};

UClass* UTgEffectBuff::pClassPointer = NULL;

// Class TgGame.TgPawn_Hunter
// 0x0034 (0x1C64 - 0x1C30)
class ATgPawn_Hunter : public ATgPawn_Character
{
public:
	unsigned char                                      m_CurrentHuntClass;                               		// 0x1C30 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_PreviousHuntClass;                              		// 0x1C31 (0x0001) [0x0000000000000000]              
	unsigned char                                      m_EdPreviewClass;                                 		// 0x1C32 (0x0001) [0x0000000000000001]              ( CPF_Edit )
	class UTgSkeletalMeshComponent*                    m_ParentedClassMeshComponent;                     		// 0x1C34 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_SocketedClassMeshComponent;                     		// 0x1C38 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	struct FName                                       m_SocketName;                                     		// 0x1C3C (0x0008) [0x0000000000000000]              
	class UAnimSet*                                    m_AimingAnimSet;                                  		// 0x1C44 (0x0004) [0x0000000000000000]              
	float                                              m_fTransitionOutTime;                             		// 0x1C48 (0x0004) [0x0000000000000000]              
	float                                              m_fTransitionInTime;                              		// 0x1C4C (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingTransitionOutTime;                    		// 0x1C50 (0x0004) [0x0000000000000000]              
	float                                              m_fRemainingTransitionInTime;                     		// 0x1C54 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeAimOffset*                        m_AimOffsetNode;                                  		// 0x1C58 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_LookAt*                           m_HandLookAt;                                     		// 0x1C5C (0x0004) [0x0000000000000000]              
	class UAnimNodePlayCustomAnim*                     m_AimingTransitionAnimNode;                       		// 0x1C60 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 37734 ];

		return pClassPointer;
	};

	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
	float CalcHunterProtection ( float fInValue, class AActor* DamageInst );
	void eventOnPhaseChange ( );
	void ChangeHunterClass ( unsigned char NewClass );
	void HandleTransitionIn ( float DeltaSeconds );
	void HandleTransitionOut ( float DeltaSeconds );
	void TransitionOutComplete ( );
	void eventTick ( float DeltaSeconds );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_Hunter::pClassPointer = NULL;

// Class TgGame.TgElevatingVolume
// 0x0000 (0x0250 - 0x0250)
class ATgElevatingVolume : public APhysicsVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 38215 ];

		return pClassPointer;
	};

};

UClass* ATgElevatingVolume::pClassPointer = NULL;

// Class TgGame.TgEmitterCrashlanding
// 0x0014 (0x01E8 - 0x01D4)
class ATgEmitterCrashlanding : public ATgEmitterSpawnable
{
public:
	class UStaticMeshComponent*                        m_PrimaryMesh;                                    		// 0x01D4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UStaticMeshComponent*                        m_SecondaryMesh;                                  		// 0x01D8 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              ParticleDurationAfterImpact;                      		// 0x01DC (0x0004) [0x0000000000000000]              
	class ULensFlareComponent*                         m_LensFlare;                                      		// 0x01E0 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UAudioComponent*                             m_AudioComponent;                                 		// 0x01E4 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 38228 ];

		return pClassPointer;
	};

	void PostImpactComplete ( );
	void OnImpact ( );
	void SetAudio ( class USoundCue* SoundCueToSet );
	void SetSecondaryMesh ( class UStaticMesh* StaticMeshToSet );
	void SetPrimaryMesh ( class UStaticMesh* StaticMeshToSet );
};

UClass* ATgEmitterCrashlanding::pClassPointer = NULL;

// Class TgGame.TgScoreboard
// 0x0004 (0x046C - 0x0468)
class ATgScoreboard : public AScoreBoard
{
public:
	int                                                ScrollTop;                                        		// 0x0468 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 38767 ];

		return pClassPointer;
	};

	bool SBInputKey ( int ControllerId, struct FName Key, unsigned char Event, float AmountDepressed );
	void ChangeState ( unsigned long bIsVisible );
	void DrawHUD ( );
	void PostBeginPlay ( );
};

UClass* ATgScoreboard::pClassPointer = NULL;

// Class TgGame.TgTeamScoreboard
// 0x0004 (0x0470 - 0x046C)
class ATgTeamScoreboard : public ATgScoreboard
{
public:
	struct FColor                                      m_PlayerColor;                                    		// 0x046C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 38766 ];

		return pClassPointer;
	};

	void DrawTaskForceCol ( float X1, float X2, float Y, class ATgRepInfo_TaskForce* taskforce );
	void DrawCol ( float X1, float X2, float Y, class ATgRepInfo_Player* prep );
	void DrawHUD ( );
};

UClass* ATgTeamScoreboard::pClassPointer = NULL;

// Class TgGame.TgHitDisplayActor
// 0x0034 (0x0200 - 0x01CC)
class ATgHitDisplayActor : public AActor
{
public:
	TArray< class UTgSpecialFx* >                      c_HitSFXs;                                        		// 0x01CC (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< int >                                      c_HitSFXIds;                                      		// 0x01D8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	TArray< class UMaterialInstanceConstant* >         c_HitMICs;                                        		// 0x01E4 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )
	class AController*                                 c_OwnerController;                                		// 0x01F0 (0x0004) [0x0000000000000000]              
	struct FVector                                     c_OffsetDistance;                                 		// 0x01F4 (0x000C) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39142 ];

		return pClassPointer;
	};

	void LightupSegment ( unsigned char HitDisplayDirection, int Damage );
	void DisplayHit ( struct FVector HitDir, int Damage, class UClass* DamageType );
	void SetOwnerController ( class AController* NewOwner );
	void eventPostBeginPlay ( );
};

UClass* ATgHitDisplayActor::pClassPointer = NULL;

// Class TgGame.TgHoldSpot
// 0x0004 (0x02D8 - 0x02D4)
class ATgHoldSpot : public ATgDefensePoint
{
public:
	class AVehicle*                                    HoldVehicle;                                      		// 0x02D4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39180 ];

		return pClassPointer;
	};

	void FreePoint ( );
	class AActor* GetMoveTarget ( );
};

UClass* ATgHoldSpot::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TriggerInterpActor
// 0x000C (0x00F4 - 0x00E8)
class UTgSeqAct_TriggerInterpActor : public USequenceAction
{
public:
	struct FString                                     m_sStateName;                                     		// 0x00E8 (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39628 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TriggerInterpActor::pClassPointer = NULL;

// Class TgGame.TgInterpolatingCameraActor
// 0x0018 (0x0278 - 0x0260)
class ATgInterpolatingCameraActor : public ACameraActor
{
public:
	TArray< struct FInterpolatingCameraInfo >          m_CameraArray;                                    		// 0x0260 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	int                                                m_nCurrentCameraIndex;                            		// 0x026C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              m_fCurrentInterpValue;                            		// 0x0270 (0x0004) [0x0000000000000000]              
	float                                              m_fTargetInterpValue;                             		// 0x0274 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 39635 ];

		return pClassPointer;
	};

	void eventTick ( float DeltaTime );
	void GetCameraView ( float DeltaTime, struct FTPOV* OutPOV );
	void eventGetActorEyesViewPoint ( struct FVector* out_Location, struct FRotator* out_Rotation );
};

UClass* ATgInterpolatingCameraActor::pClassPointer = NULL;

// Class TgGame.TgKismetTestActor
// 0x0030 (0x0234 - 0x0204)
class ATgKismetTestActor : public ADynamicSMActor
{
public:
	int                                                m_nTestCount;                                     		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	int                                                r_nCurrentTest;                                   		// 0x0208 (0x0004) [0x0000000000000021]              ( CPF_Edit | CPF_Net )
	int                                                r_nPassCount;                                     		// 0x020C (0x0004) [0x0000000000000020]              ( CPF_Net )
	int                                                r_nFailCount;                                     		// 0x0210 (0x0004) [0x0000000000000020]              ( CPF_Net )
	TArray< class UTexture2D* >                        c_aTextures;                                      		// 0x0214 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class USoundCue*                                   c_PassSound;                                      		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class USoundCue*                                   c_FailSound;                                      		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	TArray< class AInterpActor* >                      c_aResultActors;                                  		// 0x0228 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 40036 ];

		return pClassPointer;
	};

	void eventReplicatedEvent ( struct FName VarName );
	void StartTest ( int Num );
	void FailTest ( int Num );
	void PassTest ( int Num );
	void eventPostBeginPlay ( );
	void SetTestColor ( int Num, struct FLinearColor Col );
	class APlayerController* GetLocalPlayer ( );
	void OnTestResult ( class UTgSeqAct_TestResult* Action );
};

UClass* ATgKismetTestActor::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TestResult
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_TestResult : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 40049 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TestResult::pClassPointer = NULL;

// Class TgGame.TgLevelCamera
// 0x0008 (0x0268 - 0x0260)
class ATgLevelCamera : public ACameraActor
{
public:
	int                                                m_nPriority;                                      		// 0x0260 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      r_bEnabled : 1;                                   		// 0x0264 (0x0004) [0x0000000000000021] [0x00000001] ( CPF_Edit | CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 40073 ];

		return pClassPointer;
	};

	bool IsValidCamera ( );
	void OnToggle ( class USeqAct_Toggle* Action );
};

UClass* ATgLevelCamera::pClassPointer = NULL;

// Class TgGame.TgSeqAct_TriggerEventObjective
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_TriggerEventObjective : public USequenceAction
{
public:
	int                                                m_nTaskForceId;                                   		// 0x00E8 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 40146 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_TriggerEventObjective::pClassPointer = NULL;

// Class TgGame.TgMorphFX
// 0x001C (0x01E8 - 0x01CC)
class ATgMorphFX : public AActor
{
public:
	class UMeshComponent*                              c_Mesh;                                           		// 0x01CC (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	float                                              c_fCurrMorphWeight;                               		// 0x01D0 (0x0004) [0x0000000000000000]              
	float                                              c_fMorphWeightIncrease;                           		// 0x01D4 (0x0004) [0x0000000000000000]              
	class UMorphNodeWeight*                            c_WeightNode;                                     		// 0x01D8 (0x0004) [0x0000000000000000]              
	struct FName                                       c_nmMorphWeightNodeName;                          		// 0x01DC (0x0008) [0x0000000000000000]              
	class UMaterialInstanceConstant*                   c_LaserTracerMIC;                                 		// 0x01E4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 40177 ];

		return pClassPointer;
	};

	void ChangeMorphNode ( float NewWeight );
	void MorphTimer ( );
	void Destroyed ( );
	void InitLaserTracer ( class UMeshComponent* Mesh, float fDuration, class AActor* HitActor );
	void InitMorphFx ( class UMeshComponent* Mesh, float fDuration );
};

UClass* ATgMorphFX::pClassPointer = NULL;

// Class TgGame.TgSeqAct_ParentAnimComponent
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_ParentAnimComponent : public USequenceAction
{
public:
	unsigned long                                      bDetach : 1;                                      		// 0x00E8 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 40381 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_ParentAnimComponent::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetTeamIndex
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_GetTeamIndex : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41428 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetTeamIndex::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SetPlayerLevel
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_SetPlayerLevel : public USequenceAction
{
public:
	int                                                m_nLevel;                                         		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41441 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_SetPlayerLevel::pClassPointer = NULL;

// Class TgGame.TgSeqAct_GetCharClass
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_GetCharClass : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41446 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_GetCharClass::pClassPointer = NULL;

// Class TgGame.TgSeqAct_MarkSpawnReturn
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_MarkSpawnReturn : public USequenceAction
{
public:
	class ATeleporter*                                 m_Teleporter;                                     		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41484 ];

		return pClassPointer;
	};

	void eventActivated ( );
};

UClass* UTgSeqAct_MarkSpawnReturn::pClassPointer = NULL;

// Class TgGame.TgSeqAct_LaunchHomeInstance
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_LaunchHomeInstance : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41493 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_LaunchHomeInstance::pClassPointer = NULL;

// Class TgGame.TgSeqAct_Killpawns
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_Killpawns : public UTgSeqAct_KillBots
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41504 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_Killpawns::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AddAnimSets
// 0x001C (0x0104 - 0x00E8)
class UTgSeqAct_AddAnimSets : public USequenceAction
{
public:
	TArray< class UAnimSet* >                          m_MaleAnimSets;                                   		// 0x00E8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< class UAnimSet* >                          m_FemaleAnimSets;                                 		// 0x00F4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	unsigned long                                      m_bAppendToExisting : 1;                          		// 0x0100 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 41507 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AddAnimSets::pClassPointer = NULL;

// Class TgGame.TgPawn_Switchblade
// 0x0010 (0x1C4C - 0x1C3C)
class ATgPawn_Switchblade : public ATgPawn_Boss
{
public:
	class ATgCollisionProxy_Vortex*                    m_Vortex;                                         		// 0x1C3C (0x0004) [0x0000000000000000]              
	class ATgCollisionProxy*                           m_ChargeAttackAnimProxy;                          		// 0x1C40 (0x0004) [0x0000000000000000]              
	class UAnimNodePlayCustomAnim*                     m_ChargeAttackCustomAnimNode;                     		// 0x1C44 (0x0004) [0x0000000000000000]              
	class UTgSpecialFx*                                m_SwitchbladeVortexSFX;                           		// 0x1C48 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42568 ];

		return pClassPointer;
	};

	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
	void PlayDying ( class UClass* DamageType, struct FVector HitLoc );
	void EndVortex ( );
	void StartVortex ( );
	void eventOnPhaseChange ( );
	void OnPhaseTransitionComplete ( );
	void PostBeginPlay ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_Switchblade::pClassPointer = NULL;

// Class TgGame.TgPawn_AndroidMinion
// 0x0004 (0x1C34 - 0x1C30)
class ATgPawn_AndroidMinion : public ATgPawn_Character
{
public:
	class UMaterialInstanceConstant*                   m_BodyMIC;                                        		// 0x1C30 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 42995 ];

		return pClassPointer;
	};

	void UpdateMaterialParameters ( );
	void Tick ( float DeltaTime );
};

UClass* ATgPawn_AndroidMinion::pClassPointer = NULL;

// Class TgGame.TgPawn_AVCompositeWalker
// 0x0000 (0x1638 - 0x1638)
class ATgPawn_AVCompositeWalker : public ATgPawn_Robot
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43067 ];

		return pClassPointer;
	};

};

UClass* ATgPawn_AVCompositeWalker::pClassPointer = NULL;

// Class TgGame.TgPawn_Raptor
// 0x0064 (0x1CA0 - 0x1C3C)
class ATgPawn_Raptor : public ATgPawn_Boss
{
public:
	struct FTgCameraValues                             c_FootCamValues;                                  		// 0x1C3C (0x005C) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      c_bUseFootCam : 1;                                		// 0x1C98 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )
	class UMaterialInstanceConstant*                   c_RaptorMIC;                                      		// 0x1C9C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43094 ];

		return pClassPointer;
	};

	bool DoJump ( unsigned long bUpdating );
	void eventEndCrouch ( float HeightAdjust );
	void eventStartCrouch ( float HeightAdjust );
	struct FTgCameraValues eventGetCameraValues ( );
	void eventUpdateMeshBoneControllers ( float DeltaTime );
	void Tick ( float DeltaSeconds );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_Raptor::pClassPointer = NULL;

// Class TgGame.TgPawn_Boss_Destroyer
// 0x0008 (0x1CA8 - 0x1CA0)
class ATgPawn_Boss_Destroyer : public ATgPawn_Raptor
{
public:
	class UGameSkelCtrl_Recoil*                        c_GunRecolTopRight;                               		// 0x1CA0 (0x0004) [0x0000000000000000]              
	class UGameSkelCtrl_Recoil*                        c_GunRecolTopLeft;                                		// 0x1CA4 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43122 ];

		return pClassPointer;
	};

	void OnDeviceFormFire ( int nEquipSlot );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_Boss_Destroyer::pClassPointer = NULL;

// Class TgGame.TgPawn_Brawler
// 0x0000 (0x1C30 - 0x1C30)
class ATgPawn_Brawler : public ATgPawn_Character
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43139 ];

		return pClassPointer;
	};

	void eventTick ( float DeltaSeconds );
	void OnDeviceFormFire ( int nEquipSlot );
};

UClass* ATgPawn_Brawler::pClassPointer = NULL;

// Class TgGame.TgPawn_Destructible
// 0x0008 (0x1634 - 0x162C)
class ATgPawn_Destructible : public ATgPawn
{
public:
	float                                              c_fImpulseStrength;                               		// 0x162C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              c_fImpulseRadius;                                 		// 0x1630 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43211 ];

		return pClassPointer;
	};

	bool eventPostPawnSetup ( );
	void PlayDyingPhysicsAndAnimation ( class UClass* TgDmgType, struct FVector HitLoc );
};

UClass* ATgPawn_Destructible::pClassPointer = NULL;

// Class TgGame.TgPawn_Detonator
// 0x0014 (0x164C - 0x1638)
class ATgPawn_Detonator : public ATgPawn_Robot
{
public:
	struct FDeathInfo                                  s_DeathInfo;                                      		// 0x1638 (0x0014) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43224 ];

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	bool DelayedDied ( );
	bool eventDied ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void SaveDeathInfo ( class AController* Killer, class UClass* dmgType, struct FVector HitLocation );
	void Detonate ( );
	void Tick ( float DeltaSeconds );
};

UClass* ATgPawn_Detonator::pClassPointer = NULL;

// Class TgGame.TgPawn_DuneCommander
// 0x0040 (0x1C7C - 0x1C3C)
class ATgPawn_DuneCommander : public ATgPawn_Boss
{
public:
	struct FVector                                     m_fCrashLandingStartPosition;                     		// 0x1C3C (0x000C) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     m_fCrashLandingEndLocation;                       		// 0x1C48 (0x000C) [0x0000000000000000]              
	struct FVector                                     m_fCrashLandingStartLocation;                     		// 0x1C54 (0x000C) [0x0000000000000000]              
	float                                              m_fCrashLandingRemainingTime;                     		// 0x1C60 (0x0004) [0x0000000000000000]              
	float                                              m_fCrashLandingDuration;                          		// 0x1C64 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	unsigned long                                      m_bCrashLandingEnabled : 1;                       		// 0x1C68 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      r_bDoCrashLanding : 1;                            		// 0x1C68 (0x0004) [0x0000000000000020] [0x00000002] ( CPF_Net )
	unsigned long                                      c_bClientCrashLanding : 1;                        		// 0x1C68 (0x0004) [0x0000000000000000] [0x00000004] 
	float                                              m_fRedHotRemainingTime;                           		// 0x1C6C (0x0004) [0x0000000000000000]              
	float                                              m_fRedHotDuration;                                		// 0x1C70 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              r_fInitCrashLandingTime;                          		// 0x1C74 (0x0004) [0x0000000000000000]              
	class ATgEmitterCrashlanding*                      m_CrashLandingTrailEmitter;                       		// 0x1C78 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43266 ];

		return pClassPointer;
	};

	void PlayDeployAnim ( );
	void PlayImpact ( );
	void Tick ( float DeltaSeconds );
	void StartCrashLanding ( );
	void EditCrashLanding ( );
	void DoCrashLanding ( );
	bool eventPostPawnSetup ( );
	void PostBeginPlay ( );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgPawn_DuneCommander::pClassPointer = NULL;

// Class TgGame.TgPawn_Elite_Alchemist
// 0x0004 (0x1C34 - 0x1C30)
class ATgPawn_Elite_Alchemist : public ATgPawn_Character
{
public:
	class UTgSkeletalMeshComponent*                    m_TubesMeshComponent;                             		// 0x1C30 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43302 ];

		return pClassPointer;
	};

	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_Elite_Alchemist::pClassPointer = NULL;

// Class TgGame.TgPawn_Elite_Assassin
// 0x000C (0x1C3C - 0x1C30)
class ATgPawn_Elite_Assassin : public ATgPawn_Character
{
public:
	class UAnimNodeBlend*                              m_UpperBodyPrePoseBlendNode;                      		// 0x1C30 (0x0004) [0x0000000000000000]              
	float                                              m_fPrePoseBlendDistance;                          		// 0x1C34 (0x0004) [0x0000000000000000]              
	float                                              m_fPrePoseBlendSpeed;                             		// 0x1C38 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43311 ];

		return pClassPointer;
	};

	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	void Tick ( float DeltaTime );
};

UClass* ATgPawn_Elite_Assassin::pClassPointer = NULL;

// Class TgGame.TgPawn_EscortRobot
// 0x0000 (0x1638 - 0x1638)
class ATgPawn_EscortRobot : public ATgPawn_Robot
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43324 ];

		return pClassPointer;
	};

	void PlayDyingPhysicsAndAnimation ( class UClass* TgDmgType, struct FVector HitLoc );
	void PlayTeleportOutFXTimer ( );
	void PlayDyingEffects ( );
};

UClass* ATgPawn_EscortRobot::pClassPointer = NULL;

// Class TgGame.TgPawn_GroundPetA
// 0x0024 (0x167C - 0x1658)
class ATgPawn_GroundPetA : public ATgPawn_TreadRobot
{
public:
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControlRank4_UR;                  		// 0x1658 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControlRank4_CR;                  		// 0x165C (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControlRank4_LR;                  		// 0x1660 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControlRank4_UL;                  		// 0x1664 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControlRank4_CL;                  		// 0x1668 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControlRank4_LL;                  		// 0x166C (0x0004) [0x0000000000000000]              
	class UAnimNodeBlend*                              m_BarrelExtendBlendNode;                          		// 0x1670 (0x0004) [0x0000000000000000]              
	class UAnimNodeAdditiveBlending*                   m_HasTargetBlendNode;                             		// 0x1674 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bPrevisHasTarget : 1;                           		// 0x1678 (0x0004) [0x0000000000000001] [0x00000001] ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43367 ];

		return pClassPointer;
	};

	void eventTick ( float DeltaTime );
	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_GroundPetA::pClassPointer = NULL;

// Class TgGame.TgPawn_Guardian
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Guardian : public ATgPawn_Boss
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43389 ];

		return pClassPointer;
	};

	void SetPhysAnimState ( unsigned char NewState );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_Guardian::pClassPointer = NULL;

// Class TgGame.TgPawn_HoverShieldSphere
// 0x0000 (0x1640 - 0x1640)
class ATgPawn_HoverShieldSphere : public ATgPawn_Hover
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43439 ];

		return pClassPointer;
	};

	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
};

UClass* ATgPawn_HoverShieldSphere::pClassPointer = NULL;

// Class TgGame.TgPawn_Inquisitor
// 0x0000 (0x1C30 - 0x1C30)
class ATgPawn_Inquisitor : public ATgPawn_NPC
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43524 ];

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
};

UClass* ATgPawn_Inquisitor::pClassPointer = NULL;

// Class TgGame.TgPawn_Iris
// 0x0001 (0x16C5 - 0x16C4)
class ATgPawn_Iris : public ATgPawn_Scanner
{
public:
	unsigned char                                      r_nStartNewScan;                                  		// 0x16C4 (0x0001) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43643 ];

		return pClassPointer;
	};

	void eventSensorSweepComplete ( );
	void DoSensorSweep ( );
	void eventDoClientSideAlarmEffects ( );
	void eventReplicatedEvent ( struct FName VarName );
};

UClass* ATgPawn_Iris::pClassPointer = NULL;

// Class TgGame.TgPawn_Reaper
// 0x0014 (0x1C50 - 0x1C3C)
class ATgPawn_Reaper : public ATgPawn_Boss
{
public:
	class UTgAnimNodeBlendList*                        m_AOEIdleBlendNode;                               		// 0x1C3C (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UAnimNodeSequence*                           m_BatterySeqNode;                                 		// 0x1C40 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UMaterialInstanceConstant*                   c_MIC;                                            		// 0x1C44 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	class UAnimNodeAdditiveBlending*                   m_BatteryBlendNode;                               		// 0x1C48 (0x0004) [0x0000000000002000]              ( CPF_Transient )
	float                                              r_fBatteryPct;                                    		// 0x1C4C (0x0004) [0x0000000000000020]              ( CPF_Net )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43717 ];

		return pClassPointer;
	};

	void eventTick ( float DeltaSeconds );
	void OnDeviceFormFire ( int nEquipSlot );
	void BlendOutBatteryBlend ( );
	void eventOnPhaseChange ( );
	bool eventPostPawnSetup ( );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_Reaper::pClassPointer = NULL;

// Class TgGame.TgPawn_Remote
// 0x0000 (0x162C - 0x162C)
class ATgPawn_Remote : public ATgPawn
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43747 ];

		return pClassPointer;
	};

};

UClass* ATgPawn_Remote::pClassPointer = NULL;

// Class TgGame.TgPawn_ScannerRecursive
// 0x0000 (0x16C4 - 0x16C4)
class ATgPawn_ScannerRecursive : public ATgPawn_Scanner
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43752 ];

		return pClassPointer;
	};

};

UClass* ATgPawn_ScannerRecursive::pClassPointer = NULL;

// Class TgGame.TgPawn_SiegeBarrage
// 0x000C (0x1678 - 0x166C)
class ATgPawn_SiegeBarrage : public ATgPawn_Siege
{
public:
	TArray< class USkelControlSingleBone* >            c_ExhaustSkelControls;                            		// 0x166C (0x000C) [0x0000000000400000]              ( CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43806 ];

		return pClassPointer;
	};

	void EndExhaustEffect ( );
	void PlayExhaustEffect ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_SiegeBarrage::pClassPointer = NULL;

// Class TgGame.TgPawn_SiegeHover
// 0x0000 (0x166C - 0x166C)
class ATgPawn_SiegeHover : public ATgPawn_Siege
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43822 ];

		return pClassPointer;
	};

	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_SiegeHover::pClassPointer = NULL;

// Class TgGame.TgPawn_SiegeRapidFire
// 0x0004 (0x1670 - 0x166C)
class ATgPawn_SiegeRapidFire : public ATgPawn_Siege
{
public:
	class UGameSkelCtrl_Recoil*                        c_RecoilSkelControl;                              		// 0x166C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43830 ];

		return pClassPointer;
	};

	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_SiegeRapidFire::pClassPointer = NULL;

// Class TgGame.TgPawn_SupportForeman
// 0x0004 (0x163C - 0x1638)
class ATgPawn_SupportForeman : public ATgPawn_Robot
{
public:
	class UMaterialInstanceConstant*                   c_MIC;                                            		// 0x1638 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43874 ];

		return pClassPointer;
	};

	void eventOnPhaseChange ( );
	bool eventPostPawnSetup ( );
	void CheckBeingTargeted ( );
};

UClass* ATgPawn_SupportForeman::pClassPointer = NULL;

// Class TgGame.TgPawn_ThinkTank
// 0x0004 (0x1C40 - 0x1C3C)
class ATgPawn_ThinkTank : public ATgPawn_Boss
{
public:
	class UTgSpecialFx*                                c_ThinkTankShieldSFX;                             		// 0x1C3C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 43913 ];

		return pClassPointer;
	};

	void eventOnPhaseChange ( );
};

UClass* ATgPawn_ThinkTank::pClassPointer = NULL;

// Class TgGame.TgPawn_TurretFlak
// 0x0024 (0x1C9C - 0x1C78)
class ATgPawn_TurretFlak : public ATgPawn_Turret
{
public:
	class UTgSkelCon_SpinControl*                      m_BarrelSpinSkelControl;                          		// 0x1C78 (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsFiring : 1;                                  		// 0x1C7C (0x0004) [0x0000000000000000] [0x00000001] 
	float                                              m_fCurrentAmmoBeltValue;                          		// 0x1C80 (0x0004) [0x0000000000000000]              
	float                                              m_fAmmoBeltSpeed;                                 		// 0x1C84 (0x0004) [0x0000000000000000]              
	float                                              m_fCurrentRedHotBarrelValue;                      		// 0x1C88 (0x0004) [0x0000000000000000]              
	float                                              m_fTimeTillRedHotBarrelStarts;                    		// 0x1C8C (0x0004) [0x0000000000000000]              
	float                                              m_fRedHotBarrelBlendInSpeed;                      		// 0x1C90 (0x0004) [0x0000000000000000]              
	float                                              m_fRedHotBarrelBlendOutSpeed;                     		// 0x1C94 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_RotationControl;                                		// 0x1C98 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44066 ];

		return pClassPointer;
	};

	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void DoFireMaterialEffects ( float DeltaTime );
	void Tick ( float DeltaTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_TurretFlak::pClassPointer = NULL;

// Class TgGame.TgPawn_TurretFlame
// 0x0004 (0x1C7C - 0x1C78)
class ATgPawn_TurretFlame : public ATgPawn_Turret
{
public:
	class USkelControlSingleBone*                      m_RotationControl;                                		// 0x1C78 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44093 ];

		return pClassPointer;
	};

	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_TurretFlame::pClassPointer = NULL;

// Class TgGame.TgPawn_TurretPlasma
// 0x0014 (0x1C8C - 0x1C78)
class ATgPawn_TurretPlasma : public ATgPawn_Turret
{
public:
	class UAnimNodeSequence*                           m_AimAnimSequenceNode;                            		// 0x1C78 (0x0004) [0x0000000000000000]              
	class UTgAnimNodeAimOffset*                        m_AimOffsetNode;                                  		// 0x1C7C (0x0004) [0x0000000000000000]              
	float                                              m_AimAnimMin;                                     		// 0x1C80 (0x0004) [0x0000000000000000]              
	float                                              m_AimAnimMax;                                     		// 0x1C84 (0x0004) [0x0000000000000000]              
	class USkelControlSingleBone*                      m_RotationControl;                                		// 0x1C88 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44104 ];

		return pClassPointer;
	};

	void Tick ( float DeltaTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_TurretPlasma::pClassPointer = NULL;

// Class TgGame.TgPawn_UberWalker
// 0x0014 (0x1C50 - 0x1C3C)
class ATgPawn_UberWalker : public ATgPawn_Boss
{
public:
	class UTgSkelCon_SpinControl*                      m_LeftBarrelSpinSkelControl;                      		// 0x1C3C (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_RightBarrelSpinSkelControl;                     		// 0x1C40 (0x0004) [0x0000000000000000]              
	class UTgAnimBlendByRangeUseType*                  m_RocketRangeUseTypeNode;                         		// 0x1C44 (0x0004) [0x0000000000000000]              
	class UTgAnimBlendByRangeUseType*                  m_MinigunRangeUseTypeNode;                        		// 0x1C48 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           m_DeathTest;                                      		// 0x1C4C (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44122 ];

		return pClassPointer;
	};

	void PlayDyingPhysicsAndAnimation ( class UClass* TgDmgType, struct FVector HitLoc );
	void eventOnPhaseChange ( );
	void OnDeviceFormStopFire ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
};

UClass* ATgPawn_UberWalker::pClassPointer = NULL;

// Class TgGame.TgPawn_Vanguard
// 0x0018 (0x1C54 - 0x1C3C)
class ATgPawn_Vanguard : public ATgPawn_Boss
{
public:
	class UTgSkeletalMeshComponent*                    m_PilotMesh;                                      		// 0x1C3C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UGameSkelCtrl_Recoil*                        c_FootstepRecoilSkelControl;                      		// 0x1C40 (0x0004) [0x0000000000000000]              
	class UGameSkelCtrl_Recoil*                        c_GunRecoilSkelControl;                           		// 0x1C44 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_MinigunSpinSkelControl;                         		// 0x1C48 (0x0004) [0x0000000000000000]              
	class UTgSkelCon_SpinControl*                      m_EnergyGunSpinSkelControl;                       		// 0x1C4C (0x0004) [0x0000000000000000]              
	unsigned long                                      m_bIsPlayingTractorBeamFireAnim : 1;              		// 0x1C50 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44142 ];

		return pClassPointer;
	};

	void eventTick ( float DeltaSeconds );
	void PlayFootstepRecoil ( );
	bool eventPostPawnSetup ( );
	void StopGunRecoil ( );
	void StopTractorBeamFire ( );
	void OnDeviceFormStopFire ( );
	void PlayGunRecoil ( );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormBuildup ( int nEquipSlot );
	void StopFullBodyAnimation ( float BlendOutTime );
	void eventPostInitAnimTree ( class USkeletalMeshComponent* SkelComp );
	struct FTgCameraValues eventGetCameraValues ( );
};

UClass* ATgPawn_Vanguard::pClassPointer = NULL;

// Class TgGame.TgPawn_Vulcan
// 0x0000 (0x1C3C - 0x1C3C)
class ATgPawn_Vulcan : public ATgPawn_Boss
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44197 ];

		return pClassPointer;
	};

	void eventOnPhaseChange ( );
};

UClass* ATgPawn_Vulcan::pClassPointer = NULL;

// Class TgGame.TgPawn_Warlord
// 0x000C (0x1C48 - 0x1C3C)
class ATgPawn_Warlord : public ATgPawn_Boss
{
public:
	class UTgSkeletalMeshComponent*                    m_SwordMesh;                                      		// 0x1C3C (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	class UTgSkeletalMeshComponent*                    m_GunMesh;                                        		// 0x1C40 (0x0004) [0x0000000004080008]              ( CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned long                                      m_bLastBuildupAnimIsShockwave : 1;                		// 0x1C44 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44204 ];

		return pClassPointer;
	};

	void StopFullBodyAnimation ( float BlendOutTime );
	void OnDeviceFormFire ( int nEquipSlot );
	void OnDeviceFormBuildup ( int nEquipSlot );
	bool eventPostPawnSetup ( );
};

UClass* ATgPawn_Warlord::pClassPointer = NULL;

// Class TgGame.TgPhysAnimTestActor
// 0x0088 (0x0254 - 0x01CC)
class ATgPhysAnimTestActor : public AActor
{
public:
	TArray< struct FName >                             LowerBoneNames;                                   		// 0x01CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             LinearBoneSpringNames;                            		// 0x01D8 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	TArray< struct FName >                             AngularBoneSpringNames;                           		// 0x01E4 (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )
	class USkeletalMeshComponent*                      SkeletalMeshComponent;                            		// 0x01F0 (0x0004) [0x0000000004080009]              ( CPF_Edit | CPF_ExportObject | CPF_Component | CPF_EditInline )
	unsigned char                                      CurrentState;                                     		// 0x01F4 (0x0001) [0x0000000000000000]              
	unsigned long                                      bBlendToGetUp : 1;                                		// 0x01F8 (0x0004) [0x0000000000000000] [0x00000001] 
	unsigned long                                      bBlendingBack : 1;                                		// 0x01F8 (0x0004) [0x0000000000000000] [0x00000002] 
	unsigned long                                      bRampingDownMotors : 1;                           		// 0x01F8 (0x0004) [0x0000000000000000] [0x00000004] 
	unsigned long                                      bNextPokeKnocksDown : 1;                          		// 0x01F8 (0x0004) [0x0000000000000000] [0x00000008] 
	float                                              GetUpBlendStartTime;                              		// 0x01FC (0x0004) [0x0000000000000000]              
	float                                              GetUpBlendTime;                                   		// 0x0200 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              GetUpToIdleTime;                                  		// 0x0204 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              ActorOriginHeight;                                		// 0x0208 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              PokePauseTime;                                    		// 0x020C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              PokeBlendTime;                                    		// 0x0210 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              BlendBackStartTime;                               		// 0x0214 (0x0004) [0x0000000000000000]              
	float                                              MotorDownStartTime;                               		// 0x0218 (0x0004) [0x0000000000000000]              
	float                                              MotorDownTime;                                    		// 0x021C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              MotorDownAnimTime;                                		// 0x0220 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              BlendStaggerAnimTime;                             		// 0x0224 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              StaggerSpeedAdj;                                  		// 0x0228 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              StaggerVel;                                       		// 0x022C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	struct FVector                                     MoveDir;                                          		// 0x0230 (0x000C) [0x0000000000000000]              
	float                                              AngularHipDriveScale;                             		// 0x023C (0x0004) [0x0000000000000001]              ( CPF_Edit )
	float                                              StaggerMuscleScale;                               		// 0x0240 (0x0004) [0x0000000000000001]              ( CPF_Edit )
	class UAnimNodeBlend*                              BlendNode;                                        		// 0x0244 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           GetUpNode;                                        		// 0x0248 (0x0004) [0x0000000000000000]              
	class UAnimNodeSequence*                           RunNode;                                          		// 0x024C (0x0004) [0x0000000000000000]              
	class URB_BodyInstance*                            HipBody;                                          		// 0x0250 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44258 ];

		return pClassPointer;
	};

	void eventOnAnimEnd ( class UAnimNodeSequence* SeqNode, float PlayedTime, float ExcessTime );
	void Tick ( float DeltaSeconds );
	void SetAllMotorsAngularDriveStrength ( float InAngularSpringStrength, float InAngularDampingStrength, float InAngularForceLimitStrength, class USkeletalMeshComponent* SkelMeshComp );
	void RecoverFromRagdoll ( );
	void SetBoneSprings ( unsigned long bEnabled );
	bool IsAngularBoneSpringName ( struct FName InName );
	bool IsLinearBoneSpringName ( struct FName InName );
	void SetLowerFixed ( );
	void DetachAttachments ( );
	bool IsLowerBodyName ( struct FName InName );
	void SetBodiesFixed ( unsigned long InFixed );
	void EnableMotors ( unsigned long InEnabled );
	void SetPATAState ( unsigned char NewState );
	void EndGrab ( );
	bool PreGrab ( );
	bool PrePokeActor ( struct FVector PokeDir );
	void BoneImpulse ( struct FVector Impulse, struct FName BoneName );
	void PostBeginPlay ( );
};

UClass* ATgPhysAnimTestActor::pClassPointer = NULL;

// Class TgGame.TgPickupFactory_Item
// 0x0014 (0x0304 - 0x02F0)
class ATgPickupFactory_Item : public ATgPickupFactory
{
public:
	class USoundCue*                                   PickupSound;                                      		// 0x02F0 (0x0004) [0x0000000000000000]              
	struct FString                                     PickupMessage;                                    		// 0x02F4 (0x000C) [0x0000000000408002]              ( CPF_Const | CPF_Localized | CPF_NeedCtorLink )
	float                                              RespawnTime;                                      		// 0x0300 (0x0004) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 44385 ];

		return pClassPointer;
	};

	float BotDesireability ( class APawn* P );
	float GetRespawnTime ( );
	void SetRespawn ( );
	void SpawnCopyFor ( class APawn* Recipient );
	struct FString GetLocalString ( int Switch, class APlayerReplicationInfo* RelatedPRI, class APlayerReplicationInfo* RelatedPRI01 );
	void InitializePickup ( );
};

UClass* ATgPickupFactory_Item::pClassPointer = NULL;

// Class TgGame.TgSeqAct_CameraShake
// 0x0038 (0x0120 - 0x00E8)
class UTgSeqAct_CameraShake : public USequenceAction
{
public:
	struct FViewShakeInfo                              CameraShake;                                      		// 0x00E8 (0x0038) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 45310 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_CameraShake::pClassPointer = NULL;

// Class TgGame.TgSeqAct_RestartPlayers
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_RestartPlayers : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 45812 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_RestartPlayers::pClassPointer = NULL;

// Class TgGame.TgProj_Grenade
// 0x0000 (0x0294 - 0x0294)
class ATgProj_Grenade : public ATgProj_Bounce
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46468 ];

		return pClassPointer;
	};

};

UClass* ATgProj_Grenade::pClassPointer = NULL;

// Class TgGame.TgProj_Net
// 0x000C (0x0294 - 0x0288)
class ATgProj_Net : public ATgProjectile
{
public:
	struct FVector                                     c_Dir;                                            		// 0x0288 (0x000C) [0x0000000000000000]              

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46526 ];

		return pClassPointer;
	};

	void Init ( struct FVector Direction );
};

UClass* ATgProj_Net::pClassPointer = NULL;

// Class TgGame.TgProj_Teleporter
// 0x0004 (0x0294 - 0x0290)
class ATgProj_Teleporter : public ATgProj_FreeGrenade
{
public:
	unsigned long                                      m_bCollisionUpdated : 1;                          		// 0x0290 (0x0004) [0x0000000000000000] [0x00000001] 

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46555 ];

		return pClassPointer;
	};

	void TargetReached ( struct FVector vLocation );
	void eventHitWall ( struct FVector HitNormal, class AActor* Wall, class UPrimitiveComponent* WallComp );
	void eventLanded ( struct FVector HitNormal, class AActor* FloorActor );
	void SpawnExplosionEffects ( struct FVector HitLocation, struct FVector HitNormal, struct FIMPACT_FX ImpactFx );
	void GotoLocation ( struct FVector Loc );
	void CancelTeleporting ( );
	void CheckInterruptTeleport ( );
	void RangeReached ( );
	void Timer ( );
	void SetMeshCollision ( );
	void PostBeginPlay ( );
};

UClass* ATgProj_Teleporter::pClassPointer = NULL;

// Class TgGame.TgProj_StraightTeleporter
// 0x0000 (0x0294 - 0x0294)
class ATgProj_StraightTeleporter : public ATgProj_Teleporter
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46592 ];

		return pClassPointer;
	};

};

UClass* ATgProj_StraightTeleporter::pClassPointer = NULL;

// Class TgGame.TgReferenceArray
// 0x000C (0x01D8 - 0x01CC)
class ATgReferenceArray : public AActor
{
public:
	TArray< class UObject* >                           ObjectRefs;                                       		// 0x01CC (0x000C) [0x0000000000400001]              ( CPF_Edit | CPF_NeedCtorLink )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 46932 ];

		return pClassPointer;
	};

};

UClass* ATgReferenceArray::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AIFreeze
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_AIFreeze : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 47267 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AIFreeze::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AIStartFireAt
// 0x0001 (0x00E9 - 0x00E8)
class UTgSeqAct_AIStartFireAt : public USequenceAction
{
public:
	unsigned char                                      ForcedFireMode;                                   		// 0x00E8 (0x0001) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 47269 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AIStartFireAt::pClassPointer = NULL;

// Class TgGame.TgSeqAct_AIStopFire
// 0x0000 (0x00E8 - 0x00E8)
class UTgSeqAct_AIStopFire : public USequenceAction
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 47272 ];

		return pClassPointer;
	};

};

UClass* UTgSeqAct_AIStopFire::pClassPointer = NULL;

// Class TgGame.TgSeqAct_SpawnProjectile
// 0x0004 (0x00EC - 0x00E8)
class UTgSeqAct_SpawnProjectile : public USequenceAction
{
public:
	class UClass*                                      ProjectileClass;                                  		// 0x00E8 (0x0004) [0x0000000000000001]              ( CPF_Edit )

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 47357 ];

		return pClassPointer;
	};

	void eventActivated ( );
};

UClass* UTgSeqAct_SpawnProjectile::pClassPointer = NULL;

// Class TgGame.TgSoundInsulationVolume
// 0x0000 (0x0208 - 0x0208)
class ATgSoundInsulationVolume : public AVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 48222 ];

		return pClassPointer;
	};

	void eventUnTouch ( class AActor* Other );
	void eventTouch ( class AActor* Other, class UPrimitiveComponent* OtherComp, struct FVector HitLocation, struct FVector HitNormal );
};

UClass* ATgSoundInsulationVolume::pClassPointer = NULL;

// Class TgGame.TgStaticMeshActor
// 0x0000 (0x01F8 - 0x01F8)
class ATgStaticMeshActor : public AStaticMeshActor
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 48428 ];

		return pClassPointer;
	};

};

UClass* ATgStaticMeshActor::pClassPointer = NULL;

// Class TgGame.TgWaterVolume
// 0x0000 (0x0264 - 0x0264)
class ATgWaterVolume : public AWaterVolume
{
public:

private:
	static UClass* pClassPointer;

public:
	static UClass* StaticClass()
	{
		if ( ! pClassPointer )
			pClassPointer = (UClass*) UObject::GObjObjects()->Data[ 49283 ];

		return pClassPointer;
	};

};

UClass* ATgWaterVolume::pClassPointer = NULL;


#ifdef _MSC_VER
	#pragma pack ( pop )
#endif